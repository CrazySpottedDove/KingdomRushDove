-- chunkname: @./kr1/game_scripts.lua

require("klua.table")
require("i18n")
local scripts = require("scripts")
local AC = require("achievements")
require("game_scripts_utils")
-------------------------------------------
require("hero_scripts")(scripts)
require("tower_scripts")(scripts)
-------------------------------------------
scripts.mod_high_elven = {
    insert = function(this, store, script)
        local m = this.modifier
        local target = store.entities[m.target_id]

        if not target or not target.tower then
            log.info("cannot insert mod_high_elven to entity %s - ", target.id, target.template_name)
            return false
        end
        SU.insert_tower_damage_factor_buff(target, this.enhance_damage_factor + this.enhance_damage_factor_inc * m.level)

        signal.emit("mod-applied", this, target)

        return true
    end,
    remove = function(this, store, script)
        local m = this.modifier
        local target = store.entities[m.target_id]

        SU.remove_tower_damage_factor_buff(target, this.enhance_damage_factor + this.enhance_damage_factor_inc * m.level)

        return true
    end
}

scripts.mod_tower_decal = {}
function scripts.mod_tower_decal.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
	if not target or not target.tower then
		log.error("cannot insert mod_crossbow_eagle to entity %s - ", target.id, target.template_name)
		return false
	end
	signal.emit("mod-applied", this, target)
	return true
end
function scripts.mod_tower_decal.remove(this, store, script)
    return true
end

scripts.mod_crossbow_eagle = {}

function scripts.mod_crossbow_eagle.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
    local range_factor = this.range_factor + m.level * this.range_factor_inc
    local cooldown_factor = this.cooldown_factor + m.level * this.cooldown_factor_inc
	if not target or not target.tower then
		log.error("cannot insert mod_crossbow_eagle to entity %s - ", target.id, target.template_name)
		return false
	end
    SU.insert_tower_range_buff(target, range_factor, true)
    SU.insert_tower_cooldown_buff(target, cooldown_factor)

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_crossbow_eagle.remove(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
    local range_factor = this.range_factor + m.level * this.range_factor_inc
    local cooldown_factor = this.cooldown_factor + m.level * this.cooldown_factor_inc
    SU.remove_tower_range_buff(target, range_factor, true)
    SU.remove_tower_cooldown_buff(target, cooldown_factor)
	return true
end

scripts.aura_totem = {}

function scripts.aura_totem.update(this, store, script)
	local last_hit_ts = 0
	local a = this.aura
	local ring_sid = 1
	local ground_sid = 2
	local totem_sid = 3

	if GR:cell_is(this.pos.x, this.pos.y, TERRAIN_WATER) then
		local fx = E:create_entity("fx")

		fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
		fx.render.sprites[1].name = "totem_water_fx_enter"
		fx.render.sprites[1].anchor.y = 0.09
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	this.render.sprites[ring_sid].ts = store.tick_ts

	U.animation_start(this, "start", nil, store.tick_ts, 1, totem_sid)

	while not U.animation_finished(this, totem_sid) do
		coroutine.yield()
	end

	while store.tick_ts - this.aura.ts < a.duration + a.duration_inc * a.level do
		local enemies = table.filter(store.enemies, function(k, e)
			return not e.health.dead and band(e.vis.flags, this.aura.vis_bans) == 0 and band(e.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(e.pos, this.pos, this.aura.radius)
		end)

		for _, enemy in pairs(enemies) do
			local new_mod = E:create_entity(this.aura.mod)

			new_mod.modifier.level = this.aura.level
			new_mod.modifier.target_id = enemy.id
			new_mod.modifier.source_id = this.id

			queue_insert(store, new_mod)
		end

		last_hit_ts = store.tick_ts

		while store.tick_ts - last_hit_ts < this.aura.cycle_time do
			coroutine.yield()
		end
	end

	if GR:cell_is(this.pos.x, this.pos.y, TERRAIN_WATER) then
		local fx = E:create_entity("fx")

		fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
		fx.render.sprites[1].name = "totem_water_fx_exit"
		fx.render.sprites[1].anchor.y = 0.09
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	this.render.sprites[ground_sid].hidden = true
	this.render.sprites[ring_sid].hidden = true

	S:queue("TotemVanish")
	U.animation_start(this, "end", nil, store.tick_ts, 1, totem_sid)

	while not U.animation_finished(this, totem_sid) do
		coroutine.yield()
	end

	queue_remove(store, this)
end





scripts.twister = {}

function scripts.twister.insert(this, store, script)
	return true
end

function scripts.twister.update(this, store, script)
	local dmax = this.damage_max + this.aura.level * this.damage_inc
	local dmin = this.damage_min + this.aura.level * this.damage_inc
	local enemies_max = this.enemies_max + this.aura.level * this.enemies_inc

	U.animation_start(this, "start", nil, store.tick_ts, 1)

	while not U.animation_finished(this) do
		coroutine.yield()
	end

	S:queue("ArchmageTwisterTravel")
	U.animation_start(this, "travel", nil, store.tick_ts, -1)

	local np = this.nav_path

	np.ni = km.clamp(P:get_start_node(np.pi), P:get_end_node(np.pi), np.ni)

	local walk_nodes = this.nodes + this.aura.level * this.nodes_inc
	local nodes_step = -5
	local picked_enemies = this.picked_enemies
	local terrains = P:path_terrain_types(np.pi)

	terrains = band(terrains, bnot(TERRAIN_CLIFF))

	local last_node = P:get_start_node(np.pi) + this.nodes_limit

	for i = 1, math.ceil(walk_nodes / math.abs(nodes_step)) do
		if last_node >= np.ni and band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_CLIFF) == 0 then
			coroutine.yield()
			break
		end

		local next_pos = P:node_pos(np.pi, np.spi, np.ni + nodes_step)

		if P:is_node_valid(np.pi, np.ni + nodes_step, NF_TWISTER) and band(GR:cell_type(next_pos.x, next_pos.y), TERRAIN_CLIFF) == 0 then
			np.ni = np.ni + nodes_step
		end

		np.spi = np.spi == 2 and 3 or 2

		U.set_destination(this, P:node_pos(np.pi, np.spi, np.ni))

		while not this.motion.arrived do
			U.walk(this, store.tick_length)
			coroutine.yield()

			if this.interrupt then
				goto label_105_0
			end

			if enemies_max > #picked_enemies then
				local _, enemies = U.find_foremost_enemy(store.enemies, this.pos, 0, this.pickup_range, false, this.aura.vis_flags, this.aura.vis_bans, function(e)
					return (not e.enemy.counts.twister or e.enemy.counts.twister < this.max_times_applied) and band(bnot(e.enemy.valid_terrains), terrains) == 0
				end)

				if enemies then
					for _, enemy in ipairs(enemies) do
						if enemies_max > #picked_enemies then
							log.debug("^ twister %s picked up (%s)-%s", this.id, enemy.id, enemy.template_name)
							-- AC:inc_check("FUJITA5", 1)
							table.insert(picked_enemies, enemy)
							SU.remove_modifiers(store, enemy)
							SU.remove_auras(store, enemy)
							queue_remove(store, enemy)

							enemy.health.dead = true
							enemy.health.last_damage_types = DAMAGE_EAT
							enemy.main_script.co = nil
							enemy.main_script.runs = 0

							U.unblock_all(store, enemy)

							if enemy.ui then
								enemy.ui.can_click = false
							end

							if enemy.count_group then
								enemy.count_group.in_limbo = true
							end
						end
					end
				end
			end
		end
	end

	for _, enemy in pairs(picked_enemies) do
		if not enemy.enemy.counts.twister then
			enemy.enemy.counts.twister = 1
		else
			enemy.enemy.counts.twister = enemy.enemy.counts.twister + 1
		end

		log.debug("v twister %s dropped (%s)-%s", this.id, enemy.id, enemy.template_name)

		enemy.nav_path.pi = np.pi
		enemy.nav_path.ni = km.clamp(1, #P:path(np.pi) - 1, math.random(-3, 3) + np.ni)
		enemy.pos = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, enemy.nav_path.ni)
		enemy.main_script.runs = 1
		enemy.health.dead = false

		if enemy.ui then
			enemy.ui.can_click = true
		end

		enemy.motion.forced_waypoint = nil

		queue_insert(store, enemy)
	end

	coroutine.yield()

	for _, enemy in pairs(picked_enemies) do
		local d = E:create_entity("damage")
		d.source_id = this.id
		d.target_id = enemy.id
		d.value = math.random(dmin, dmax)
		d.damage_type = this.damage_type
		queue_damage(store, d)
        local m = E:create_entity(this.after_mod)
        m.source_id = this.id
        m.target_id = enemy.id
        queue_insert(store, m)
	end

	::label_105_0::

	this.picked_enemies = {}

	S:stop("ArchmageTwisterTravel")
	U.animation_start(this, "end", nil, store.tick_ts, 1)

	while not U.animation_finished(this) do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.pestilence = {}

function scripts.pestilence.insert(this, store, script)
	local duration = this.aura.duration + this.aura.level * this.aura.duration_inc

	this.actual_duration = duration

	local count = 2 + this.aura.level
	local points = {}

	this.aura.ts = store.tick_ts

	for i = 1, count do
		points[i] = V.v(this.pos.x + math.random(-42, 42), this.pos.y + math.random(-42, 42))
	end

	for _, dest in pairs(points) do
		local decal = E:create_entity("decal_tween")

		decal.pos.x, decal.pos.y = dest.x, dest.y
		decal.tween.props[1].keys = {
			{
				0,
				0
			},
			{
				0.1,
				255
			},
			{
				duration,
				255
			},
			{
				duration + 1.2,
				0
			}
		}
		decal.tween.props[1].name = "alpha"
		decal.render.sprites[1].name = "NecroPestilenceDecal"
		decal.render.sprites[1].animated = false
		decal.render.sprites[1].z = Z_DECALS
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	local smoke_offsets = {
		V.v(-17, 5),
		V.v(6, 13),
		V.v(3, -5),
		V.v(23, 3)
	}

	for _, dest in pairs(points) do
		for i, off in ipairs(smoke_offsets) do
			local sm = E:create_entity("decal_tween")

			sm.pos.x, sm.pos.y = dest.x + off.x, dest.y + off.y
			sm.tween.props[1].keys = {
				{
					0,
					0
				},
				{
					0.1,
					255
				},
				{
					duration,
					255
				},
				{
					duration + 1.2,
					0
				}
			}
			sm.tween.props[1].name = "alpha"
			sm.render.sprites[1].name = "pestilence_fx_decal_smoke"
			sm.render.sprites[1].z = Z_OBJECTS
			sm.render.sprites[1].ts = store.tick_ts
			sm.render.sprites[1].time_offset = i * 6 / FPS

			queue_insert(store, sm)
		end
	end

	for _, dest in pairs(points) do
		local s = E:create_entity("decal_timed")

		s.pos.x, s.pos.y = dest.x, dest.y
		s.render.sprites[1].name = "pestilence_fx_start_smoke"
		s.render.sprites[1].ts = store.tick_ts
		s.render.sprites[1].time_offset = math.random(0, 3) / 30

		queue_insert(store, s)
	end

	return true
end

scripts.necromancer_aura = {}

function scripts.necromancer_aura.update(this, store, script)
	local last_ts = store.tick_ts
	local tower_skeletons_count = 0
	local cg = store.count_groups[this.count_group_type]

	while true do
		local source = store.entities[this.aura.source_id]

		if not source then
			queue_remove(store, this)
			return
		end

		if store.tick_ts - last_ts >= this.aura.cycle_time then
			last_ts = store.tick_ts
			tower_skeletons_count = 0

			for _, e in pairs(store.soldiers) do
				if e and not e.health.dead and e.soldier.tower_id == source.id and e.template_name ~= "soldier_death_rider" then
					tower_skeletons_count = tower_skeletons_count + 1
				end
			end

			local max_spawns = math.min(this.max_skeletons_tower - tower_skeletons_count, this.count_group_max - (cg[this.count_group_name] or 0))

			if max_spawns < 1 then
				-- block empty
			else
				local dead_enemies = table.filter(store.enemies, function(k, v)
					return v.enemy and v.vis and v.health and v.health.dead and band(v.health.last_damage_types, bor(DAMAGE_EAT)) == 0 and band(v.vis.bans, F_SKELETON) == 0 and store.tick_ts - v.health.death_ts >= v.health.dead_lifetime - this.aura.cycle_time and U.is_inside_ellipse(v.pos, this.pos, source.attacks.range)
				end)

				dead_enemies = table.slice(dead_enemies, 1, max_spawns)

				for _, dead in pairs(dead_enemies) do
					dead.vis.bans = bor(dead.vis.bans, F_SKELETON)
					dead.health.delete_after = 0

					local e

					if dead.health.hp_max > this.min_health_for_knight then
						e = E:create_entity("soldier_skeleton_knight")
					else
						e = E:create_entity("soldier_skeleton")
					end

					e.pos = V.vclone(dead.pos)

					if dead.enemy.necromancer_offset then
						e.pos.x = e.pos.x + dead.enemy.necromancer_offset.x * (dead.render.sprites[1].flip_x and -1 or 1)
						e.pos.y = e.pos.y + dead.enemy.necromancer_offset.y
					end

					e.nav_rally.center = V.vclone(e.pos)
					e.nav_rally.pos = V.vclone(e.pos)
					e.soldier.tower_id = source.id

					queue_insert(store, e)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.mod_death_rider = {}

function scripts.mod_death_rider.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
    local level = m.level
	if not target or not target.health or target.health.dead then
		return false
	end

	target.health.armor = target.health.armor + (this.extra_armor + this.extra_armor_inc * level)
	target.unit.damage_factor = target.unit.damage_factor * (this.inflicted_damage_factor + this.inflicted_damage_factor_inc * level)

	return true
end

function scripts.mod_death_rider.remove(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
    local level = m.level
	if target then
		target.health.armor = target.health.armor - (this.extra_armor + this.extra_armor_inc * level)
		target.unit.damage_factor = target.unit.damage_factor /( this.inflicted_damage_factor + this.inflicted_damage_factor_inc * level)
	end

	return true
end

scripts.drill = {}

function scripts.drill.update(this, store, script)
	local b = this.bullet
	local target = store.entities[b.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	local no = P:predict_enemy_node_advance(target, b.flight_time)
	local pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + no)

	if GR:cell_is(pos.x, pos.y, TERRAIN_WATER) then
		U.animation_start(this, "water", nil, store.tick_ts, 1)
	else
		U.animation_start(this, "ground", nil, store.tick_ts, 1)
	end

	while store.tick_ts - this.render.sprites[1].ts < this.hit_time do
		coroutine.yield()
	end

	local d = E:create_entity("damage")

	d.damage_type = DAMAGE_INSTAKILL
	d.source_id = this.id
	d.target_id = target.id
	d.pop = b.pop
	d.pop_conds = b.pop_conds
	d.pop_chance = b.pop_chance

	queue_damage(store, d)

	while not U.animation_finished(this) do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.soldier_mecha = {}

function scripts.soldier_mecha.insert(this, store, script)
	this.attacks.order = U.attack_order(this.attacks.list)
	this.idle_flip.ts = store.tick_ts

	return true
end

function scripts.soldier_mecha.remove(this, store, script)
	S:stop("MechWalk")
	S:stop("MechSteam")

	return true
end

function scripts.soldier_mecha.update(this, store, script)
	local ab = this.attacks.list[1]
	local am = this.attacks.list[2]
	local ao = this.attacks.list[3]
	local pow_m = this.powers.missile
	local pow_o = this.powers.oil
	local ab_side = 1

	::label_67_0::

	while true do
		local r = this.nav_rally

		while r.new do
			r.new = false

			U.set_destination(this, r.pos)

			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

			U.animation_start(this, an, af, store.tick_ts, true, 1)
			S:queue("MechWalk")

			local ts = store.tick_ts

			while not this.motion.arrived and not r.new do
				if store.tick_ts - ts > 1 then
					ts = store.tick_ts

					S:queue("MechSteam")
				end

				U.walk(this, store.tick_length)
				coroutine.yield()

				this.motion.speed.x, this.motion.speed.y = 0, 0
			end

			S:stop("MechWalk")
			coroutine.yield()
		end

		if pow_o.level > 0 then
			if pow_o.changed then
				pow_o.changed = nil

				if pow_o.level == 1 then
					ao.ts = store.tick_ts
				end
			end

			if store.tick_ts - ao.ts > ao.cooldown * this.owner.tower.cooldown_factor then
				local _, targets = U.find_foremost_enemy(store.enemies, this.pos, ao.min_range, ao.max_range, true, ao.vis_flags, ao.vis_bans)

				if not targets then
					-- block empty
				else
					local target = table.random(targets)

					ao.ts = store.tick_ts

					local an, af = U.animation_name_facing_point(this, ao.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)
					U.y_wait(store, ao.hit_time)

					local b = E:create_entity(ao.bullet)

					b.pos.x = this.pos.x + (af and -1 or 1) * ao.start_offset.x
					b.pos.y = this.pos.y + ao.start_offset.y
					b.aura.level = pow_o.level
					b.aura.ts = store.tick_ts
					b.aura.source_id = this.id
					b.render.sprites[1].ts = store.tick_ts

					queue_insert(store, b)

					while not U.animation_finished(this) do
						coroutine.yield()
					end

					goto label_67_0
				end
			end
		end

		if pow_m.level > 0 then
			if pow_m.changed then
				pow_m.changed = nil

				if pow_m.level == 1 then
					am.ts = store.tick_ts
				end
			end

			if store.tick_ts - am.ts > am.cooldown * this.owner.tower.cooldown_factor then
				local _, targets = U.find_foremost_enemy(store.enemies, this.pos, am.min_range, am.max_range, false, am.vis_flags, am.vis_bans)

				if not targets then
					-- block empty
				else
					local target = table.random(targets)

					am.ts = store.tick_ts

					local an, af = U.animation_name_facing_point(this, am.animation_pre, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false, 1)

					while not U.animation_finished(this) do
						coroutine.yield()
					end

					local burst_count = am.burst + pow_m.level * am.burst_inc
					local fire_loops = burst_count / #am.hit_times

					for i = 1, fire_loops do
						local an, af = U.animation_name_facing_point(this, am.animation, target.pos)

						U.animation_start(this, an, af, store.tick_ts, false, 1)

						for hi, ht in ipairs(am.hit_times) do
							while ht > store.tick_ts - this.render.sprites[1].ts do
								if this.nav_rally.new then
									goto label_67_1
								end

								coroutine.yield()
							end

							local b = E:create_entity(am.bullet)

							b.pos.x = this.pos.x + (af and -1 or 1) * am.start_offsets[km.zmod(hi, #am.start_offsets)].x
							b.pos.y = this.pos.y + am.start_offsets[hi].y
							b.bullet.level = pow_m.level
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.v(b.pos.x + (af and -1 or 1) * am.launch_vector.x, b.pos.y + am.launch_vector.y)
							b.bullet.target_id = target.id
                            b.bullet.damage_factor = this.owner.tower.damage_factor

							queue_insert(store, b)

							_, targets = U.find_foremost_enemy(store.enemies, this.pos, am.min_range, am.max_range, false, am.vis_flags, am.vis_bans)

							if not targets then
								goto label_67_1
							end

							target = table.random(targets)
						end

						while not U.animation_finished(this) do
							coroutine.yield()
						end
					end

					::label_67_1::

					U.animation_start(this, am.animation_post, nil, store.tick_ts, false, 1)

					while not U.animation_finished(this) do
						coroutine.yield()
					end

					am.ts = store.tick_ts

					goto label_67_0
				end
			end
		end

		if store.tick_ts - ab.ts > ab.cooldown * this.owner.tower.cooldown_factor then
			local _, targets = U.find_foremost_enemy(store.enemies, this.pos, ab.min_range, ab.max_range, ab.node_prediction, ab.vis_flags, ab.vis_bans)

			if not targets then
				-- block empty
			else
				local target = table.random(targets)
				local pred_pos = P:predict_enemy_pos(target, ab.node_prediction)

				ab.ts = store.tick_ts
				ab_side = km.zmod(ab_side + 1, 2)

				local an, af = U.animation_name_facing_point(this, ab.animations[ab_side], target.pos)

				U.animation_start(this, an, af, store.tick_ts, false, 1)
				U.y_wait(store, ab.hit_times[ab_side])

				local b = E:create_entity(ab.bullet)

				b.bullet.damage_factor = this.owner.tower.damage_factor
				b.pos.x = this.pos.x + (af and -1 or 1) * ab.start_offsets[ab_side].x
				b.pos.y = this.pos.y + ab.start_offsets[ab_side].y
				b.bullet.from = V.vclone(b.pos)
				b.bullet.to = pred_pos
				b.bullet.source_id = this.id

				queue_insert(store, b)

				while not U.animation_finished(this) do
					if this.nav_rally.new then
						break
					end

					coroutine.yield()
				end

				goto label_67_0
			end
		end

		if store.tick_ts - this.idle_flip.ts > this.idle_flip.cooldown then
			this.idle_flip.ts = store.tick_ts

			local new_pos = V.vclone(this.pos)

			this.idle_flip.last_dir = -1 * this.idle_flip.last_dir
			new_pos.x = new_pos.x + this.idle_flip.last_dir * this.idle_flip.walk_dist

			if not GR:cell_is(new_pos.x, new_pos.y, TERRAIN_WATER) then
				r.new = true
				r.pos = new_pos

				goto label_67_0
			end
		end

		U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
		coroutine.yield()
	end
end

scripts.tower_elf_holder = {}

function scripts.tower_elf_holder.get_info()
	local tpl = E:get_template("tower_elf")
	local o = scripts.tower_barrack.get_info(tpl)
	return o
end

scripts.amazona_gain_mod = {}
function scripts.amazona_gain_mod.update(this, store, script)
    local m = this.modifier
    local target = store.entities[m.target_id]
    this.pos = target.pos
    local damage_limit = this.gain.damage_limit
    local hp_limit = this.gain.hp_limit
    local speed_limit = this.gain.speed_limit
    local cooldown_limit = this.gain.cooldown_limit
    local size_limit = this.gain.size_limit
    local whirwind_radius_base = 55
    local heal_base = 60
    while true do
        target = store.entities[m.target_id]
        if not target or target.health.dead then
            queue_remove(store, this)
            return
        end
        if this.render and m.use_mod_offset and target.unit.mod_offset then
            this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.mod_offset.x,
                target.unit.mod_offset.y
        end

        local has_kills = false

        for _, kid in pairs(target.track_kills.killed) do
            damage_limit = damage_limit - this.gain.damage
            if damage_limit >= 0 then
                for _, a in pairs(target.melee.attacks) do
                    a.damage_max = a.damage_max + this.gain.damage
                    a.damage_min = a.damage_min + this.gain.damage
                end
            end
            hp_limit = hp_limit - this.gain.hp
            if hp_limit >= 0 then
                target.health.hp_max = target.health.hp_max + this.gain.hp
            end
            speed_limit = speed_limit - this.gain.speed
            if speed_limit >= 0 then
                U.speed_inc_self(target, this.gain.speed)
            end
            cooldown_limit = cooldown_limit - this.gain.cooldown
            if cooldown_limit >= 0 then
                if target.melee.cooldown then
                    target.melee.cooldown = target.melee.cooldown - this.gain.cooldown
                end
            end
            size_limit = size_limit - this.gain.size
            if size_limit >= 0 then
                if not target.render.sprites[1].scale then
                    target.render.sprites[1].scale = vec_2(1+this.gain.size, 1+this.gain.size)
                else
                    target.render.sprites[1].scale.x = target.render.sprites[1].scale.x + this.gain.size
                    target.render.sprites[1].scale.y = target.render.sprites[1].scale.y + this.gain.size
                end
                target.melee.attacks[2].damage_radius = whirwind_radius_base * target.render.sprites[1].scale.x
            end
            target.health.hp = target.health.hp + heal_base * target.render.sprites[1].scale.x
            if target.health.hp_max < target.health.hp then
                target.health.hp = target.health.hp_max
            end
            has_kills = true
        end

        if has_kills then
            target.track_kills.killed = {}
            if this.render then
                this.render.sprites[1].ts = store.tick_ts
                this.render.sprites[1].hidden = false
            end
        end
        coroutine.yield()
    end
end

scripts.soldier_elf = {}
function scripts.soldier_elf.on_power_upgrade(this, power_name, power)
    if power_name == "bleed" then
        if this.powers.bleed.level > 0 then
            this.ranged.attacks[1].mod = "mod_elf_bleed"
            this.melee.attacks[1].mod = "mod_elf_bleed"
        end
    end
end

scripts.soldier_dwarf = {}

function scripts.soldier_dwarf.update(this, store, script)
	local brk, sta

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)
				end
			end
		end

		if this.health.dead then
			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if SU.y_soldier_new_rally(store, this) then
					goto label_180_0
				end
			end

			if this.powers.beer.level > 0 and this.health.hp > 0 and this.health.hp < this.beer.hp_trigger_factor * this.health.hp_max and store.tick_ts - this.beer.ts > this.beer.cooldown then
				this.beer.ts = store.tick_ts
				this.health.immune_to = DAMAGE_ALL

				U.y_animation_play(this, this.beer.animation, nil, store.tick_ts, 1)

				this.health.immune_to = 0

				local m = E:create_entity(this.beer.mod)

				m.pos = this.pos
				m.modifier.level = this.powers.beer.level
				m.modifier.target_id = this.id
				m.modifier.source_id = this.id

				queue_insert(store, m)

				goto label_180_0
			end

            brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

            if brk or sta ~= A_NO_TARGET then
                goto label_180_0
            end

			if SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_180_0::

		coroutine.yield()
	end
end


scripts.tower_sasquash_holder = {}

function scripts.tower_sasquash_holder.get_info()
	local tpl = E:get_template("tower_sasquash")
	local o = scripts.tower_barrack.get_info(tpl)

	-- o.respawn = nil

	return o
end

function scripts.tower_sasquash_holder.update(this, store)
	while true do
		local items = LU.list_entities(store.entities, "fx_fireball_explosion")

		if #items > 0 then
			for _, e in pairs(items) do
				if U.is_inside_ellipse(tpos(this), e.pos, this.unfreeze_radius) then
					this.tower.upgrade_to = this.unfreeze_upgrade_to

					SU.insert_sprite(store, this.unfreeze_fx, this.pos)
					queue_remove(store, this)

					return
				end
			end
		end

		coroutine.yield()
	end
end

scripts.soldier_barbarian = {}

function scripts.soldier_barbarian.on_power_upgrade(this, power_name, power)
	if not this._on_power_upgrade_called then
		this._on_power_upgrade_called = true
		this.ranged.attacks[1].animation = this.ranged.attacks[1].animation .. "2"
		this.melee.attacks[1].animation = this.melee.attacks[1].animation .. "2"
		this.melee.attacks[2].animation = this.melee.attacks[2].animation .. "2"
		this.render.sprites[1].angles.walk[1] = this.render.sprites[1].angles.walk[1] .. "2"
		this.idle_flip.last_animation = this.idle_flip.last_animation .. "2"
		this.soldier.melee_slot_offset = V.v(7, 0)
        this.melee.attacks[1].damage_type = DAMAGE_RUDE
        this.melee.attacks[2].damage_type = DAMAGE_RUDE
        this.ranged.attacks[1].bullet = "axe_barbarian_rude"
	end
end

scripts.soldier_sasquash = {}

function scripts.soldier_sasquash.insert(this, store)
	if not scripts.soldier_barrack.insert(this, store) then
		return false
	end

	AC:got("HENDERSON")

	return true
end

function scripts.hero_dracolich.insert(this, store)
    this.hero.fn_level_up(this, store)

    this.ranged.order = U.attack_order(this.ranged.attacks)

    return true
end

function scripts.hero_dracolich.update(this, store)
    local h = this.health
    local he = this.hero
    local a, skill, force_idle_ts

    local function skeleton_glow_fx()
        local fx = E:create_entity("fx_dracolich_skeleton_glow")

        fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].flip_x = this.render.sprites[1].flip_x
        fx.render.sprites[1].anchor.y = this.render.sprites[1].anchor.y

        queue_insert(store, fx)
    end

    U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)

    this.health_bar.hidden = false
    force_idle_ts = true

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)

            force_idle_ts = true
        end

        while this.nav_rally.new do
            SU.y_hero_new_rally(store, this)
        end

        if SU.hero_level_up(store, this) then
            U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
        end

        a = this.timed_attacks.list[1]
        skill = this.hero.skills.bonegolem

        if not a.disabled and store.tick_ts - a.ts > a.cooldown then
            local target = U.find_random_enemy(store.enemies, this.pos, a.min_range, a.max_range * 1.5, a.vis_flags,
                a.vis_bans, function(v)
                    local offset = P:predict_enemy_node_advance(v, a.spawn_time)
                    local ppos = P:node_pos(v.nav_path.pi, v.nav_path.spi, v.nav_path.ni + offset)

                    return P:is_node_valid(v.nav_path.pi, v.nav_path.ni + offset, NF_RALLY) and
                               GR:cell_is_only(ppos.x, ppos.y, TERRAIN_LAND)
                end)
            local spawn_pos

            if target then
                local offset = P:predict_enemy_node_advance(target, a.spawn_time)

                spawn_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + offset)
            else
                local positions = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_range, a.max_range, TERRAIN_LAND,
                    nil, NF_RALLY)

                spawn_pos = table.random(positions)
            end

            if not spawn_pos then
                SU.delay_attack(store, a, 0.4)
            else
                S:queue(a.sound)
                U.animation_start(this, "golem", nil, store.tick_ts)
                skeleton_glow_fx()
                U.y_wait(store, a.spawn_time)

                local e = E:create_entity(a.entity)

                e.pos = V.vclone(spawn_pos)
                e.nav_rally.pos = V.vclone(spawn_pos)
                e.nav_rally.center = V.vclone(spawn_pos)
                e.render.sprites[1].flip_x = math.random() < 0.5

                queue_insert(store, e)

                e.owner = this

                U.y_animation_wait(this)

                force_idle_ts = true
                a.ts = store.tick_ts

                SU.hero_gain_xp_from_skill(this, skill)

                goto label_407_1
            end
        end

        a = this.timed_attacks.list[2]
        skill = this.hero.skills.spinerain

        if not a.disabled and store.tick_ts - a.ts > a.cooldown then
            local target = U.find_random_enemy(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                a.vis_bans)

            if not target then
                SU.delay_attack(store, a, 0.4)
            else
                local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
                local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {pi}, nil, nil, NF_RALLY)

                if #nodes < 1 then
                    SU.delay_attack(store, a, 0.4)
                else
                    local s_pi, s_spi, s_ni = unpack(nodes[1])
                    local flip = target.pos.x < this.pos.x

                    U.animation_start(this, "spinerain", flip, store.tick_ts)
                    skeleton_glow_fx()
                    U.y_wait(store, a.spawn_time)

                    local delay = 0
                    local n_step = ni < s_ni and -2 or 2

                    ni = km.clamp(1, #P:path(s_pi), ni < s_ni and ni + 6 or ni)

                    for i = 1, skill.count[skill.level] do
                        local e = E:create_entity(a.entity)

                        e.pos = P:node_pos(pi, spi, ni)
                        e.render.sprites[1].prefix = e.render.sprites[1].prefix .. math.random(1, 3)
                        e.render.sprites[1].flip_x = not flip
                        e.delay = delay
                        e.bullet.source_id = this.id

                        queue_insert(store, e)

                        delay = delay + fts(U.frandom(1, 3))
                        ni = ni + n_step
                        spi = km.zmod(spi + math.random(1, 2), 3)
                    end

                    U.y_animation_wait(this)

                    force_idle_ts = true
                    a.ts = store.tick_ts

                    SU.hero_gain_xp_from_skill(this, skill)

                    goto label_407_1
                end
            end
        end

        a = this.timed_attacks.list[3]
        skill = this.hero.skills.diseasenova

        if not a.disabled and store.tick_ts - a.ts > a.cooldown then
            local targets = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                a.vis_bans)

            if not targets or #targets < a.min_count then
                SU.delay_attack(store, a, 0.4)
            else
                local start_ts = store.tick_ts

                this.health_bar.hidden = true
                this.health.ignore_damage = true

                U.animation_start(this, "nova", nil, store.tick_ts)
                S:queue(a.sound, {
                    delay = fts(10)
                })
                U.y_wait(store, a.hit_time)

                for _, target in pairs(targets) do
                    local d = E:create_entity("damage")

                    d.damage_type = a.damage_type
                    d.source_id = this.id
                    d.target_id = target.id
                    d.value = math.random(a.damage_min, a.damage_max)

                    queue_damage(store, d)

                    if a.mod then
                        local m = E:create_entity(a.mod)

                        m.modifier.source_id = this.id
                        m.modifier.target_id = target.id
                        m.modifier.xp_dest_id = this.id

                        queue_insert(store, m)
                    end
                end

                local fi, fo = 10, 35

                for i = 1, 6 do
                    local rx, ry = V.rotate(2 * math.pi * i / 6, 1, 0)
                    local fx = E:create_entity("fx_dracolich_nova_cloud")

                    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                    fx.tween.props[2].keys = {{0, V.v(rx * fi, ry * fi)}, {fts(20), V.v(rx * fo, ry * fo)}}
                    fx.tween.ts = store.tick_ts

                    queue_insert(store, fx)
                end

                local fx = E:create_entity("fx_dracolich_nova_explosion")

                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                fx.render.sprites[1].ts = store.tick_ts

                queue_insert(store, fx)

                local fx = E:create_entity("fx_dracolich_nova_decal")

                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                fx.render.sprites[1].ts = store.tick_ts

                queue_insert(store, fx)
                U.y_animation_wait(this)

                this.render.sprites[1].hidden = true

                U.y_wait(store, a.respawn_delay)

                this.render.sprites[1].hidden = nil

                S:queue(a.respawn_sound)
                U.y_animation_play(this, "respawn", nil, store.tick_ts)

                this.health_bar.hidden = false
                this.health.ignore_damage = false
                force_idle_ts = true
                a.ts = store.tick_ts

                SU.hero_gain_xp_from_skill(this, skill)
            end
        end

        a = this.timed_attacks.list[4]
        skill = this.hero.skills.plaguecarrier

        if not a.disabled and store.tick_ts - a.ts > a.cooldown then
            local targets_info = U.find_enemies_in_paths(store.enemies, this.pos, a.range_nodes_min, a.range_nodes_max,
                nil, a.vis_flags, a.vis_bans)

            if not targets_info then
                SU.delay_attack(store, a, 0.4)
            else
                local target

                for _, ti in pairs(targets_info) do
                    if GR:cell_is(ti.enemy.pos.x, ti.enemy.pos.y, TERRAIN_LAND) then
                        target = ti.enemy

                        break
                    end
                end

                if not target then
                    SU.delay_attack(store, a, 0.4)
                else
                    local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
                    local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {pi}, nil, nil, NF_RALLY)

                    if #nodes < 1 then
                        SU.delay_attack(store, a, 0.4)
                    else
                        local s_pi, s_spi, s_ni = unpack(nodes[1])
                        local dir = ni < s_ni and -1 or 1
                        local offset = math.random(a.range_nodes_min, a.range_nodes_min + 5)

                        s_ni = km.clamp(1, #P:path(s_pi), s_ni + (dir > 0 and offset or -offset))

                        local flip = P:node_pos(s_pi, s_spi, s_ni, true).x < this.pos.x

                        S:queue(a.sound)
                        U.animation_start(this, "plague", flip, store.tick_ts)
                        U.y_wait(store, a.spawn_time)

                        local delay = 0

                        for i = 1, a.count do
                            local e = E:create_entity(a.entity)

                            e.pos.x, e.pos.y = this.pos.x + (flip and -1 or 1) * a.spawn_offset.x,
                                this.pos.y + a.spawn_offset.y
                            e.nav_path.pi = s_pi
                            e.nav_path.spi = math.random(1, 3)
                            e.nav_path.ni = s_ni
                            e.nav_path.dir = dir
                            e.delay = delay
                            e.aura.source_id = this.id

                            queue_insert(store, e)

                            delay = delay + fts(U.frandom(1, 3))
                        end

                        U.y_animation_wait(this)

                        force_idle_ts = true
                        a.ts = store.tick_ts

                        SU.hero_gain_xp_from_skill(this, skill)

                        goto label_407_1
                    end
                end
            end
        end

        for _, i in pairs(this.ranged.order) do
            local a = this.ranged.attacks[i]

            if a.disabled then
                -- block empty
            elseif a.sync_animation and not this.render.sprites[1].sync_flag then
                -- block empty
            elseif store.tick_ts - a.ts < a.cooldown then
                -- block empty
            elseif math.random() > a.chance then
                -- block empty
            else
                local origin = V.v(this.pos.x, this.pos.y + a.bullet_start_offset[1].y)
                local bullet_t = E:get_template(a.bullet)
                local bullet_speed = bullet_t.bullet.min_speed
                local flight_time = bullet_t.bullet.flight_time
                local target = U.find_random_enemy(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,a.vis_bans)

                if target then
                    local start_ts = store.tick_ts
                    local b, emit_fx, emit_ps, emit_ts
                    local dist = V.dist(origin.x, origin.y, target.pos.x, target.pos.y)
                    local node_offset = P:predict_enemy_node_advance(target, dist / bullet_speed)
                    local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
                    local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)

                    U.animation_start(this, an, af, store.tick_ts)

                    while store.tick_ts - start_ts < a.shoot_time do
                        if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
                            goto label_407_0
                        end

                        coroutine.yield()
                    end

                    S:queue(a.sound)

                    b = E:create_entity(a.bullet)
                    b.bullet.target_id = target.id
                    b.bullet.source_id = this.id
                    b.pos = V.vclone(this.pos)
                    b.pos.x = b.pos.x + (af and -1 or 1) * a.bullet_start_offset[ai].x
                    b.pos.y = b.pos.y + a.bullet_start_offset[ai].y
                    b.bullet.from = V.vclone(b.pos)
                    b.bullet.to = V.v(t_pos.x, t_pos.y)

                    queue_insert(store, b)

                    a.ts = start_ts

                    while not U.animation_finished(this) do
                        if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
                            goto label_407_0
                        end

                        coroutine.yield()
                    end

                    force_idle_ts = true

                    ::label_407_0::

                    goto label_407_1
                end
            end
        end

        SU.soldier_idle(store, this, force_idle_ts)
        SU.soldier_regen(store, this)

        force_idle_ts = nil

        ::label_407_1::

        coroutine.yield()
    end
end

scripts.mod_dracolich_disease = {}

function scripts.mod_dracolich_disease.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if this.spread_active and target and target.health.dead and band(target.health.last_damage_types, DAMAGE_EAT) == 0 then
        local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, this.spread_radius,
            this.modifier.vis_flags, this.modifier.vis_bans)

        if targets then
            for _, t in pairs(targets) do
                local m = E:create_entity(this.template_name)

                m.modifier.target_id = t.id
                m.modifier.source_id = this.modifier.source_id
                m.modifier.xp_dest_id = this.modifier.xp_dest_id

                queue_insert(store, m)

                local d = E:create_entity("damage")

                d.source_id = this.id
                d.target_id = t.id
                d.value = this.spread_damage
                d.damage_type = this.dps.damage_type

                queue_damage(store, d)

                local h = store.entities[this.modifier.xp_dest_id]

                if h and h.hero then
                    SU.hero_gain_xp_from_skill(h, h.hero.skills.unstabledisease)
                end
            end
        end

        local fx = E:create_entity(this.spread_fx)

        fx.pos = V.vclone(this.pos)

        if target and this.modifier.use_mod_offset and target.unit.mod_offset then
            local mo = target.unit.mod_offset

            fx.pos.x, fx.pos.y = fx.pos.x + mo.x, fx.pos.y + mo.y
        end

        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end

    return true
end

scripts.dracolich_spine = {}

function scripts.dracolich_spine.update(this, store)
    local b = this.bullet

    U.sprites_hide(this)

    if this.delay then
        U.y_wait(store, this.delay)
    end

    U.sprites_show(this)

    local start_ts = store.tick_ts

    this.pos.x = this.pos.x + math.random(-4, 4)
    this.pos.y = this.pos.y + math.random(-5, 5)

    S:queue(this.sound_events.delayed_insert)
    U.animation_start(this, "start", nil, store.tick_ts, false, 1)

    this.tween.ts = store.tick_ts

    U.y_wait(store, b.hit_time)

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, b.damage_radius, b.damage_flags, b.damage_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = E:create_entity("damage")

            d.damage_type = b.damage_type
            d.source_id = this.id
            d.target_id = target.id
            d.value = math.random(b.damage_min, b.damage_max)

            queue_damage(store, d)

            if b.mod then
                local m = E:create_entity(b.mod)

                m.modifier.source_id = this.id
                m.modifier.target_id = target.id
                m.modifier.xp_dest_id = b.source_id

                queue_insert(store, m)
            end
        end
    end

    U.y_wait(store, b.duration - (store.tick_ts - start_ts))
    U.y_animation_play(this, "end", nil, store.tick_ts, 1, 1)
    queue_remove(store, this)
end

scripts.dracolich_plague_carrier = {}

function scripts.dracolich_plague_carrier.insert(this, store)
    next_pos = P:node_pos(this.nav_path)

    if not next_pos then
        return false
    end

    return true
end

function scripts.dracolich_plague_carrier.update(this, store)
    local y_off = 20
    local a = this.aura
    local m = this.motion
    local nav = this.nav_path
    local dt = store.tick_length
    local start_ni = nav.ni
    local start_ts = store.tick_ts
    local hit_ts = 0

    a.duration = a.duration + U.frandom(-a.duration_var, 0)
    m.max_speed = m.max_speed + math.random(0, m.max_speed_var)

    local step = this.motion.real_speed * dt
    local next_pos = P:node_pos(nav)

    next_pos.y = next_pos.y + y_off

    U.set_destination(this, next_pos)

    local v_heading = V.v(0, 0)

    v_heading.x, v_heading.y = V.normalize(next_pos.x - this.pos.x, next_pos.y - this.pos.y)

    local th_dist = 25
    local turn_speed = math.pi * 1.5
    local enemies_hit = {}

    if this.delay then
        this.render.sprites[1].hidden = true

        U.y_wait(store, this.delay)

        this.render.sprites[1].hidden = nil
    end

    local ps = E:create_entity("ps_dracolich_plague")

    ps.particle_system.track_id = this.id

    queue_insert(store, ps)

    while true do
        if this.tween.disabled and store.tick_ts - start_ts > a.duration then
            this.tween.disabled = nil
            this.tween.ts = store.tick_ts
            ps.particle_system.emit = false
        end

        if th_dist > V.len(m.dest.x - this.pos.x, m.dest.y - this.pos.y) then
            nav.ni = nav.ni + math.random(6, 11) * nav.dir

            local p_len = #P:path(nav.pi)

            if nav.ni <= 1 or p_len <= nav.ni then
                a.duration = 0
            end

            nav.ni = km.clamp(1, p_len, nav.ni)
            nav.spi = km.zmod(nav.spi + math.random(1, 2), 3)
            next_pos = P:node_pos(nav)
            next_pos.y = next_pos.y + y_off

            U.set_destination(this, next_pos)
        end

        local dx, dy = V.sub(m.dest.x, m.dest.y, this.pos.x, this.pos.y)
        local sa = km.short_angle(V.angleTo(dx, dy), V.angleTo(v_heading.x, v_heading.y))
        local angle_step = math.min(turn_speed * dt, math.abs(sa)) * km.sign(sa) * -1

        v_heading.x, v_heading.y = V.rotate(angle_step, v_heading.x, v_heading.y)

        local sx, sy = V.mul(step, v_heading.x, v_heading.y)

        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
        m.speed.x, m.speed.y = sx / dt, sy / dt
        this.render.sprites[1].r = V.angleTo(v_heading.x, v_heading.y)

        if store.tick_ts - hit_ts > a.damage_cycle then
            hit_ts = store.tick_ts

            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.damage_radius, a.damage_flags,
                a.damage_bans, function(v)
                    return not table.contains(enemies_hit, v)
                end)

            if not targets then
                -- block empty
            else
                for _, e in pairs(targets) do
                    local d = E:create_entity("damage")

                    d.source_id = this.id
                    d.target_id = e.id
                    d.value = math.random(a.damage_min, a.damage_max)
                    d.damage_type = a.damage_type

                    queue_damage(store, d)

                    if a.mod then
                        local m = E:create_entity(a.mod)

                        m.modifier.source_id = this.id
                        m.modifier.target_id = e.id
                        m.modifier.xp_dest_id = a.source_id

                        queue_insert(store, m)
                    end

                    table.insert(enemies_hit, e)
                end
            end
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.fireball_dragon = {}

function scripts.fireball_dragon.update(this, store)
    local b = this.bullet
    local mspeed = b.min_speed
    local tl = store.tick_length
    local ps
    local targeted_hit_offset = false

    if b.particles_name then
        ps = E:create_entity(b.particles_name)
        ps.particle_system.track_id = this.id

        queue_insert(store, ps)
    end

    local target = store.entities[b.target_id]

    if target then
        local dist = V.dist(this.pos.x, this.pos.y, target.pos.x, target.pos.y)
        local node_offset = P:predict_enemy_node_advance(target, dist / mspeed)

        b.to = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)

        if band(target.vis.flags, F_FLYING) ~= 0 and target.unit and target.unit.hit_offset then
            targeted_hit_offset = true
            b.to.x, b.to.y = b.to.x + target.unit.hit_offset.x, b.to.y + target.unit.hit_offset.y
        end
    end

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * tl do
        b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * tl, this.pos.y + b.speed.y * tl
        this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

        coroutine.yield()
    end

    local hit_center = V.vclone(b.to)

    if target and target.unit and target.unit.hit_offset and targeted_hit_offset then
        hit_center.y = hit_center.y - target.unit.hit_offset.y
    end

    local targets = U.find_enemies_in_range(store.enemies, hit_center, 0, b.damage_radius, b.vis_flags, b.vis_bans)

    if targets then
        for _, e in pairs(targets) do
            local d = SU.create_bullet_damage(b, e.id, this.id)

            d.xp_dest_id = b.source_id

            queue_damage(store, d)

            if b.mod then
                local mod = E:create_entity(b.mod)

                mod.modifier.target_id = e.id
                mod.xp_dest_id = b.source_id

                queue_insert(store, mod)
            end
        end
    end

    S:queue(this.sound_events.hit)

    local fx, air_hit

    if b.hit_fx_air and target and target.vis and band(target.vis.flags, F_FLYING) ~= 0 then
        fx = E:create_entity(b.hit_fx_air)
        air_hit = true
    elseif b.hit_fx then
        fx = E:create_entity(b.hit_fx)
    end

    if fx then
        fx.pos.x, fx.pos.y = b.to.x, b.to.y
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end

    if b.hit_decal and not air_hit then
        fx = E:create_entity(b.hit_decal)
        fx.pos.x, fx.pos.y = b.to.x, b.to.y
        fx.render.sprites[1].ts = 0

        queue_insert(store, fx)
    end

    queue_remove(store, this)
end

function scripts.hero_pirate.insert(this, store, script)
    this.hero.fn_level_up(this, store)

    this.melee.order = U.attack_order(this.melee.attacks)
    this.ranged.order = U.attack_order(this.ranged.attacks)

    if this.hero.skills.looting.level > 0 then
        local a = E:create_entity("pirate_loot_aura")

        a.aura.source_id = this.id

        queue_insert(store, a)
    end

    return true
end

function scripts.hero_pirate.update(this, store, script)
    local h = this.health
    local he = this.hero
    local a, skill, brk, sta

    U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_hero_new_rally(store, this) then
                    goto label_317_0
                end
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
            end

            a = this.timed_attacks.list[1]
            skill = he.skills.kraken

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                    a.vis_bans)

                targets = targets and table.filter(targets, function(_, e)
                    local neighbors = U.find_enemies_in_range(store.enemies, e.pos, 0, a.nearby_range, a.vis_flags,
                        a.vis_bans, function(oe)
                            return e.id ~= oe.id
                        end)

                    return neighbors and #neighbors >= a.min_enemies_nearby
                end)

                if targets and targets[1] then
                    local target = targets[1]
                    local start_ts = store.tick_ts
                    local flip = target.pos.x < this.pos.x

                    U.animation_start(this, a.animation, flip, store.tick_ts)
                    S:queue(a.sound)

                    while store.tick_ts - start_ts < a.shoot_time do
                        if this.nav_rally.new then
                            goto label_317_0
                        end

                        if this.health.dead then
                            goto label_317_0
                        end

                        if this.unit.is_stunned then
                            goto label_317_0
                        end

                        coroutine.yield()
                    end

                    a.ts = store.tick_ts

                    SU.hero_gain_xp_from_skill(this, skill)

                    local k_aura = E:create_entity(a.bullet)

                    k_aura.aura.source_id = this.id
                    k_aura.aura.ts = store.tick_ts

                    local ni = target.nav_path.ni + P:predict_enemy_node_advance(target, fts(8))

                    k_aura.pos = P:node_pos(target.nav_path.pi, 1, ni)

                    queue_insert(store, k_aura)

                    local ks_aura = E:create_entity("kraken_aura_slow")

                    ks_aura.aura.source_id = this.id
                    ks_aura.aura.ts = store.tick_ts
                    ks_aura.pos = k_aura.pos

                    queue_insert(store, ks_aura)

                    while not U.animation_finished(this) do
                        if this.nav_rally.new then
                            goto label_317_0
                        end

                        if this.health.dead then
                            goto label_317_0
                        end

                        if this.unit.is_stunned then
                            goto label_317_0
                        end

                        coroutine.yield()
                    end

                    a.ts = store.tick_ts
                end
            end

            a = this.timed_attacks.list[2]
            skill = he.skills.scattershot

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                    a.vis_bans)

                if targets then
                    a.ts = store.tick_ts

                    local target = targets[1]
                    local pi = target.nav_path.pi
                    local spi = target.nav_path.spi
                    local ni = target.nav_path.ni +
                                   P:predict_enemy_node_advance(target, a.shoot_time + fts(20) + fts(18))
                    local npos = P:node_pos(pi, spi, ni)

                    npos.y = npos.y + 80

                    local an, af, ai = U.animation_name_facing_point(this, a.animation, npos)

                    U.animation_start(this, an, af, store.tick_ts, false)

                    while store.tick_ts - a.ts < a.shoot_time do
                        if this.health.dead then
                            goto label_317_0
                        end

                        coroutine.yield()
                    end

                    SU.hero_gain_xp_from_skill(this, skill)

                    local bullet = E:create_entity(a.bullet)

                    bullet.pos = V.vclone(this.pos)

                    if a.bullet_start_offset then
                        local offset = a.bullet_start_offset[ai]

                        bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
                    end

                    bullet.bullet.from = V.vclone(bullet.pos)
                    bullet.bullet.to = npos

                    queue_insert(store, bullet)

                    while not U.animation_finished(this) do
                        if this.nav_rally.new then
                            goto label_317_0
                        end

                        if this.health.dead then
                            goto label_317_0
                        end

                        if this.unit.is_stunned then
                            goto label_317_0
                        end

                        coroutine.yield()
                    end
                end
            end

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                -- block empty
            else
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk or sta ~= A_NO_TARGET then
                    -- block empty
                elseif SU.soldier_go_back_step(store, this) then
                    -- block empty
                else
                    SU.soldier_idle(store, this)
                    SU.soldier_regen(store, this)
                end
            end
        end

        ::label_317_0::

        coroutine.yield()
    end
end

scripts.kraken_aura = {}

function scripts.kraken_aura.insert(this, store, script)
    scripts.aura_apply_mod.insert(this, store, script)

    local e = E:create_entity("decal_kraken")

    e.pos.x, e.pos.y = this.pos.x, this.pos.y

    queue_insert(store, e)

    return true
end

scripts.decal_kraken = {}

function scripts.decal_kraken.update(this, store, script)
    local start_ts = store.tick_ts

    U.y_animation_play(this, "start", nil, store.tick_ts)
    U.animation_start(this, "loop", nil, store.tick_ts, true)

    while store.tick_ts - start_ts < this.duration do
        coroutine.yield()
    end

    U.y_animation_play(this, "end", nil, store.tick_ts, 1)
    queue_remove(store, this)
end

scripts.pirate_exploding_barrel = {}

function scripts.pirate_exploding_barrel.update(this, store, script)
    local b = this.bullet

    this.render.sprites[1].r = 20 * math.pi / 180 * (b.to.x > b.from.x and 1 or -1)

    while store.tick_ts - b.ts < b.flight_time do
        b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
        this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

        if b.align_with_trajectory then
            this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
        elseif b.rotation_speed then
            this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
        end

        coroutine.yield()
    end

    if b.hit_fx then
        S:queue(this.sound_events.hit)

        local sfx = E:create_entity(b.hit_fx)

        sfx.pos = V.vclone(b.to)
        sfx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, sfx)
    end

    local center = V.v(this.pos.x, this.pos.y - 80)

    center.x, center.y = center.x + math.random(-4, 4), center.y + math.random(-4, 4)

    local angle = 0
    local min_angle = 2 * math.pi / this.fragments

    for i = 1, this.fragments do
        angle = angle + min_angle + U.frandom(0, math.pi / 6)

        local bf = E:create_entity("barrel_fragment")

        bf.bullet.from = V.vclone(this.pos)
        bf.bullet.to = U.point_on_ellipse(center, (50 * math.random() + 45) / 2, angle)
        bf.bullet.flight_time = U.frandom(fts(16), fts(20))
        bf.render.sprites[1].r = 100 * math.random() * (math.pi / 180)

        if i > 1 then
            bf.sound_events.hit = nil
        end

        queue_insert(store, bf)
    end

    queue_remove(store, this)
end

scripts.mod_pirate_loot = {}

function scripts.mod_pirate_loot.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or not target.health or target.health.dead then
        return false
    end

    this.extra_loot = math.ceil(target.enemy.gold * this.percent)
    target.enemy.gold = target.enemy.gold + this.extra_loot

    return true
end

function scripts.mod_pirate_loot.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
        coroutine.yield()
    end

    if target then
        if target.health.dead and target.enemy.gold > 0 then
            local fx = E:create_entity("fx_coin_jump")

            fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
            fx.render.sprites[1].ts = store.tick_ts

            if target.health_bar then
                fx.render.sprites[1].offset.y = target.health_bar.offset.y
            end

            queue_insert(store, fx)
        else
            target.enemy.gold = km.clamp(0, target.enemy.gold, target.enemy.gold - this.extra_loot)
        end
    end

    queue_remove(store, this)
end

scripts.mod_stun_kraken = {}

function scripts.mod_stun_kraken.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead then
        return false
    end

    local ka = store.entities[this.modifier.source_id]

    if ka and ka.max_active_targets and ka.active_targets_count >= ka.max_active_targets then
        return false
    end

    if target and target.unit and this.render then
        local s = this.render.sprites[1]

        if s.size_names then
            s.prefix = s.prefix .. "_" .. s.size_names[target.unit.size]
            s.flip_x = target.render.sprites[1].flip_x
        end

        if this.modifier.use_mod_offset and target.unit.mod_offset then
            s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
        end

        s.flip_x = false
    end

    this.modifier.duration = ka.aura.duration - (store.tick_ts - ka.aura.ts)
    ka.active_targets_count = ka.active_targets_count + 1
    this.modifier.ts = store.tick_ts

    log.paranoid("aura: %s, mod duration ttl: %f", ka.id, this.modifier.duration)

    local target = store.entities[this.modifier.target_id]

    if target and not target.health.dead then
        SU.stun_inc(target)
    end

    return true
end

function scripts.mod_stun_kraken.remove(this, store)
    local ka = store.entities[this.modifier.source_id]

    if ka and ka.max_active_targets and ka.active_targets_count > 0 then
        ka.active_targets_count = ka.active_targets_count - 1
    end

    local target = store.entities[this.modifier.target_id]

    if target then
        SU.stun_dec(target)
    end

    return true
end

function scripts.mod_stun_kraken.update(this, store)
    local m = this.modifier
    local target = store.entities[this.modifier.target_id]

    if target and not target.health.dead then
        this.pos = target.pos

        local s = this.render.sprites[1]

        s.anchor.y = s.size_anchors_y[target.unit.size]

        local dpsmod = E:create_entity("mod_dps_kraken")

        dpsmod.modifier.target_id = m.target_id

        queue_insert(store, dpsmod)
        U.animation_start(this, "grab", nil, store.tick_ts)

        while store.tick_ts - m.ts < m.duration - fts(10) and target and not target.health.dead do
            coroutine.yield()
        end

        U.y_animation_play(this, "end", nil, store.tick_ts, 1)
        queue_remove(store, dpsmod)
    end

    queue_remove(store, this)
end

function scripts.hero_elora.freeze_filter_fn(e, origin)
	return e.template_name ~= "enemy_demon_cerberus"
end

function scripts.hero_elora.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill, brk, sta
	local fe = this.render.sprites[2]
	local ps = E:create_entity(this.run_particles_name)

	ps.particle_system.track_id = this.id
	ps.particle_system.emit = false

	queue_insert(store, ps)
	U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)

	this.health_bar.hidden = false
	fe.hidden = true

	while true do
		ps.particle_system.emit = false

		if h.dead then
			fe.hidden = true

			SU.y_hero_death_and_respawn(store, this)
		end

		fe.hidden = false

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				ps.particle_system.emit = true

				if SU.y_hero_new_rally(store, this) then
					goto label_61_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)
			end

			a = this.timed_attacks.list[1]
			skill = this.hero.skills.ice_storm

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local target = U.find_random_enemy(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

				if not target then
					SU.delay_attack(store, a, 0.13333333333333333)
				else
					local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
					local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
						pi
					}, nil, nil, NF_RALLY)

					if #nodes < 1 then
						SU.delay_attack(store, a, 0.4)
					else
						local s_pi, s_spi, s_ni = unpack(nodes[1])
						local flip = target.pos.x < this.pos.x
						local start_ts = store.tick_ts

						U.animation_start(this, "iceStorm", flip, store.tick_ts)
						S:queue(a.sound)

						if SU.y_hero_wait(store, this, a.cast_time) then
							goto label_61_0
						end

						a.ts = start_ts

						SU.hero_gain_xp_from_skill(this, skill)

						local delay = 0
						local n_step = ni < s_ni and -2 or 2

						ni = km.clamp(1, #P:path(s_pi), ni < s_ni and ni + a.nodes_offset or ni)

						for i = 1, skill.count[skill.level] do
							local b = E:create_entity(a.bullet)

							b.pos = P:node_pos(pi, spi, ni)
							b.spike_idx = math.random(1, 2)
							b.render.sprites[1].prefix = b.render.sprites[1].prefix .. b.spike_idx
							b.render.sprites[1].flip_x = not flip
							b.render.sprites[2].name = b.render.sprites[2].name .. b.spike_idx
							b.delay = delay
							b.bullet.source_id = this.id

							queue_insert(store, b)

							delay = delay + U.frandom(0.05, 0.1)
							ni = ni + n_step
							spi = km.zmod(spi + 1, 3)
						end

						SU.y_hero_animation_wait(this)

						goto label_61_0
					end
				end
			end

			a = this.timed_attacks.list[2]
			skill = this.hero.skills.chill

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local target = U.find_random_enemy(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

				if not target then
					SU.delay_attack(store, a, 0.13333333333333333)
				else
					local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
					local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
						pi
					}, nil, nil, NF_RALLY)

					if #nodes < 1 then
						SU.delay_attack(store, a, 0.4)
					else
						local s_pi, s_spi, s_ni = unpack(nodes[1])
						local flip = target.pos.x < this.pos.x
						local start_ts = store.tick_ts

						U.animation_start(this, "chill", flip, store.tick_ts)
						S:queue(a.sound)

						if SU.y_hero_wait(store, this, a.cast_time) then
							goto label_61_0
						end

						a.ts = start_ts

						SU.hero_gain_xp_from_skill(this, skill)

						local delay = 0
						local n_step = ni < s_ni and -a.step or a.step

						ni = km.clamp(1, #P:path(s_pi), ni < s_ni and ni + a.nodes_offset or ni)

						for i = 1, skill.count[skill.level] do
							local b = E:create_entity(a.bullet)

							b.pos = P:node_pos(pi, spi, ni)
							b.render.sprites[1].prefix = b.render.sprites[1].prefix .. math.random(1, 3)
							b.render.sprites[1].flip_x = not flip
							b.delay = delay

							queue_insert(store, b)

							delay = delay + 0.05
							ni = ni + n_step
							spi = km.zmod(spi + 1, 3)
						end

						SU.y_hero_animation_wait(this)

						goto label_61_0
					end
				end
			end

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				brk, sta = SU.y_soldier_ranged_attacks(store, this)

				if brk then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_61_0::

		coroutine.yield()
	end
end

scripts.elora_ice_spike = {}

function scripts.elora_ice_spike.update(this, store)
	local b = this.bullet

	U.sprites_hide(this)

	if this.sprite_idx == 1 then
		this.render.sprites[1].anchor.y = this.spike_1_anchor_y
		this.render.sprites[2].anchor.y = this.spike_1_anchor_y
	end

	if this.delay then
		U.y_wait(store, this.delay)
	end

	this.render.sprites[1].hidden = false

	local start_ts = store.tick_ts

	this.pos.x = this.pos.x + math.random(-4, 4)
	this.pos.y = this.pos.y + math.random(-5, 5)

	S:queue(this.sound_events.delayed_insert)
	U.animation_start(this, "start", nil, store.tick_ts, false, 1)
	U.y_wait(store, b.hit_time)

	this.render.sprites[2].hidden = false

	local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.source_id = this.id
			d.target_id = target.id
			d.value = math.random(b.damage_min, b.damage_max)

			queue_damage(store, d)
		end
	end

	U.y_wait(store, 1)
	S:queue(this.sound_events.ice_break)
	U.y_wait(store, b.duration - (store.tick_ts - start_ts))
	queue_remove(store, this)
end

function scripts.hero_hacksaw.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill, brk, sta

	U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)

	this.health_bar.hidden = false

	while true do
		if h.dead then
			S:queue(this.sound_events.death2)
			SU.y_hero_death_and_respawn(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_64_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)
			end

			brk, sta = SU.y_soldier_ranged_attacks(store, this)

			if brk then
				-- block empty
			else
				brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or sta ~= A_NO_TARGET then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_64_0::

		coroutine.yield()
	end
end

function scripts.hero_ignus.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill, brk, sta, target, attack_done

	U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)

	this.health_bar.hidden = false

	local aura = E:create_entity(this.particles_aura)

	aura.aura.source_id = this.id

	queue_insert(store, aura)

	local ps = E:create_entity(this.run_particles_name)

	ps.particle_system.track_id = this.id
	ps.particle_system.emit = false

	queue_insert(store, ps)

	while true do
		ps.particle_system.emit = false

		if h.dead then
			SU.y_hero_death_and_respawn(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				ps.particle_system.emit = true

				if SU.y_hero_new_rally(store, this) then
					goto label_71_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)
			end

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or h.dead then
				-- block empty
			else
				a = this.timed_attacks.list[2]
				skill = this.hero.skills.surge_of_flame

				if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then
					local target = U.find_first_target(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans, function(e)
						if not e.nav_path or not e.nav_path.pi then
							return false
						end

						local ps, pe = P:get_visible_start_node(e.nav_path.pi), P:get_visible_end_node(e.nav_path.pi)

						return (#e.enemy.blockers or 0) == 0 and e.nav_path.ni > ps + a.nodes_margin and e.nav_path.ni < pe - a.nodes_margin
					end)

					if not target then
						-- block empty
					else
						U.unblock_target(store, this)
						U.block_enemy(store, this, target)
						SU.hero_gain_xp_from_skill(this, skill)

						local slot_pos, slot_flip = U.melee_slot_position(this, target, 1)
						local vis_bans = this.vis.bans

						this.vis.bans = F_ALL
						this.health.ignore_damage = true
                        U.speed_mul(this, a.speed_factor)
						U.set_destination(this, slot_pos)
						S:queue(a.sound)
						U.y_animation_play(this, a.animations[1], nil, store.tick_ts)

						local aura = E:create_entity(a.aura)

						aura.aura.source_id = this.id

						queue_insert(store, aura)

						while not this.motion.arrived do
							U.walk(this, store.tick_length, nil, true)
							coroutine.yield()
						end

						this.nav_rally.center = V.vclone(this.pos)
						this.nav_rally.pos = V.vclone(this.pos)

						S:queue(a.sound_end)
						U.y_animation_play(this, a.animations[2], nil, store.tick_ts)

						a.ts = store.tick_ts
						this.vis.bans = vis_bans
						this.health.ignore_damage = nil
                        U.speed_div(this, a.speed_factor)
						goto label_71_0
					end
				end

				a = this.timed_attacks.list[1]
				skill = this.hero.skills.flaming_frenzy

				if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then
					if U.frandom(0, 1) >= a.chance then
						goto label_71_0
					end

					local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

					if not targets then
						-- block empty
					else
						local start_ts = store.tick_ts
						local flip = targets[1].pos.x < this.pos.x

						U.animation_start(this, a.animation, flip, store.tick_ts)
						S:queue(a.sound)

						if U.y_wait(store, a.cast_time, function()
							return SU.hero_interrupted(this)
						end) then
							goto label_71_0
						end

						SU.hero_gain_xp_from_skill(this, skill)

						a.ts = start_ts
						targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

						if targets then
							for _, t in pairs(targets) do
								local fx = E:create_entity(a.hit_fx)

								fx.pos = V.vclone(t.pos)

								if t.unit and t.unit.mod_offset then
									fx.pos.x, fx.pos.y = fx.pos.x + t.unit.mod_offset.x, fx.pos.y + t.unit.mod_offset.y
								end

								for i = 1, #fx.render.sprites do
									fx.render.sprites[i].ts = store.tick_ts
								end

								queue_insert(store, fx)

								local d = E:create_entity("damage")

								d.damage_type = a.damage_type
								d.source_id = this.id
								d.target_id = t.id
								d.value = math.random(a.damage_min, a.damage_max)

								queue_damage(store, d)
							end
						end

                        scripts.heal(this, this.health.hp_max * a.heal_factor)

						local e = E:create_entity(a.decal)

						e.pos = V.vclone(this.pos)
						e.render.sprites[1].ts = store.tick_ts

						queue_insert(store, e)

						if not U.y_animation_wait(this) then
							-- block empty
						end

						goto label_71_0
					end
				end

				if sta ~= A_NO_TARGET then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_71_0::

		coroutine.yield()
	end
end



scripts.decal_oni_torment_sword = {}

function scripts.decal_oni_torment_sword.update(this, store)
	local sword_name = table.random(this.sword_names)

	this.render.sprites[1].prefix = sword_name
	this.render.sprites[1].hidden = true

	U.y_wait(store, this.delay)

	this.render.sprites[1].hidden = false

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.y_wait(store, this.duration)
	U.y_animation_play(this, "out", nil, store.tick_ts)
	queue_remove(store, this)
end

function scripts.hero_thor.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill, brk, sta

	U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_87_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelUp", nil, store.tick_ts, 1)
			end

			brk, sta = SU.y_soldier_ranged_attacks(store, this)

			if brk then
				-- block empty
			else
				brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or sta ~= A_NO_TARGET then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_87_0::

		coroutine.yield()
	end
end

function scripts.hero_10yr.get_info(this)
	local a = this.is_buffed and this.melee.attacks[3] or this.melee.attacks[1]
	local min, max = a.damage_min + this.damage_buff, a.damage_max+this.damage_buff

	min, max = min * this.unit.damage_factor, max * this.unit.damage_factor

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
        damage_type = a.damage_type,
		-- damage_icon = this.info.damage_icon,
		armor = this.health.armor,
        magic_armor = this.health.magic_armor,
		respawn = this.health.dead_lifetime
	}
end


scripts.enemy_sheep = {
    update = function (this, store)
        local clicks = 0
        local hp_max = this.health.hp_max
        if hp_max > 4000 then
            this.clicks_to_destroy = 8
        else
            this.clicks_to_destroy = hp_max / 500
        end
        while true do
            if this.health.dead then
                SU.y_enemy_death(store, this)
                return
            end

            if this.ui.clicked then
                this.ui.clicked = nil
                clicks = clicks + 1
            end

            if clicks >= this.clicks_to_destroy then
                this.health.hp = 0
                coroutine.yield()
                AC:inc_check("SHEEP_KILLER")
            elseif this.unit.is_stunned then
                U.animation_start(this, "idle", nil, store.tick_ts, -1)
                coroutine.yield()
            else
                SU.y_enemy_walk_until_blocked(store, this, true, function(store, this)
                    return this.ui.clicked
                end)
            end
        end
    end
}


scripts.enemy_shaman = {
    update= function(this, store)
        local a = this.timed_attacks.list[1]
        a.ts = store.tick_ts

        local function ready_to_heal()
            return enemy_ready_to_magic_attack(this, store, a)
        end

        ::label_95_0::

        while true do
            if this.health.dead then
                SU.y_enemy_death(store, this)
                return
            end

            if this.unit.is_stunned then
                SU.y_enemy_stun(store, this)
            else
                if ready_to_heal() then
                    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                        a.vis_bans, function(e)
                            return e.health.hp < e.health.hp_max
                        end)

                    if not targets then
                        SU.delay_attack(store, a, 0.5)
                    else
                        a.ts = store.tick_ts
                        U.animation_start(this, a.animation, nil, store.tick_ts, false)
                        S:queue(a.sound)
                        if SU.y_enemy_wait(store, this, a.cast_time) then
                            goto label_95_0
                        end
                        targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans,
                            function(e)
                                return e.health.hp < e.health.hp_max
                            end)
                        if targets then
                            local healed_count = 0
                            for _, target in ipairs(targets) do
                                if healed_count >= a.max_count then
                                    break
                                end
                                local m = E:create_entity(a.mod)
                                m.modifier.source_id = this.id
                                m.modifier.target_id = target.id
                                queue_insert(store, m)
                                healed_count = healed_count + 1
                            end
                        end
                        U.y_animation_wait(this)
                    end
                end

                if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_heal, ready_to_heal) then
                    -- block empty
                else
                    coroutine.yield()
                end
            end
        end
    end
}

scripts.enemy_spider_big = {
    update = function(this, store, script)
        local ma = this.melee.attacks[1]
        local ta = this.timed_attacks.list[1]

        ta.ts = store.tick_ts
        ta.cooldown = U.frandom(ta.min_cooldown, ta.max_cooldown)

        local eggs_count = 0

        local function ready_to_lay()
            return enemy_ready_to_magic_attack(this, store, ta) and eggs_count < ta.max_count and not U.get_blocker(store, this)
        end

        while true do
            if this.health.dead then
                SU.y_enemy_death(store, this)

                return
            end

            if this.unit.is_stunned then
                U.animation_start(this, "idle", nil, store.tick_ts, -1)
                coroutine.yield()
            else
                if ready_to_lay() then
                    ta.ts = store.tick_ts
                    eggs_count = eggs_count + 1
                    local pi, spi, ni = this.nav_path.pi, this.nav_path.spi, this.nav_path.ni
                    local e = E:create_entity(ta.bullet)

                    e.pos.x, e.pos.y = this.pos.x, this.pos.y
                    e.spawner.pi = pi
                    e.spawner.spi = spi
                    e.spawner.ni = ni
                    if this.health_judger then
                        e.health_factor = this.health.hp / this.health.hp_max
                        e.health_factor = e.health_factor * e.health_factor
                    end
                    queue_insert(store, e)
                end

                if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_lay, nil, nil) then
                    -- block empty
                else
                    coroutine.yield()
                end
            end
        end
    end
}

scripts.enemy_rocketeer = {
    on_damage = function(this, store, damage)
        if not this.health.dead and not U.has_modifier_types(store, this, MOD_TYPE_FREEZE) and not this.already_speed_up then
            local speed_buff = E:create_entity("mod_rocketeer_speed_buff")

            speed_buff.modifier.source_id = this.id
            speed_buff.modifier.target_id = this.id

            queue_insert(store, speed_buff)
        end
        return true
    end
}

scripts.enemy_troll_chieftain = {
    update = function(this, store)
        local a = this.timed_attacks.list[1]
        a.ts = store.tick_ts

        local function ready_to_rage()
            if U.get_blocker(store, this) then
                a.ts = store.tick_ts
                return false
            else
                return enemy_ready_to_magic_attack(this, store, a)
            end
        end

        local function get_rage_targets()
            return U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans, function(e)
                return table.contains(a.allowed_templates, e.template_name) and
                        not U.has_modifier_in_list(store, e, a.exclude_with_mods) and
                        not U.has_modifier_types(store, e, MOD_TYPE_SLOW)
            end)
        end

        local function rage_targets()
            local targets = get_rage_targets()
            if targets then
                local raged_count = 0
                for _, target in ipairs(targets) do
                    if raged_count >= a.max_count then
                        break
                    end
                    raged_count = raged_count + 1
                    for _, name in pairs(a.mods) do
                        local m = E:create_entity(name)
                        m.modifier.source_id = this.id
                        m.modifier.target_id = target.id
                        queue_insert(store, m)
                    end
                end
            end
        end

        ::label_102_0::

        while true do
            if this.health.dead then
                SU.y_enemy_death(store, this)
                return
            end

            if this.unit.is_stunned then
                SU.y_enemy_stun(store, this)
            else
                if ready_to_rage() then
                    local targets = get_rage_targets()

                    if not targets then
                        SU.delay_attack(store, a, 0.5)
                    else
                        a.ts = store.tick_ts

                        for i = 1, a.loops do
                            U.animation_start(this, a.animation, nil, store.tick_ts, false)
                            if SU.y_enemy_wait(store, this, a.cast_time) then
                                goto label_102_0
                            end
                            S:queue(a.cast_sound)
                            rage_targets()
                            U.y_animation_wait(this)
                        end
                    end
                end

                if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_rage, nil) then
                    -- block empty
                else
                    coroutine.yield()
                end
            end
        end
    end
}

scripts.enemy_demon_mage = {}

function scripts.enemy_demon_mage.update(this, store)
	local a = this.timed_attacks.list[1]

	a.ts = store.tick_ts

	local function ready_to_shield()
		return enemy_ready_to_magic_attack(this, store, a)
	end

	local function get_shield_targets()
		return U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans, function(e)
			return (table.contains(a.allowed_templates, e.template_name))
		end)
	end

	::label_107_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_shield() then
				local targets = get_shield_targets()

				if not targets then
					SU.delay_attack(store, a, 0.5)
				else
					a.ts = store.tick_ts

					U.animation_start(this, a.animation, nil, store.tick_ts, false)
					S:queue(a.sound)

					if SU.y_enemy_wait(store, this, a.cast_time) then
						goto label_107_0
					end

					targets = get_shield_targets()

					if targets then
						local shielded_count = 0

						for _, target in ipairs(targets) do
							if shielded_count >= a.max_count then
								break
							end

							shielded_count = shielded_count + 1

							local m = E:create_entity(a.mod)

							m.modifier.source_id = this.id
							m.modifier.target_id = target.id

							queue_insert(store, m)
						end
					end

					if SU.y_enemy_animation_wait(this) then
						goto label_107_0
					end
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_shield, ready_to_shield) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_demon_legion = {}

function scripts.enemy_demon_legion.update(this, store)
	local a = this.timed_attacks.list[1]

	local function ready_to_clone()
		return a.count > 0 and enemy_ready_to_magic_attack(this, store, a) and P:nodes_to_defend_point(this.nav_path) > a.nodes_limit
	end

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end

		if this._raise_vis_bans then
			this.vis.bans = this._raise_vis_bans
			this.health.ignore_damage = this._raise_ignore_damage
		end

		U.animation_start(this, "idle", af, store.tick_ts, true)
	end

	a.count = a.generation
	a.ts = store.tick_ts

	::label_111_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)
			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_clone() then
				U.animation_start(this, a.animation, nil, store.tick_ts)

				if SU.y_enemy_wait(store, this, a.spawn_time) then
					goto label_111_0
				end

				local e = E:create_entity(a.entity)

				e._summoned = true
				e.health.hp = this.health.hp
				e.enemy.gold = 0
				e.render.sprites[1].name = "raise"
				e.timed_attacks.list[1].generation = a.generation - 1
				e.nav_path.pi = this.nav_path.pi
				e.nav_path.spi = math.random(1, 3)
				e.nav_path.ni = this.nav_path.ni + math.random(a.spawn_offset_nodes[1], a.spawn_offset_nodes[2])

				if not P:is_node_valid(e.nav_path.pi, e.nav_path.ni) then
					e.nav_path.ni = this.nav_path.ni
				end

				queue_insert(store, e)
				SU.y_enemy_animation_wait(this)

				a.ts = store.tick_ts
				a.count = a.count - 1
				a.cooldown = a.cooldown_after
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_clone, ready_to_clone) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_demon_gulaemon = {}

function scripts.enemy_demon_gulaemon.update(this, store)
	local cont, blocker, is_flying
	local a = this.timed_actions.list[1]
	local sp = this.render.sprites[1]

	this.is_flying = false
	a.ts = store.tick_ts

	local function ready_for_takeoff()
		return not is_flying and enemy_ready_to_magic_attack(this, store, a) and P:nodes_to_defend_point(this.nav_path) > a.nodes_limit_start
	end

	local function ready_to_land()
		return this._should_land
	end

	local function patch_offsets(factor)
		this.health_bar.offset.y = this.health_bar.offset.y + factor * a.off_health_bar_y
		this.ui.click_rect.pos.y = this.ui.click_rect.pos.y + factor * a.off_click_rect_y
		this.unit.mod_offset.y = this.unit.mod_offset.y + factor * a.off_mod_offset_y
		this.unit.hit_offset.y = this.unit.hit_offset.y + factor * a.off_hit_offset_y
	end

	::label_113_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_land() and not this.health.dead then
				this._should_land = nil
				this.health_bar.hidden = true

				local an, af = U.animation_name_facing_point(this, "land", this.motion.dest)

				U.animation_start(this, an, af, store.tick_ts)

				while not U.animation_finished(this) and not this.health.dead do
					coroutine.yield()
				end

				this.health_bar.hidden = this.health.dead
				is_flying = false

				patch_offsets(-1)

				sp.prefix = sp.prefix_ground
				sp.name = "idle"
				this.vis.bans = U.flag_clear(this.vis.bans, a.bans_air)
				this.vis.flags = U.flag_clear(this.vis.flags, a.flags_air)
				this.unit.disintegrate_fx = "fx_enemy_desintegrate"
				a.ts = store.tick_ts

				goto label_113_0
			end

			cont, blocker = SU.y_enemy_walk_until_blocked(store, this, is_flying, ready_to_land)

			if not cont then
				-- block empty
			else
				if blocker and not is_flying then
					if ready_for_takeoff() then
						is_flying = true

						U.cleanup_blockers(store, this)
						SU.remove_modifiers_by_type(store, this, MOD_TYPE_SLOW)
						patch_offsets(1)

						sp.prefix = sp.prefix_air
						this.vis.bans = U.flag_set(this.vis.bans, a.bans_air)
						this.vis.flags = U.flag_set(this.vis.flags, a.flags_air)
						this.unit.disintegrate_fx = "fx_enemy_desintegrate_air"
						this.health_bar.hidden = true

						local an, af = U.animation_name_facing_point(this, "takeoff", this.motion.dest)

						U.y_animation_play(this, an, af, store.tick_ts)

						this.health_bar.hidden = nil

						local m = E:create_entity(a.mod)

						m.modifier.source_id = this.id
						m.modifier.target_id = this.id

						queue_insert(store, m)

						goto label_113_0
					else
						if not SU.y_wait_for_blocker(store, this, blocker) then
							goto label_113_0
						end

						while SU.can_melee_blocker(store, this, blocker) do
							if not SU.y_enemy_melee_attacks(store, this, blocker) then
								goto label_113_0
							end

							coroutine.yield()
						end
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_zombiemancer = {
    update = function(this, store)
        local a = this.timed_actions.list[1]
        local a2 = this.timed_actions.list[2]
        local cg = store.count_groups[a.count_group_type]

        a.ts = store.tick_ts

        local function summon_count_exceeded()
            return cg[a.count_group_name] and cg[a.count_group_name] >= a.count_group_max
        end

        local function ready_to_summon()
            if U.get_blocker(store, this) then
                a.ts = store.tick_ts

                return false
            end
            return enemy_ready_to_magic_attack(this, store, a) and not summon_count_exceeded()
        end

        local function ready_to_raise()
            if U.get_blocker(store, this) then
                a2.ts = store.tick_ts

                return false
            end
            return enemy_ready_to_magic_attack(this, store, a2) and cg[a.count_group_name] and cg[a.count_group_name] > 0
        end

        local function get_zombies()
            return table.filter(store.enemies, function(k,v)
                return v.owner and v.owner == this.id and v.health and not v.health.dead
            end)
        end

        local function break_fn()
            return ready_to_summon() or ready_to_raise()
        end

        ::label_117_0::

        while true do
            if this.health.dead then
                SU.y_enemy_death(store, this)

                return
            end

            if this.unit.is_stunned then
                SU.y_enemy_stun(store, this)
            else
                if ready_to_summon() then
                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    if SU.y_enemy_wait(store, this, a.spawn_time) then
                        goto label_117_0
                    end

                    for i = 1, a.max_count do
                        if SU.y_enemy_wait(store, this, a.spawn_delay) then
                            goto label_117_0
                        end

                        if i ~= 1 and summon_count_exceeded() then
                            break
                        end

                        local e = E:create_entity(a.entity)
                        local noff = a.summon_offsets[i] or a.summon_offsets[1]

                        e.nav_path.pi = this.nav_path.pi
                        e.nav_path.spi = noff[1]
                        e.nav_path.ni = this.nav_path.ni + math.random(noff[2], noff[3])
                        e.render.sprites[1].name = a.spawn_animation
                        e.enemy.gold = 0
                        e.owner = this.id
                        e.motion.max_speed = (0.5 + math.random() * 0.1 ) * FPS
                        E:add_comps(e, "count_group")
                        e.count_group.name = a.count_group_name
                        e.count_group.type = a.count_group_type
                        if P:is_node_valid(e.nav_path.pi, e.nav_path.ni) then
                            queue_insert(store, e)
                        end

                        coroutine.yield()
                    end

                    U.y_animation_wait(this)

                    a.ts = store.tick_ts
                end

                if ready_to_raise() then
                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    local zombies = get_zombies()
                    local raise_index = math.random(1, #zombies)
                    local anchor = zombies[raise_index]

                    local fx = E:create_entity("decal_zombiemancer_raise")
                    fx.pos = V.vclone(anchor.pos)
                    for i = 1, #fx.render.sprites do
                        fx.render.sprites[i].ts = store.tick_ts
                    end
                    queue_insert(store, fx)

                    local hp_sum = 0
                    for _, zombie in pairs(zombies) do
                        if zombie.health and not zombie.health.dead then
                            local mod = E:create_entity("mod_blood")
                            mod.modifier.duration = 1
                            mod.dps.damage_inc = 0
                            local deal = this.health.hp / 4
                            mod.dps.damage_max = deal
                            mod.dps.damage_min = deal
                            hp_sum = hp_sum + deal

                            mod.modifier.source_id = this.id
                            mod.modifier.target_id = zombie.id
                            queue_insert(store, mod)
                        end
                    end

                    local abomination = E:create_entity("enemy_abomination")
                    abomination.nav_path.pi = anchor.nav_path.pi
                    abomination.nav_path.spi = anchor.nav_path.spi
                    abomination.nav_path.ni = anchor.nav_path.ni
                    abomination.enemy.gold = 0
                    abomination.render.sprites[1].alpha = 100
                    abomination.health.hp_max = 3 * hp_sum
                    abomination.health.hp = abomination.health.hp_max
                    if P:is_node_valid(abomination.nav_path.pi, abomination.nav_path.ni) then
                        queue_insert(store, abomination)
                    end

                    SU.stun_inc(abomination)
                    if SU.y_enemy_wait(store, this, a.spawn_time) then
                        goto label_117_0
                    end

                    U.y_animation_wait(this)
                    abomination.render.sprites[1].alpha = 255
                    SU.stun_dec(abomination)

                    a2.ts = store.tick_ts
                end

                if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn) then
                    -- block empty
                else
                    coroutine.yield()
                end
            end
        end
    end
}

scripts.enemy_necromancer = {}

function scripts.enemy_necromancer.update(this, store)
	local a = this.timed_actions.list[1]
	local cg = store.count_groups[a.count_group_type]

	a.ts = store.tick_ts

	local function summon_count_exceeded()
		return cg[a.count_group_name] and cg[a.count_group_name] >= a.count_group_max
	end

	local function ready_to_summon()
		if U.get_blocker(store, this) then
			a.ts = store.tick_ts

			return false
		else
			return enemy_ready_to_magic_attack(this, store, a) and not summon_count_exceeded()
		end
	end

	::label_117_0::

	while true do
		if this.health.dead then
            -- 找到所有由此necromancer召唤的骷髅，将它们的减伤效果取消（即damage_factor置为1）
            for _, entity in pairs(store.enemies) do
                if entity.health.damage_factor_source and entity.health.damage_factor_source == this.id then
                    entity.health.damage_factor = entity.health.damage_factor + 0.3
                end
            end
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_summon() then
				U.animation_start(this, a.animation, nil, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, a.spawn_time) then
					goto label_117_0
				end

				for i = 1, a.max_count do
					if SU.y_enemy_wait(store, this, a.spawn_delay) then
						goto label_117_0
					end

					if i ~= 1 and summon_count_exceeded() then
						break
					end

					local e_name = a.entity_names[U.random_table_idx(a.entity_chances)]
					local e = E:create_entity(e_name)
					local noff = a.summon_offsets[i] or a.summon_offsets[1]

					e.nav_path.pi = this.nav_path.pi
					e.nav_path.spi = noff[1]
					e.nav_path.ni = this.nav_path.ni + math.random(noff[2], noff[3])
					e.render.sprites[1].name = a.spawn_animation
					e.enemy.gold = 0
                    e.health.damage_factor = e.health.damage_factor - 0.3
                    e.health.damage_factor_source = this.id
                    e.motion.max_speed = (0.5 + math.random() * 0.2 ) * FPS
					E:add_comps(e, "count_group")

					e.count_group.name = a.count_group_name
					e.count_group.type = a.count_group_type

					if P:is_node_valid(e.nav_path.pi, e.nav_path.ni) then
						queue_insert(store, e)
					end

					coroutine.yield()
				end

				U.y_animation_wait(this)

				a.ts = store.tick_ts
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_summon, ready_to_summon) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_demon_cerberus = {
    update = function(this, store)
        if this.sleeping then
            local original_bans = this.vis.bans
            this.health_bar.hidden = true
            this.health.immune_to = DAMAGE_ALL
            this.ui.can_select = false
            this.vis.bans = F_ALL
            U.animation_start(this, "sleeping", nil, store.tick_ts, true)
            while this.sleeping do
                coroutine.yield()
            end
            this.health_bar.hidden = false
            this.health.immune_to = 0
            this.ui.can_select = true
            this.vis.bans = original_bans
            this.render.sprites[1].name = "raise"
        end
        return scripts.enemy_mixed.update(this, store)
    end
}

scripts.enemy_troll_skater = {}

function scripts.enemy_troll_skater.update(this, store)
	local walking_angles = this.render.sprites[1].angles.walk

	this._last_on_ice = false

	local function on_ice()
		return this.enemy.can_do_magic and band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_ICE) ~= 0
	end

	local function ice_changed()
		return this._last_on_ice ~= on_ice()
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)
			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ice_changed() then
				if on_ice() then
					this._last_on_ice = true
					this.vis.bans = U.flag_set(this.vis.bans, this.skate.vis_bans_extra)
					this.render.sprites[1].angles.walk = this.skate.walk_angles

					local m = E:create_entity(this.skate.mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = this.id

					queue_insert(store, m)

					this.skate._mod = m
				else
					this._last_on_ice = false
					this.vis.bans = U.flag_clear(this.vis.bans, this.skate.vis_bans_extra)
					this.render.sprites[1].angles.walk = walking_angles

					if this.skate._mod then
						queue_remove(store, this.skate._mod)
						this.skate._mod = nil
					end
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, skating, ice_changed) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_witch = {
    get_info = function(this)
        local out = scripts.enemy_basic.get_info(this)
        local mod = E:get_template("mod_witch_frog")
        out.damage_min = mod.modifier.damage_min
        out.damage_max = mod.modifier.damage_max
        return out
    end
}

scripts.enemy_spectral_knight = {}

function scripts.enemy_spectral_knight.insert(this, store)
	if not scripts.enemy_basic.insert(this, store) then
		return false
	end

	if this.render.sprites[1].name == "raise" then
		this._raise_vis_bans = this.vis.bans
		this._raise_ignore_damage = this.health.ignore_damage
		this.vis.bans = bor(F_ALL)
		this.health.ignore_damage = true
		this.health_bar.hidden = true
	end

	return true
end

function scripts.enemy_spectral_knight.update(this, store)
	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end

		if this._raise_vis_bans then
			this.vis.bans = this._raise_vis_bans
			this.health.ignore_damage = this._raise_ignore_damage
		end

		U.animation_start(this, "idle", af, store.tick_ts, true)
	end

	return scripts.enemy_mixed.update(this, store)
end

scripts.eb_juggernaut = {}

-- function scripts.eb_juggernaut.get_info(this)
-- 	local ma = this.melee.attacks[1]
-- 	local min, max = ma.damage_min, ma.damage_max

-- 	return {
-- 		type = STATS_TYPE_ENEMY,
-- 		hp = this.health.hp,
-- 		hp_max = this.health.hp_max,
-- 		damage_min = min,
-- 		damage_max = max,
-- 		armor = this.health.armor,
-- 		magic_armor = this.health.magic_armor,
-- 		lives = this.enemy.lives_cost
-- 	}
-- end

function scripts.eb_juggernaut.insert(this, store, script)
	this.melee.order = U.attack_order(this.melee.attacks)
	return true
end

function scripts.eb_juggernaut.update(this, store, script)
	local ma = this.timed_attacks.list[1]
	local ba = this.timed_attacks.list[2]

	local function ready_to_shoot()
		for _, a in pairs(this.timed_attacks.list) do
			if enemy_ready_to_magic_attack(this, store, a) then
				return true
			end
		end
		return false
	end
    local spawn_level = 0
	ma.ts = store.tick_ts
	ba.ts = store.tick_ts

	::label_129_0::

	while true do
		if this.health.dead then
			LU.kill_all_enemies(store, true)
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)
			signal.emit("boss-killed", this)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			for _, a in pairs(this.timed_attacks.list) do
				if store.tick_ts - a.ts < a.cooldown then
					-- block empty
				else
					local target

					if a == ma then
						local targets = U.find_soldiers_in_range(store.soldiers, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

						if not targets then
							SU.delay_attack(store, a, 0.5)

							goto label_129_1
						end

						target = targets[1]
					end

					U.animation_start(this, a.animation, nil, store.tick_ts, false)
					U.y_wait(store, a.shoot_time)

					local af = this.render.sprites[1].flip_x
					local o = a.bullet_start_offset
					local b = E:create_entity(a.bullet)

					b.bullet.source_id = this.id
					b.bullet.target_id = target and target.id
					b.bullet.from = V.v(this.pos.x + (af and -1 or 1) * o.x, this.pos.y + o.y)
					b.pos = V.vclone(b.bullet.from)

					if a == ma then
						b.bullet.to = V.v(b.pos.x + a.launch_vector.x, b.pos.y + a.launch_vector.y)
					else
						b.bullet.to = P:get_random_position(20, TERRAIN_LAND, NF_RANGE, 30)
                        E:get_template(b.bullet.hit_payload).level = spawn_level < 7 and spawn_level or 7
						b.bullet.hit_payload = E:create_entity(b.bullet.hit_payload)
						b.bullet.hit_payload.spawner.owner_id = this.id
                        spawn_level = spawn_level + 1
					end

					if b.bullet.to then
						queue_insert(store, b)
					else
						log.debug("could not find random position to shoot juggernaut bomb. skipping...")
					end

					U.y_animation_wait(this)

					a.ts = store.tick_ts
				end

				::label_129_1::
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_shoot)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_129_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_shoot() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_129_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.eb_jt = {}

function scripts.eb_jt.get_info(this)
	local ma = this.melee.attacks[1]
	local min, max = ma.damage_min, ma.damage_max

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_jt.on_damage(this, store, damage)
	local pd = U.predict_damage(this, damage)

	if pd >= this.health.hp then
		this.dying = true
		this.health_bar.hidden = true
		this.health.ignore_damage = true
		this.ui.can_select = false
		this.vis.bans = F_ALL

		SU.remove_modifiers(store, this)
		SU.stun_inc(this)

		return false
	end

	return true
end

function scripts.eb_jt.update(this, store)
	local fa = this.timed_attacks.list[1]

	local function ready_to_freeze()
		return enemy_ready_to_magic_attack(this, store, fa)
	end

	fa.ts = store.tick_ts

	::label_133_0::

	while true do
		if this.dying then
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)

			if IS_CONSOLE then
				U.y_wait(store, this.tap_timeout)
			else
				local tap = SU.insert_sprite(store, this.tap_decal, this.pos)

				this.ui.clicked = nil

				while not this.ui.clicked do
					coroutine.yield()
				end

				queue_remove(store, tap)
			end

			S:stop_all()
			S:queue(this.sound_events.death_explode)
			U.y_animation_play(this, "death_end", nil, store.tick_ts)

			this.health.ignore_damage = false
			this.health.hp = 0

			coroutine.yield()
			LU.kill_all_enemies(store, true)
			signal.emit("boss-killed", this)

			return
		end

		if this.unit.is_stunned and not this.dying then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_freeze() then
				local towers = U.find_towers_in_range(store.towers, this.pos, fa, function(t)
					return t.tower.can_be_mod
				end)

				if not towers then
					SU.delay_attack(store, fa, 0.5)
				else
					SU.hide_modifiers(store, this, true)
					U.animation_start(this, "freeze", nil, store.tick_ts, 1)
					S:queue(fa.sound, fa.sound_args)
					U.y_wait(store, fa.hit_time)

					local hit_pos = V.vclone(this.pos)
					local af = this.render.sprites[1].flip_x

					if fa.hit_offset then
						hit_pos.x = hit_pos.x + (af and -1 or 1) * fa.hit_offset.x
						hit_pos.y = hit_pos.y + fa.hit_offset.y
					end

					SU.insert_sprite(store, fa.hit_decal, hit_pos)

					for i, t in ipairs(towers) do
						if i >= fa.count then
							break
						end

						local m = E:create_entity(fa.mod)

						m.modifier.target_id = t.id
						m.modifier.source_id = this.id

						queue_insert(store, m)
					end

					U.y_animation_wait(this)
					SU.show_modifiers(store, this, true)

					fa.ts = store.tick_ts

					U.animation_start(this, "breath", nil, store.tick_ts, -1)
					S:queue(fa.exhausted_sound, fa.exhausted_sound_args)

					if SU.y_enemy_wait(store, this, fa.exhausted_duration) then
						goto label_133_0
					end
				end
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_freeze)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_133_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_freeze() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_133_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.jt_spawner_aura = {}

function scripts.jt_spawner_aura.update(this, store)
	local spawn_ts = {}

	for i = 1, #this.spawn_data do
		spawn_ts[i] = store.tick_ts
	end

	local owner = store.entities[this.aura.source_id]

	if not owner then
		log.error("owner %s was not found. baling out", this.aura.source_id)
	else
		while not owner.dying do
			for i, v in ipairs(this.spawn_data) do
				local template, cooldown, delay, pi, spi = unpack(v)

				if store.tick_ts - spawn_ts[i] >= cooldown + delay then
					local e = E:create_entity(template)

					e.nav_path.pi = pi
					e.nav_path.spi = spi
					e.nav_path.ni = P:get_start_node(pi)

					queue_insert(store, e)

					spawn_ts[i] = store.tick_ts - delay
				end
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.mod_jt_tower = {}

function scripts.mod_jt_tower.update(this, store)
	local clicks = 0
	local s_tap = this.render.sprites[2]
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	SU.tower_block_inc(target)

	this.pos.x, this.pos.y = target.pos.x, target.pos.y

	U.y_animation_play(this, "start", nil, store.tick_ts, 1, 1)

	s_tap.hidden = nil

	SU.ui_click_proxy_add(target, this)

	while clicks < this.required_clicks do
		if IS_CONSOLE then
			if target.ui.hover_controller_active then
				s_tap.alpha = s_tap.alpha_focused
				s_tap.name = s_tap.name_focused
			else
				s_tap.alpha = s_tap.alpha_unfocused
				s_tap.name = s_tap.name_unfocused
			end
		end

		if this.ui.clicked then
			S:queue(this.sound_events.click)
			SU.insert_sprite(store, this.ui.click_fx, target.pos)

			this.ui.clicked = nil
			clicks = clicks + 1
		end

		coroutine.yield()
	end

	SU.ui_click_proxy_remove(target, this)

	this.ui.can_click = false
	s_tap.hidden = true

	U.animation_start(this, "end", nil, store.tick_ts, false, 1)
	U.y_wait(store, this.end_delay)
	SU.tower_block_dec(target)
	U.y_animation_wait(this)

	if this.tween then
		this.tween.ts = store.tick_ts
		this.tween.props[1].disabled = nil

		U.y_wait(store, 2)
	end

	queue_remove(store, this)
end

scripts.eb_veznan = {}

function scripts.eb_veznan.get_info(this)
	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = this.melee.attacks[1].damage_min,
		damage_max = this.melee.attacks[1].damage_max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_veznan.on_damage(this, store, damage)
	if this.phase == "battle" then
		local pd = U.predict_damage(this, damage)

		if pd >= this.health.hp then
			this.phase_signal = true

			return false
		end
	elseif this.phase == "demon" then
		local pd = U.predict_damage(this, damage)

		if pd >= this.health.hp then
			this.phase_signal = true

			return false
		end
	end

	return true
end

function scripts.eb_veznan.update(this, store)
	local ba = this.timed_attacks.list[1]
	local pa = this.timed_attacks.list[2]
	local taunt_ts
	local portals = LU.list_entities(store.entities, pa.portal_name)
	local initial_hp = this.health.hp_max

	local function y_taunt(idx, set)
		U.animation_start(this, "laugh", nil, store.tick_ts, true)
		SU.y_show_taunt_set(store, this.taunts, set or this.phase, idx, nil, nil, true)
		U.y_animation_wait(this)
		U.animation_start(this, "idleDown", nil, store.tick_ts, true)
	end

	local function y_block_towers()
		local towers = table.filter(store.towers, function(_, e)
			return e.tower.can_be_mod and not U.has_modifiers(store, e, ba.mod)
		end)

		if not towers or #towers == 0 then
			SU.delay_attack(store, ba, 0.5)

			return
		end

		local start_ts = store.tick_ts

		U.animation_start(this, ba.animation, nil, store.tick_ts)
		U.y_wait(store, ba.hit_time)
		S:queue(ba.sound)

		local random_towers = table.random_order(towers)

		for i, t in ipairs(random_towers) do
			if i > ba.count then
				break
			end

			local m = E:create_entity(ba.mod)

			m.modifier.target_id = t.id
			m.modifier.source_id = this.id

			queue_insert(store, m)
		end

		U.y_animation_wait(this)
		U.y_wait(store, ba.attack_duration - (store.tick_ts - start_ts))

		ba.ts = store.tick_ts

		if this.phase == "castle" then
			U.animation_start(this, "idleDown", nil, store.tick_ts, true)
		end
	end

	local function y_portal()
		local start_ts = store.tick_ts

		U.animation_start(this, pa.animation, nil, store.tick_ts)
		U.y_wait(store, pa.hit_time)
		S:queue(pa.sound)

		pa.count = pa.count + 1

		for _, p in pairs(portals) do
			if pa.portals[p.portal_idx] ~= 1 then
				-- block empty
			else
				p.spawn_signal = true
			end
		end

		U.y_animation_wait(this)
		U.y_wait(store, pa.attack_duration - (store.tick_ts - start_ts))

		pa.ts = store.tick_ts

		if this.phase == "castle" then
			U.animation_start(this, "idleDown", nil, store.tick_ts, true)
		end
	end

	local function signal_ready()
		return this.phase_signal
	end

	local function battle_started()
		return store.wave_group_number >= 1
	end

	local function ready_to_block()
		return not ba.disabled and enemy_ready_to_magic_attack(this, store, ba)
	end

	local function ready_to_portal()
		return not pa.disabled and enemy_ready_to_magic_attack(this, store, pa) and pa.count < pa.max_count
	end

	local function can_break_battle_walk()
		return ready_to_block() or ready_to_portal() or this.phase_signal
	end

	this.phase_signal = nil
	this.phase_signal = nil

	while not this.phase_signal do
		coroutine.yield()
	end

	this.phase = "welcome"

	for i, d in ipairs(this.taunts.sets.welcome.delays) do
		if U.y_wait(store, d, battle_started) then
			break
		end

		y_taunt(i)
	end

	while not battle_started() do
		coroutine.yield()
	end

	y_taunt(5)

	this.phase = "castle"

	local last_lives = store.lives
	local last_wave
	local taunt_cooldown = math.random(this.taunts.delay_min, this.taunts.delay_max)

	ba.ts = store.tick_ts
	pa.ts = store.tick_ts
	taunt_ts = store.tick_ts
	this.phase_signal = nil

	while not this.phase_signal do
		if store.wave_group_number ~= last_wave and not this.phase_signal then
			local ba_wave_data = ba.data[store.wave_group_number]

			ba.disabled = not ba_wave_data

			if not ba.disabled then
				ba.cooldown = ba_wave_data and ba_wave_data[1] or 0
				ba.count = ba_wave_data and ba_wave_data[2] or 0
			end

			local pa_wave_data = pa.data[store.wave_group_number]

			pa.disabled = not pa_wave_data

			if not pa.disabled then
				pa.cooldown, pa.max_count, pa.portals = unpack(pa_wave_data)
				pa.count = 0
			end

			last_wave = store.wave_group_number
		end

		if taunt_cooldown <= store.tick_ts - taunt_ts and not this.phase_signal then
			y_taunt(nil, last_lives > store.lives and "damage" or nil)

			last_lives = store.lives
			taunt_ts = store.tick_ts
			taunt_cooldown = math.random(this.taunts.delay_min, this.taunts.delay_max)
		end

		if ready_to_block() and not this.phase_signal then
			y_block_towers()
		end

		if ready_to_portal() and not this.phase_signal then
			y_portal()
		end

		coroutine.yield()
	end

	this.phase = "pre_battle"

	local battle_ts = store.tick_ts

	pa.cooldown = this.battle.pa_cooldown
	pa.max_count = this.battle.pa_max_count
	pa.animation = this.battle.pa_animation
	ba.animation = this.battle.ba_animation

	U.y_wait(store, fts(24))
	y_taunt()
	U.y_wait(store, battle_ts + fts(115) - store.tick_ts)
	U.y_animation_play(this, "walkAway", nil, store.tick_ts)

	this.nav_path.pi, this.nav_path.spi, this.nav_path.ni = 1, 1, 1
	this.pos = P:node_pos(this.nav_path)
	pa.ts = store.tick_ts
	ba.ts = store.tick_ts
	this.vis.bans = U.flag_clear(this.vis.bans, F_ALL)
	this.health.ignore_damage = false
	this.health_bar.hidden = nil
	this.phase_signal = nil
	this.phase = "battle"

	while not this.phase_signal do
		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_block() and not this.phase_signal then
				y_block_towers()
			end

			if ready_to_portal() and not this.phase_signal then
				y_portal()
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, can_break_battle_walk, can_break_battle_walk) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end

	this.health_bar.hidden = true
	this.vis.bans = U.flag_set(this.vis.bans, F_ALL)

	SU.remove_modifiers(store, this)
	S:queue(this.demon.transform_sound)
	U.y_animation_play(this, "demonTransform", nil, store.tick_ts, 1)

	this.enemy.melee_slot = this.demon.melee_slot
	this.health.hp = initial_hp * 1.5
	this.health.hp_max = initial_hp * 1.5
	this.health_bar.offset = this.demon.health_bar_offset
	this.health_bar.frames[1].bar_width = this.health_bar.frames[1].bar_width * this.demon.health_bar_scale
	this.health_bar.frames[2].bar_width = this.health_bar.frames[2].bar_width * this.demon.health_bar_scale
	this.health_bar.frames[1].scale.x = this.health_bar.frames[1].scale.x * this.demon.health_bar_scale
	this.health_bar.frames[2].scale.x = this.health_bar.frames[2].scale.x * this.demon.health_bar_scale
	this.melee.attacks[1].disabled = true
	this.melee.attacks[2].disabled = false
	this.motion.max_speed = this.demon.speed
    this.motion.real_speed = U.real_max_speed(this)
	this.render.sprites[1].prefix = this.demon.sprites_prefix
	this.ui.click_rect = this.demon.ui_click_rect
	this.unit.hit_offset = this.demon.unit_hit_offset
	this.unit.mod_offset = this.demon.unit_mod_offset
	this.unit.size = this.demon.unit_size
	this.info.portrait = this.demon.info_portrait
	this.health_bar.hidden = nil
	this.vis.bans = U.flag_clear(this.vis.bans, F_ALL)
	this.phase_signal = nil
	this.phase = "demon"

	while not this.phase_signal do
		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, signal_ready, signal_ready) then
			-- block empty
		else
			coroutine.yield()
		end
	end

	this.phase = "death"
	this.health_bar.hidden = true
	this.health.ignore_damage = true
	this.ui.can_click = false
	this.vis.bans = U.flag_set(this.vis.bans, F_ALL)

	SU.remove_modifiers(store, this)
	LU.kill_all_enemies(store, true)
	S:stop_all()
	S:queue(this.sound_events.death)
	signal.emit("boss-killed", this)
	U.animation_start(this, "death", nil, store.tick_ts, 1)
	signal.emit("hide-gui")
	U.y_wait(store, fts(110))
	LU.kill_all_enemies(store, true)

	local sc = E:create_entity(this.souls_aura)

	sc.pos = V.vclone(this.pos)
	sc.pos.y = sc.pos.y + 14

	queue_insert(store, sc)
	U.y_animation_wait(this)
	U.animation_start(this, "deathLoop", nil, store.tick_ts, true)
	U.y_wait(store, fts(90))

	sc.interrupt = true

	LU.kill_all_enemies(store, true)
	U.animation_start(this, "deathEnd", nil, store.tick_ts, true)

	local circle = E:create_entity(this.white_circle)

	circle.pos.x, circle.pos.y = this.pos.x + 6, this.pos.y + 12
	circle.tween.ts = store.tick_ts
	circle.render.sprites[1].ts = store.tick_ts

	queue_insert(store, circle)
	U.y_wait(store, fts(65) + 2)

	this.phase = "death-end"

	queue_remove(store, this)
end

scripts.veznan_portal = {}

function scripts.veznan_portal.update(this, store)
	local spawns = this.spawn_groups[this.portal_idx]
	local ni = this.out_nodes[this.pi]

	while true do
		while not this.spawn_signal do
			coroutine.yield()
		end

		U.y_animation_play(this, "start", nil, store.tick_ts)

		local roll = math.random()
		local entity_data

		for _, s in pairs(spawns) do
			if roll <= s[1] then
				entity_data = s[2]

				break
			end
		end

		U.animation_start(this, "active", nil, store.tick_ts, true)

		for _, d in pairs(entity_data) do
			local min, max, template = unpack(d)
			local count = min ~= max and math.random(min, max) or min

			for i = 1, count do
				local e = E:create_entity(template)

				e.nav_path.pi = this.pi
				e.nav_path.spi = math.random(1, 3)
				e.nav_path.ni = ni
				e.pos = V.vclone(this.pos)

				queue_insert(store, e)
				U.y_wait(store, this.spawn_interval)
			end
		end

		U.y_animation_wait(this)
		U.y_animation_play(this, "end", nil, store.tick_ts)

		this.spawn_signal = nil

		coroutine.yield()
	end
end

scripts.mod_veznan_tower = {}

function scripts.mod_veznan_tower.update(this, store)
	local clicks = 0
	local s_tap = this.render.sprites[2]
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos.x, this.pos.y = target.pos.x, target.pos.y

	U.y_animation_play(this, "start", nil, store.tick_ts, 1, 1)

	s_tap.hidden = nil

	U.animation_start(this, "preHold", nil, store.tick_ts, true, 1)
	SU.tower_block_inc(target)

	local hold_ts = store.tick_ts

	SU.ui_click_proxy_add(target, this)

	while clicks < this.required_clicks and store.tick_ts - hold_ts < this.click_time do
		if IS_CONSOLE then
			if target.ui.hover_controller_active then
				s_tap.alpha = s_tap.alpha_focused
				s_tap.name = s_tap.name_focused
			else
				s_tap.alpha = s_tap.alpha_unfocused
				s_tap.name = s_tap.name_unfocused
			end
		end

		if this.ui.clicked then
			S:queue(this.sound_click)

			this.ui.clicked = nil
			clicks = clicks + 1

			if clicks >= this.required_clicks then
				goto label_151_0
			end
		end

		coroutine.yield()
	end

	s_tap.hidden = true

	S:queue(this.sound_blocked)
	U.animation_start(this, "hold", nil, store.tick_ts, 1, 1)
	U.y_wait(store, this.duration)

	::label_151_0::

	SU.ui_click_proxy_remove(target, this)

	s_tap.hidden = true

	S:queue(this.sound_released)
	U.y_animation_play(this, "remove", nil, store.tick_ts, 1, 1)
	SU.tower_block_dec(target)
	queue_remove(store, this)
end

scripts.veznan_souls_aura = {}

function scripts.veznan_souls_aura.update(this, store)
	local count = 0

	for i = 1, this.souls.count do
		if this.interrupt then
			break
		end

		local e = E:create_entity(this.souls.entity)

		e.angle = U.frandom(this.souls.angles[1], this.souls.angles[2])
		e.pos = V.vclone(this.pos)
		e.soul_phase = 1 - i / this.souls.count

		queue_insert(store, e)

		if this.souls.delay_frames >= 2 then
			this.souls.delay_frames = this.souls.delay_frames - 1
		end

		U.y_wait(store, fts(this.souls.delay_frames))
	end

	queue_remove(store, this)
end

scripts.veznan_soul = {}

function scripts.veznan_soul.update(this, store)
	local speed = math.random(this.speed[1], this.speed[2])
	local inc = math.random() > 0.5 and this.angle_variation or -this.angle_variation
	local angle_var = 0
	local start_ts = store.tick_ts
	local last_ts = store.tick_ts
	local ps = E:create_entity(this.particles_name)

	ps.particle_system.track_id = this.id

	local pl = ps.particle_system.particle_lifetime

	pl[1], pl[2] = pl[1] * this.soul_phase, pl[2] * this.soul_phase

	queue_insert(store, ps)

	while store.tick_ts - start_ts < this.duration do
		local dt = store.tick_ts - last_ts
		local a = this.angle + angle_var
		local x_step, y_step = V.rotate(a, speed * dt, 0)

		this.render.sprites[1].r = a
		this.pos.x = this.pos.x + x_step
		this.pos.y = this.pos.y + y_step
		angle_var = angle_var + inc

		if angle_var >= this.max_angle then
			inc = -this.angle_variation
		elseif angle_var <= this.min_angle then
			inc = this.angle_variation
		end

		last_ts = store.tick_ts

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.eb_greenmuck = {}

function scripts.eb_greenmuck.get_info(this)
	local ma = this.melee.attacks[1]
	local min, max = ma.damage_min, ma.damage_max

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_greenmuck.update(this, store)
	local ba = this.timed_attacks.list[1]

	local function ready_to_shoot()
		return enemy_ready_to_magic_attack(this, store, ba)
	end

	ba.ts = store.tick_ts

	::label_155_0::

	while true do
		if this.health.dead then
			U.y_animation_play(this, "death", nil, store.tick_ts)
			signal.emit("boss-killed", this)
			SU.fade_out_entity(store, this, this.unit.fade_time_after_death)

			local spawner = LU.list_entities(store.entities, "s15_rotten_spawner")[1]

			if spawner then
				spawner.interrupt = true
			end

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_shoot() then
				local targets = table.filter(store.soldiers, function(_, e)
					return not e.pending_removal and not e.health.dead and band(e.vis.flags, ba.vis_bans) == 0 and band(e.vis.bans, ba.vis_flags) == 0
				end)

				if #targets < 1 then
					SU.delay_attack(store, ba, 0.5)
				else
					U.animation_start(this, ba.animation, nil, store.tick_ts, false)
					U.y_wait(store, ba.shoot_time)

					local af = this.render.sprites[1].flip_x
					local o = ba.bullet_start_offset
					local random_targets = table.random_order(targets)

					for i, t in ipairs(random_targets) do
						if i > ba.count then
							break
						end

						local b = E:create_entity(ba.bullet)

						b.bullet.source_id = this.id
						b.bullet.target_id = t
						b.bullet.from = V.v(this.pos.x + (af and -1 or 1) * o.x, this.pos.y + o.y)
						b.bullet.to = V.vclone(t.pos)
						b.pos = V.vclone(b.bullet.from)

						queue_insert(store, b)
					end

					U.y_animation_wait(this)

					ba.ts = store.tick_ts
				end
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_shoot)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_155_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_shoot() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_155_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.eb_kingpin = {}

function scripts.eb_kingpin.get_info(this)
	local ma = this.melee.attacks[1]
	local min, max = ma.damage_min, ma.damage_max

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_kingpin.update(this, store)
	local hs = this.timed_attacks.list[1]
	local ho = this.timed_attacks.list[2]
	local stop_ts

	local function ready_to_stop()
		return store.tick_ts - stop_ts > this.stop_cooldown
	end

	stop_ts = store.tick_ts

	::label_159_0::

	while true do
		if this.health.dead then
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)
			signal.emit("boss-killed", this)
			SU.fade_out_entity(store, this, this.unit.fade_time_after_death)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_stop() then
				local stop_start = store.tick_ts
				local a = table.random(this.timed_attacks.list)

				U.animation_start(this, a.animation, nil, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, this.stop_wait) then
					goto label_159_0
				end

				local targets

				if a == hs and this.health.hp < this.health.hp_max then
					targets = {
						this
					}
				elseif a == ho then
					targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans, function(e)
						return e.health.hp < e.health.hp_max and e ~= this
					end)
				end

				if targets then
					for _, target in pairs(targets) do
						local m = E:create_entity(a.mod)

						m.modifier.source_id = this.id
						m.modifier.target_id = target.id

						queue_insert(store, m)
					end
				end

				if SU.y_enemy_animation_wait(this) then
					goto label_159_0
				end

				U.animation_start(this, a.animation, nil, store.tick_ts, false)

				if SU.y_enemy_animation_wait(this) then
					goto label_159_0
				end

				if SU.y_enemy_wait(store, this, this.stop_time - (store.tick_ts - stop_start)) then
					goto label_159_0
				end

				stop_ts = store.tick_ts
			end

			SU.y_enemy_walk_until_blocked(store, this, false, ready_to_stop)
		end
	end
end

scripts.eb_ulgukhai = {}

function scripts.eb_ulgukhai.get_info(this)
	local ma = this.melee.attacks[1]
	local min, max = ma.damage_min, ma.damage_max

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_ulgukhai.update(this, store)
	::label_163_0::

	while true do
		if this.health.dead then
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)
			signal.emit("boss-killed", this)
			SU.fade_out_entity(store, this, this.unit.fade_time_after_death)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			this.health.ignore_damage = true
			this.unit.blood_color = BLOOD_NONE
			this.vis.bans = U.flag_set(this.vis.bans, this.shielded_extra_vis_bans)

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false)

			if not cont then
				-- block empty
			else
				if blocker then
					this.health.ignore_damage = nil
					this.unit.blood_color = BLOOD_RED
					this.vis.bans = U.flag_clear(this.vis.bans, this.shielded_extra_vis_bans)

					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_163_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_163_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.eb_moloch = {}

-- function scripts.eb_moloch.get_info(this)
-- 	local ma = this.melee.attacks[1]
-- 	local min, max = ma.damage_min, ma.damage_max

-- 	return {
-- 		type = STATS_TYPE_ENEMY,
-- 		hp = this.health.hp,
-- 		hp_max = this.health.hp_max,
-- 		damage_min = min,
-- 		damage_max = max,
-- 		armor = this.health.armor,
-- 		magic_armor = this.health.magic_armor,
-- 		lives = this.enemy.lives_cost
-- 	}
-- end

function scripts.eb_moloch.update(this, store)
	local ha = this.timed_attacks.list[1]

	local function ready_to_horn()
		return enemy_ready_to_magic_attack(this, store, ha)
	end

	U.animation_start(this, "sitting", nil, store.tick_ts, true)

	this.phase = "sitting"
	this.phase_signal = nil
	this.health_bar.hidden = true

	while not this.phase_signal do
		coroutine.yield()
	end

	U.y_wait(store, this.stand_up_wait_time)
	S:queue(this.stand_up_sound)
	U.y_animation_play(this, "raise", nil, store.tick_ts)

	this.health_bar.hidden = nil
	this.health.ignore_damage = nil
	this.vis.bans = this.active_vis_bans
	ha.ts = store.tick_ts

	::label_165_0::

	while true do
		if this.health.dead then
			game.store.force_next_wave = true
			this.phase = "dead"

			LU.kill_all_enemies(store, true)
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)
			signal.emit("boss-killed", this)
			LU.kill_all_enemies(store, true)

			this.phase = "death-complete"

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_horn() then
				local dest = V.vclone(this.pos)
				local af = this.render.sprites[1].flip_x and -1 or 1

				if ha.hit_offset then
					dest.x = dest.x + af * ha.hit_offset.x
					dest.y = dest.y + ha.hit_offset.y
				end

				local targets = U.find_soldiers_in_range(store.soldiers, dest, 0, ha.damage_radius, ha.vis_flags or 0, ha.vis_bans or 0)

				if not targets or #targets < ha.min_targets then
					SU.delay_attack(store, ha, 0.5)
				else
					SU.hide_modifiers(store, this, true)
					S:queue(ha.sound, ha.sound_args)
					U.animation_start(this, ha.animation, nil, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, ha.hit_time) then
						goto label_165_0
					end

					targets = U.find_soldiers_in_range(store.soldiers, dest, 0, ha.damage_radius, ha.vis_flags or 0, ha.vis_bans or 0)

					if targets then
						for _, t in pairs(targets) do
							local d = SU.create_attack_damage(ha, t.id, this)

							queue_damage(store, d)
						end
					end

					for _, f in pairs(ha.fx_list) do
						local fx_name, positions = unpack(f)

						for _, p in pairs(positions) do
							local xo, yo = unpack(p)
							local fx = E:create_entity(fx_name)

							fx.render.sprites[1].ts = store.tick_ts
							fx.pos.x = this.pos.x + xo * af
							fx.pos.y = this.pos.y + yo

							queue_insert(store, fx)
						end
					end

					U.y_wait(store, fts(12))
					SU.show_modifiers(store, this, true)
					U.y_animation_wait(this)

					ha.ts = store.tick_ts
				end
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_horn)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_165_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_horn() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_165_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.eb_myconid = {}

-- function scripts.eb_myconid.get_info(this)
-- 	local ma = this.melee.attacks[1]
-- 	local min, max = ma.damage_min, ma.damage_max

-- 	return {
-- 		type = STATS_TYPE_ENEMY,
-- 		hp = this.health.hp,
-- 		hp_max = this.health.hp_max,
-- 		damage_min = min,
-- 		damage_max = max,
-- 		armor = this.health.armor,
-- 		magic_armor = this.health.magic_armor,
-- 		lives = this.enemy.lives_cost
-- 	}
-- end

function scripts.eb_myconid.update(this, store)
	local sa = this.timed_attacks.list[1]
	local si = 1

	local function ready_to_spore()
		return enemy_ready_to_magic_attack(this, store, sa) and this.nav_path.ni > sa.min_nodes
	end

	local function spawn_mushrooms(count, owner)
		local sp = E:create_entity(this.spawner_entity)

		sp.spawner.pi = this.nav_path.pi
		sp.spawner.spi = this.nav_path.spi
		sp.spawner.ni = this.nav_path.ni
		sp.spawner.random_cycle = {
			0,
			1 / count
		}
		sp.spawner.count = count
		sp.spawner.owner_id = owner

		queue_insert(store, sp)
	end

	sa.ts = store.tick_ts

	::label_168_0::

	while true do
		if this.health.dead then
			S:queue(this.sound_events.death)
			U.animation_start(this, "death", nil, store.tick_ts, false)
			U.y_wait(store, this.on_death_spawn_wait)
			spawn_mushrooms(this.on_death_spawn_count, nil)
			signal.emit("boss-killed", this)
			SU.fade_out_entity(store, this, this.unit.fade_time_after_death)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_spore() then
				local fx_wait, mod_wait, spawner_wait = unpack(sa.wait_times)

				S:queue(sa.sound)
				U.animation_start(this, "spores", nil, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, fx_wait) then
					goto label_168_0
				end

				local fx = E:create_entity(sa.fx)

				fx.render.sprites[1].ts = store.tick_ts
				fx.pos = V.vclone(this.pos)

				if sa.fx_offset then
					fx.pos.x = fx.pos.x + sa.fx_offset.x
					fx.pos.y = fx.pos.y + sa.fx_offset.y
				end

				queue_insert(store, fx)

				if SU.y_enemy_wait(store, this, mod_wait) then
					goto label_168_0
				end

				local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, sa.radius, sa.vis_flags, sa.vis_bans)

				if targets then
					for _, target in pairs(targets) do
						local m = E:create_entity(sa.mod)

						m.modifier.target_id = target.id
						m.modifier.source_id = this.id

						queue_insert(store, m)
					end
				end

				if SU.y_enemy_wait(store, this, spawner_wait) then
					goto label_168_0
				end

				spawn_mushrooms(sa.summon_counts[si] or sa.summon_counts[#sa.summon_counts], this.id)

				si = si + 1

				if SU.y_enemy_wait(store, this, sa.final_wait) then
					if sp then
						sp.spawner.interrupt = true
					end

					goto label_168_0
				end

				sa.ts = store.tick_ts
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_spore)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_168_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_spore() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_168_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.eb_blackburn = {}

function scripts.eb_blackburn.get_info(this)
	local ma = this.melee.attacks[1]
	local min, max = ma.damage_min, ma.damage_max

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		lives = this.enemy.lives_cost
	}
end

function scripts.eb_blackburn.update(this, store)
	local sa = this.timed_attacks.list[1]

	local function ready_to_smash()
		return enemy_ready_to_magic_attack(this, store, sa)
	end

	sa.ts = store.tick_ts

	::label_172_0::

	while true do
		if this.health.dead then
			LU.kill_all_enemies(store, true)
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)

			this.ui.can_click = false

			local megaspawner = LU.list_entities(store.entities, "mega_spawner")[1]

			if megaspawner then
				megaspawner.interrupt = true
			end

			store.force_next_wave = true

			U.animation_start(this, "death_end", nil, store.tick_ts, true)
			signal.emit("boss-killed", this)
			LU.kill_all_enemies(store, true)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_smash() then
				U.animation_start(this, sa.animation, nil, store.tick_ts, false)
				S:queue(sa.sound, sa.sound_args)

				if SU.y_enemy_wait(store, this, sa.hit_time) then
					goto label_172_0
				end

				local a = E:create_entity(sa.aura_shake)

				queue_insert(store, a)

				local af = this.render.sprites[1].flip_x
				local fx = E:create_entity(sa.fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts
				fx.pos.x = fx.pos.x + (af and -1 or 1) * sa.fx_offset.x
				fx.pos.y = fx.pos.y + (af and -1 or 1) * sa.fx_offset.y

				queue_insert(store, fx)
				SU.insert_sprite(store, sa.hit_decal, fx.pos, af, fts(2))

				local towers = U.find_towers_in_range(store.towers, this.pos, sa, function(t)
					return t.tower.can_be_mod
				end)

				if towers then
					for _, tt in pairs(towers) do
						local tm = E:create_entity(sa.mod_towers)

						tm.modifier.source_id = this.id
						tm.modifier.target_id = tt.id

						queue_insert(store, tm)
					end
				end

				local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, sa.damage_radius, sa.vis_flags or 0, sa.vis_bans or 0)

				if targets then
					for _, t in pairs(targets) do
						local d = E:create_entity("damage")

						d.damage_type = sa.damage_type
						d.value = math.random(sa.damage_min, sa.damage_max)
						d.source_id = this.id
						d.target_id = t.id

						queue_damage(store, d)

						local tm = E:create_entity(sa.mod)

						tm.modifier.source_id = this.id
						tm.modifier.target_id = t.id

						queue_insert(store, tm)
					end
				end

				U.y_animation_wait(this)

				if SU.y_enemy_wait(store, this, sa.after_hit_wait) then
					goto label_172_0
				end

				sa.cooldown = sa.after_cooldown
				sa.ts = store.tick_ts
			end

			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_smash)

			if not cont then
				-- block empty
			else
				if blocker and blocker.unit and not blocker.unit.is_stunned then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_172_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_smash() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_172_0
						end

						coroutine.yield()
					end
				else
					U.unblock_target(store, blocker)
				end

				coroutine.yield()
			end
		end
	end
end

scripts.mod_blackburn_tower = {}

function scripts.mod_blackburn_tower.update(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos.x, this.pos.y = target.pos.x, target.pos.y

	if this.tween then
		this.tween.disabled = false
		this.tween.reverse = false
		this.tween.ts = store.tick_ts
	end

	U.y_wait(store, m.duration)

	if this.tween then
		this.tween.ts = store.tick_ts
		this.tween.reverse = true
	end

	SU.tower_block_dec(target)
	U.y_wait(store, this.tween.props[1].keys[2][1])
	queue_remove(store, this)
end

scripts.blackburn_aura = {}

function scripts.blackburn_aura.update(this, store)
	local last_ts = store.tick_ts
	local cg = store.count_groups[this.count_group_type]

	while true do
		local source = store.entities[this.aura.source_id]

		if not source or source.health.dead then
			queue_remove(store, this)

			return
		end

		this.pos = source.pos

		if store.tick_ts - last_ts >= this.aura.cycle_time then
			last_ts = store.tick_ts

			for _, e in pairs(store.soldiers) do
				if e and not e.health.dead  and e.soldier.tower_id == source.id then
					tower_skeletons_count = tower_skeletons_count + 1
				end
			end

			local max_spawns = this.count_group_max - (cg[this.count_group_name] or 0)

			if max_spawns < 1 then
				-- block empty
			else
				local dead_soldiers = table.filter(store.soldiers, function(k, v)
					return v.soldier and v.health and v.health.dead and band(v.vis.bans or 0, F_SKELETON) == 0 and store.tick_ts - v.health.death_ts >= this.aura.cycle_time and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius)
				end)

				dead_soldiers = table.slice(dead_soldiers, 1, max_spawns)

				local spii = math.random(1, 3)

				for _, dead in pairs(dead_soldiers) do
					local nearest_nodes = P:nearest_nodes(dead.pos.x, dead.pos.y, {
						source.nav_path.pi
					})

					if #nearest_nodes < 1 then
						-- block empty
					else
						local pi, spi, ni = unpack(nearest_nodes[1])

						if not P:is_node_valid(pi, ni) then
							-- block empty
						else
							U.sprites_hide(dead)

							dead.vis.bans = bor(dead.vis.bans, F_SKELETON)

							local e = E:create_entity(this.aura.raise_entity)

							spii = km.zmod(spii + 1, 3)
							e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, spii, ni
							e.enemy.gold = 0
							e.pos = V.vclone(dead.pos)
							e.render.sprites[1].name = "raise"

							E:add_comps(e, "count_group")

							e.count_group.name = this.count_group_name
							e.count_group.type = this.count_group_type

							queue_insert(store, e)
						end
					end
				end
			end
		end

		coroutine.yield()
	end
end

scripts.eb_elder_shaman = {}

function scripts.eb_elder_shaman.update(this, store)
	local taunt = this.taunt

	local function y_show_taunt(set, index, duration)
		index = index or math.random(taunt.sets[set].start_idx, taunt.sets[set].end_idx)
		duration = duration or taunt.duration
		taunt.ts = store.tick_ts
		taunt.next_ts = store.tick_ts + math.random(taunt.delay_min, taunt.delay_max)

		local t = E:create_entity("decal_elder_shaman_shoutbox")

		t.texts.list[1].text = _(string.format(taunt.sets[set].format, index))
		t.pos.x, t.pos.y = this.pos.x + taunt.offset.x, this.pos.y + taunt.offset.y
		t.render.sprites[1].ts = store.tick_ts
		t.render.sprites[2].ts = store.tick_ts

		queue_insert(store, t)
		U.y_wait(store, duration)

		t.tween.props[1].disabled = true
		t.tween.props[2].disabled = true
		t.tween.ts = store.tick_ts
		t.tween.reverse = true
		t.tween.remove = true

		return t
	end

	local function find_target(at)
		local targets = table.filter(store.entities, function(_, e)
			return not e.pending_removal and e.health and not e.health.dead and e.vis and band(e.vis.flags, at.vis_bans) == 0 and band(e.vis.bans, at.vis_flags) == 0 and (not at.path_margins or P:is_node_valid(e.nav_path.pi, e.nav_path.ni) and e.nav_path.ni > P:get_visible_start_node(e.nav_path.pi) + at.path_margins[1] and e.nav_path.ni < P:get_defend_point_node(e.nav_path.pi) - at.path_margins[2])
		end)

		if at.power_name == "damage" then
			local pis = U.find_paths_with_enemies(store.enemies, at.enemy_vis_flags, at.enemy_vis_bans)

			if not pis then
				return nil
			end

			targets = table.filter(targets, function(_, e)
				local nodes = P:nearest_nodes(e.pos.x, e.pos.y, pis, nil, true)

				return #nodes > 0
			end)
		end

		if #targets < 1 then
			return nil
		else
			local target = table.random(targets)

			if target.nav_path then
				return target, target.nav_path.pi, target.nav_path.ni
			else
				local nodes = P:nearest_nodes(target.pos.x, target.pos.y)

				if #nodes < 1 then
					return nil
				else
					return target, nodes[1][1], nodes[1][3]
				end
			end
		end
	end

	this.percussionist = LU.list_entities(store.entities, "decal_s81_percussionist")[1]
	this.phase = "welcome"

	U.y_wait(store, 1.5)
	y_show_taunt("welcome", 1)
	y_show_taunt("welcome", 2)

	this.phase = "prebattle"

	while this.phase == "prebattle" do
		if store.tick_ts > taunt.next_ts then
			y_show_taunt(this.phase)
		end

		if store.wave_group_number > 0 then
			this.phase = "battle"
		end

		coroutine.yield()
	end

	local last_wave_number = 0
	local a = this.attacks
	local ah = this.attacks.list[1]
	local ad = this.attacks.list[2]
	local as = this.attacks.list[3]
	local wave_config

	while true do
		if store.tick_ts > taunt.next_ts then
			y_show_taunt(this.phase)
		end

		if store.wave_group_number ~= last_wave_number then
			log.debug("EB_ELDER_SHAMAN: setting wave config for %s", store.wave_group_number)

			last_wave_number = store.wave_group_number
			wave_config = W:get_endless_boss_config(store.wave_group_number)
			a.chance = wave_config.chance
			a.cooldown = wave_config.cooldown
			a.multiple_attacks_chance = wave_config.multiple_attacks_chance
			a.power_chances = wave_config.power_chances
			a.ts = store.tick_ts
		end

		if store.tick_ts - a.ts > a.cooldown then
			log.debug("EB_ELDER_SHAMAN: power cooldown complete")

			a.ts = store.tick_ts
			this.percussionist.play_loops = 3

			while math.random() < a.chance do
				local pconf, e, api, aspi, ani
				local a_idx = U.random_table_idx(a.power_chances)
				local aa = this.attacks.list[a_idx]
				local plevel = km.clamp(0, 9000000000, store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)
				local target, tpi, tni = find_target(aa)

				if not target then
					log.debug("EB_ELDER_SHAMAN: no enemies found for attack %s", aa.aura)
				else
					this.percussionist.play_loops = 9

					U.animation_start(this, a.animation, nil, store.tick_ts, false)
					U.y_wait(store, U.frandom(a.delay[1], a.delay[2]))

					pconf = wave_config.powers_config[aa.power_name]
					e = E:create_entity(aa.aura)
					e.aura.duration = pconf.duration + plevel * pconf.durationIncrement
					e.aura.radius = pconf.range / 2
					api, aspi, ani = tpi, 1, tni

					if aa.node_offset then
						ani = tni + math.random(aa.node_offset[1], aa.node_offset[2])
					end

					if aa.path_margins then
						ani = km.clamp(P:get_visible_start_node(api) + aa.path_margins[1], P:get_defend_point_node(api) - aa.path_margins[2], ani)
					end

					log.debug("EB_ELDER_SHAMAN enemy aura insertion node: %s,%s,%s target ni:%s defend ni:%s", api, aspi, ani, tni, P:get_defend_point_node(api))

					e.pos = P:node_pos(api, aspi, ani)

					if aa == ah then
						e.aura.mod_args = {
							["hps.heal_min"] = math.floor(pconf.healthPerTick + plevel * pconf.healthPerTickIncrement),
							["hps.heal_max"] = math.floor(pconf.healthPerTick + plevel * pconf.healthPerTickIncrement)
						}
					elseif aa == ad then
						e.aura.mod_args = {
							["dps.damage_min"] = math.floor(pconf.damagePerTick + plevel * pconf.damagePerTickIncrement),
							["dps.damage_max"] = math.floor(pconf.damagePerTick + plevel * pconf.damagePerTickIncrement)
						}
					elseif aa == as then
						e.aura.mod_args = {
							["slow.factor"] = pconf.speedModifier + plevel * pconf.speedModifierIncrement
						}
					end

					queue_insert(store, e)
					U.y_animation_wait(this)
					U.animation_start(this, "idle", nil, store.tick_ts)
				end

				if math.random() >= a.multiple_attacks_chance then
					break
				end
			end
		end

		coroutine.yield()
	end
end

scripts.decal_s81_percussionist = {}

function scripts.decal_s81_percussionist.update(this, store)
	while true do
		while this.play_loops > 0 do
			local loops = this.play_loops

			this.play_loops = 0

			U.y_animation_play(this, "play", nil, store.tick_ts, loops)
			U.animation_start(this, "idle", nil, store.tick_ts)
		end

		coroutine.yield()
	end
end

scripts.aura_elder_shaman = {}

function scripts.aura_elder_shaman.update(this, store)
	local a = this.aura
	local s = this.render.sprites
	local ring_sid = 1
	local ground_sid = 2
	local totem_sid = 3
	local fx_sid = 4

	s[ring_sid].ts = store.tick_ts

	U.y_animation_play(this, "start", nil, store.tick_ts, 1, totem_sid)

	s[fx_sid].hidden = false
	this.aura.ts = store.tick_ts

	while store.tick_ts - this.aura.ts < a.duration do
		local targets = U.find_targets_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local e = E:create_entity(this.aura.mod)

				e.modifier.target_id = target.id
				e.modifier.source_id = this.id

				for k, v in pairs(a.mod_args) do
					LU.eval_set_prop(e, k, v)
				end

				queue_insert(store, e)
			end
		end

		U.y_wait(store, a.cycle_time)
	end

	s[ground_sid].hidden = true
	s[ring_sid].hidden = true
	s[fx_sid].hidden = true

	U.y_animation_play(this, "end", nil, store.tick_ts, 1, totem_sid)
	queue_remove(store, this)
end

scripts.axe_barbarian = {}

function scripts.axe_barbarian.insert(this, store, script)
	if scripts.arrow.insert(this, store, script) then
		AC:inc_check("AXE_RAINER")

		return true
	else
		return false
	end
end

scripts.bomb_cluster = {}

function scripts.bomb_cluster.insert(this, store)
	local b = this.bullet
	local dest = V.vclone(b.to)
	local target = store.entities[b.target_id]
	local nearest_nodes = P:nearest_nodes(b.to.x, b.to.y, target and {
		target.nav_path.pi
	} or nil)

	if #nearest_nodes > 0 then
		local pi, spi, ni = unpack(nearest_nodes[1])

		this._pred_pi, this._pred_ni = pi, ni
		dest = P:node_pos(pi, 1, ni)
	end

	b.to.x, b.to.y = dest.x + b.dest_pos_offset.x, dest.y + b.dest_pos_offset.y

	return scripts.bomb.insert(this, store)
end

function scripts.bomb_cluster.update(this, store)
	local b = this.bullet

	this.render.sprites[1].r = 20 * math.pi / 180 * (b.to.x > b.from.x and 1 or -1)

	while store.tick_ts - b.ts < b.flight_time do
		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end

		coroutine.yield()
	end

	if b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	local pi, ni = this._pred_pi, this._pred_ni
	local ni_offset = b.fragment_node_spread * math.floor(b.fragment_count / 2)
	local dest = b.to

	for i = 1, b.fragment_count do
		local bf_dest

		if pi and ni then
			bf_dest = P:node_pos(pi, 1, ni + ni_offset - i * b.fragment_node_spread)
		else
			bf_dest = U.point_on_ellipse(dest, (50 * math.random() + 45) / 2, 2 * math.pi * i / b.fragment_count)
		end

		bf_dest.x = bf_dest.x + U.frandom(-b.fragment_pos_spread.x, b.fragment_pos_spread.x)
		bf_dest.y = bf_dest.y + U.frandom(-b.fragment_pos_spread.y, b.fragment_pos_spread.y)

		local bf = E:create_entity(b.fragment_name)

		bf.bullet.from = V.vclone(this.pos)
		bf.bullet.to = bf_dest
		bf.bullet.flight_time = bf.bullet.flight_time + fts(i) * math.random(1, 2)
		bf.render.sprites[1].r = 100 * math.random() * (math.pi / 180)

		queue_insert(store, bf)
		AC:inc_check("CLUSTERED")
	end

	queue_remove(store, this)
end

scripts.ray_tesla = {}

function scripts.ray_tesla.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = b.to
	local l_src, l_dst = V.vclone(this.pos), V.vclone(b.to)

	s.scale = V.v(1, 1)

	local function update_sprite()
		if target and target.motion then
			dest.x, dest.y = target.pos.x, target.pos.y

			if target.unit and target.unit.hit_offset then
				dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
			end
		end

		if source and source.motion then
			this.pos.x, this.pos.y = source.pos.x, source.pos.y

			if source.unit and source.unit.hit_offset then
				this.pos.x, this.pos.y = this.pos.x + source.unit.hit_offset.x, this.pos.y + source.unit.hit_offset.y
			end
		end

		local dsrc = math.max(math.abs(this.pos.x - l_src.x), math.abs(this.pos.y - l_src.y))
		local ddst = math.max(math.abs(dest.x - l_dst.x), math.abs(dest.y - l_dst.y))

		if dsrc > b.max_track_distance or ddst > b.max_track_distance then
			log.paranoid("(%s) ray_tesla jumped out of max_track_distance", this.id)

			s.hidden = true
			target = nil

			return false
		end

		l_src.x, l_src.y = this.pos.x, this.pos.y
		l_dst.x, l_dst.y = dest.x, dest.y

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
		s.scale.y = 0.4 + km.clamp(0, 0.6, s.scale.x * 0.6)
		s.scale.y = s.scale.y * this.bounce_scale_y

		return true
	end

	if target then
		s.ts = store.tick_ts

		if not update_sprite() then
			-- block empty
		else
			if not this.excluded_templates or not table.contains(this.excluded_templates, target.template_name) then
                if target.template_name == "hero_thor" then
                    scripts.heal(target, target.lightning_heal)
                else
                    local mod = E:create_entity(b.mod)
                    local bounce_factor = UP:get_upgrade("engineer_efficiency") and 1 or this.bounce_damage_factor
                    local total_damage = math.ceil(math.random(this.bounce_damage_min, this.bounce_damage_max) * bounce_factor)
                    local actual_damage = math.min(total_damage, target.health.hp)
                    local last_damage = total_damage - actual_damage
                    local frame_damage = math.floor(actual_damage / mod.dps.cocos_frames)
                    local mod_damage = frame_damage * mod.dps.cocos_cycles
                    local dps_hits = math.floor(mod.modifier.duration / mod.dps.damage_every)
                    local dps_damage = math.floor(mod_damage / dps_hits)
                    local first_damage = mod_damage - dps_damage * dps_hits
                    mod.modifier.damage_factor = b.damage_factor
                    mod.modifier.level = b.level
                    mod.modifier.source_id = b.source_id
                    mod.modifier.target_id = target.id

                    mod.dps.damage_max = dps_damage
                    mod.dps.damage_min = dps_damage
                    mod.dps.damage_last = last_damage
                    mod.dps.damage_first = dps_damage + first_damage

                    queue_insert(store, mod)
                end
			end

			table.insert(this.seen_targets, target.id)

			if not this.bounces then
				this.max_bounces = this.bounces_lvl[b.level]
                this.bounces = 0
			end
            if this.bounce_range_inc then
                this.bounce_range = this.bounce_range + this.bounce_range_inc * b.level
            end
			if this.bounces < this.max_bounces then
				U.y_wait(store, this.bounce_delay)
                local bounce_target = U.find_nearest_target(store.entities, dest, 0, this.bounce_range, this.bounce_vis_flags, this.bounce_vis_bans, function(v)
					return (not table.contains(this.seen_targets, v.id)) and (v.enemy or v.template_name == "hero_thor")
				end)

				if bounce_target then
					log.paranoid("ray_tesla bounce from %s to %s dist:%s", target.id, bounce_target.id, V.dist(dest.x, dest.y, bounce_target.pos.x, bounce_target.pos.y))

					local r = E:create_entity(this.template_name)

					r.pos = V.vclone(dest)
                    r.bounce_range = this.bounce_range
					r.bullet.to = V.vclone(bounce_target.pos)
					r.bullet.target_id = bounce_target.id
					r.bullet.source_id = target.id
                    r.bullet.damage_factor = b.damage_factor
                    r.bullet.level = b.level
                    r.max_bounces = this.max_bounces
					r.bounce_scale_y = r.bounce_scale_y * r.bounce_scale_y_factor
					r.seen_targets = this.seen_targets
					r.bounce_damage_factor = math.max(this.bounce_damage_factor + this.bounce_damage_factor_inc, this.bounce_damage_factor_min)
                    if bounce_target.template_name == "hero_thor" then
                        r.bounces = 0
                        r.bounce_range = this.bounce_range * 1.5
                    else
                        r.bounces = this.bounces + 1
                    end
					queue_insert(store, r)
				end
			end

			while not U.animation_finished(this) do
				if target then
					update_sprite()
				end

				coroutine.yield()
			end
		end
	end

	queue_remove(store, this)
end

scripts.hacksaw_sawblade = {}

function scripts.hacksaw_sawblade.update(this, store)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps
	local bounce_count = 0

	U.animation_start(this, "flying", nil, store.tick_ts, true)

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_193_0::

    local mdist2 = mspeed * mspeed * store.tick_length * store.tick_length

	while V.dist2(this.pos.x, this.pos.y, b.to.x, b.to.y) > mdist2 do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead then
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		queue_insert(store, sfx)
	end

	if b.hit_blood_fx and target.unit.blood_color ~= BLOOD_NONE then
		local sfx = E:create_entity(b.hit_blood_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts

		if sfx.use_blood_color and target.unit.blood_color then
			sfx.render.sprites[1].name = target.unit.blood_color
			sfx.render.sprites[1].r = this.render.sprites[1].r
		end

		queue_insert(store, sfx)
	end

	if bounce_count < this.bounces_max then
		local target = U.find_random_enemy(store.enemies, this.pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
			return v ~= target
		end)

		if target then
			S:queue(this.sound_events.bounce)

			bounce_count = bounce_count + 1
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			b.target_id = target.id

			goto label_193_0
		end
	end

	queue_remove(store, this)
end

scripts.ray_thor = {}

function scripts.ray_thor.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = b.to

	s.scale = V.v(1, 1)

	local function update_sprite()
		if target and target.motion then
			dest.x, dest.y = target.pos.x, target.pos.y

			if target.unit and target.unit.hit_offset then
				dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
		s.scale.y = 0.4 + km.clamp(0, 0.6, s.scale.x * 0.6)
		s.scale.y = s.scale.y * this.bounce_scale_y
	end

	if target then
		s.ts = store.tick_ts

		update_sprite()

		local mod = E:create_entity(b.mod)

		mod.modifier.source_id = b.source_id
		mod.modifier.target_id = target.id

		queue_insert(store, mod)

		while not U.animation_finished(this) do
			update_sprite()
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.aura_ranger_thorn = {}

function scripts.aura_ranger_thorn.update(this, store)
	local a = this.aura

	a.ts = store.tick_ts

	local function find_targets()
		local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans, function(e)
			return not e.enemy.counts[a.mod] or e.enemy.counts[a.mod] < a.max_times
		end)

		return targets
	end

	while true do
		local owner = store.entities[a.source_id]

		if not owner then
			log.error("aura_ranger_thorn has no parent tower. removing")

			break
		end

		if owner.tower.blocked then
			-- block empty
		elseif store.tick_ts - a.ts >= a.cooldown then
			local targets = find_targets()

			if not targets or #targets < a.min_count then
				-- block empty
			else
				a.ts = store.tick_ts

				U.animation_start(owner, a.owner_animation, nil, store.tick_ts, false, a.owner_sid)
				U.y_wait(store, a.hit_time)

				targets = find_targets()

				if not targets or #targets < a.min_count then
					-- block empty
				else
					S:queue(a.hit_sound)

					for i = 1, math.min(#targets, a.max_count + a.max_count_inc * owner.powers.thorn.level) do
						local e = targets[i]
						local m = E:create_entity(a.mod)

						m.modifier.target_id = e.id
						m.modifier.source_id = this.id
						m.modifier.level = owner.powers.thorn.level
						m.modifier.duration = m.modifier.duration + m.modifier.duration_inc * owner.powers.thorn.level

                        if U.has_modifier_in_list(store, e, {"mod_ranger_poison"}) then
                            m.modifier.duration = m.modifier.duration + owner.powers.poison.level * m.modifier.duration_inc * 0.5
                        end

						queue_insert(store, m)
					end

					U.y_animation_wait(owner, a.owner_sid)
				end
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.aura_tesla_overcharge = {}

function scripts.aura_tesla_overcharge.update(this, store)
	local a = this.aura
	local ps = E:create_entity(this.particles_name)

	ps.pos = V.vclone(this.pos)

	queue_insert(store, ps)
	U.y_wait(store, a.duration)

	local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

	if targets then
		for _, e in pairs(targets) do
			local d = SU.create_attack_damage(a, e.id, this)

			queue_damage(store, d)

			if not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, e.template_name) then
				local m = E:create_entity(a.mod)

				m.modifier.target_id = e.id
				m.modifier.source_id = this.id

				queue_insert(store, m)
			end
		end
	end

	queue_remove(store, this)
end

scripts.aura_chill_elora = {}

function scripts.aura_chill_elora.update(this, store)
	local last_hit_ts = 0

	U.sprites_hide(this)

	if this.delay then
		U.y_wait(store, this.delay)
	end

	for _, s in pairs(this.render.sprites) do
		s.ts = store.tick_ts
	end

	U.sprites_show(this)

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.aura.duration then
			this.tween.disabled = false
			this.tween.ts = store.tick_ts

			return
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			last_hit_ts = store.tick_ts

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and not v._last_on_ice and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if not U.has_modifiers(store, target, this.aura.mod) then
					SU.remove_modifiers_by_type(store, target, MOD_TYPE_SLOW, this.aura.mod)
				end

				local new_mod = E:create_entity(this.aura.mod)

				new_mod.modifier.level = this.aura.level
				new_mod.modifier.target_id = target.id
				new_mod.modifier.source_id = this.id

				queue_insert(store, new_mod)
			end
		end

		coroutine.yield()
	end
end

scripts.aura_slow_bolin = {}

function scripts.aura_slow_bolin.update(this, store)
	last_hit_ts = store.tick_ts - this.aura.cycle_time

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.aura.duration then
			U.animation_start(this, "end", nil, store.tick_ts)

			this.tween.disabled = false
			this.tween.ts = store.tick_ts

			return
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			last_hit_ts = store.tick_ts

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				local new_mod = E:create_entity(this.aura.mod)

				new_mod.modifier.level = this.aura.level
				new_mod.modifier.target_id = target.id
				new_mod.modifier.source_id = this.id

				queue_insert(store, new_mod)
			end
		end

		coroutine.yield()
	end
end

scripts.aura_ignus_particles = {}

function scripts.aura_ignus_particles.update(this, store)
	local source = store.entities[this.aura.source_id]

	if not source then
		queue_remove(store, this)

		return
	end

	this.pos = source.pos

	local particles = {}
	local s = source.render.sprites[1]
	local h = source.health
	local flip = s.flip_x

	for i, o in ipairs(this.particle_offsets) do
		local ps = E:create_entity(this.particles_name)

		ps.particle_system.track_id = source.id
		ps.particle_system.track_offset = o
		ps.particle_system.ts_offset = fts(2 * i)

		queue_insert(store, ps)
		table.insert(particles, ps)
	end

	::label_209_0::

	while h.dead or not table.contains(this.emit_states, s.name) do
		coroutine.yield()
	end

	for i, p in pairs(particles) do
		p.particle_system.emit = true
	end

	while table.contains(this.emit_states, s.name) and not h.dead do
		if s.flip_x ~= flip then
			flip = s.flip_x

			for i, p in pairs(particles) do
				p.particle_system.emit_offset = s.flip_x and this.flip_offset or nil
			end
		end

		coroutine.yield()
	end

	for _, p in pairs(particles) do
		p.particle_system.emit = false
	end

	goto label_209_0
end

scripts.aura_ignus_surge_of_flame = {}

function scripts.aura_ignus_surge_of_flame.update(this, store)
	local source = store.entities[this.aura.source_id]

	if not source then
		queue_remove(store, this)

		return
	end

	this.pos = source.pos

	local s = source.render.sprites[1]
	local ps = E:create_entity(this.particles_name)

	ps.particle_system.track_id = source.id
	ps.particle_system.emit = true

	queue_insert(store, ps)

	local a = this.aura
	local ts = 0
	local targets

	while s.name == this.damage_state do
		if store.tick_ts - ts + 1e-09 <= a.cycle_time then
			-- block empty
		else
			targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.damage_radius, a.damage_flags or 0, a.damage_bans or 0) or {}
			ts = store.tick_ts

			for _, t in pairs(targets) do
				local d = E:create_entity("damage")

				d.damage_type = a.damage_type
				d.source_id = this.id
				d.target_id = t.id
				d.value = math.random(a.damage_min, a.damage_max)

				queue_damage(store, d)

				local fx = E:create_entity(a.hit_fx)

				fx.pos = V.vclone(t.pos)

				if t.unit and t.unit.mod_offset then
					fx.pos.x, fx.pos.y = fx.pos.x + t.unit.mod_offset.x, fx.pos.y + t.unit.mod_offset.y
				end

				for i = 1, #fx.render.sprites do
					fx.render.sprites[i].ts = store.tick_ts
				end

				queue_insert(store, fx)
			end
		end

		coroutine.yield()
	end

	ps.particle_system.emit = false

	queue_remove(store, this)
end

scripts.aura_ingvar_bear_regenerate = {}

function scripts.aura_ingvar_bear_regenerate.update(this, store)
	local hero = store.entities[this.aura.source_id]

	if not hero then
		log.error("hero not found for aura_ingvar_bear_regenerate")
		queue_remove(store, this)

		return
	end

	this.aura.ts = store.tick_ts

	while true do
		if not hero.is_bear or hero.health.dead then
			-- block empty
		elseif store.tick_ts - this.aura.ts >= this.regen.cooldown then
			this.aura.ts = store.tick_ts
			hero.health.hp = hero.health.hp + this.regen.health
			hero.health.hp = km.clamp(0, hero.health.hp_max, hero.health.hp)
		end

		coroutine.yield()
	end
end

scripts.aura_10yr_particles = {}

function scripts.aura_10yr_particles.update(this, store)
	local source = store.entities[this.aura.source_id]

	if not source then
		queue_remove(store, this)

		return
	end

	this.pos = source.pos

	local particles = {}
	local s = source.render.sprites[1]
	local h = source.health
	local flip = s.flip_x

	for i, o in ipairs(this.particle_offsets) do
		local ps = E:create_entity(this.particles_name)

		ps.particle_system.track_id = source.id
		ps.particle_system.track_offset = o
		ps.particle_system.ts_offset = fts(2 * i)

		queue_insert(store, ps)
		table.insert(particles, ps)
	end

	for i, p in pairs(particles) do
		p.particle_system.emit = false
	end

	::label_212_0::

	while h.dead or not source.is_buffed or not table.contains(this.emit_states, s.name) do
		coroutine.yield()
	end

	for i, p in pairs(particles) do
		p.particle_system.emit = true
	end

	while table.contains(this.emit_states, s.name) and not h.dead and source.is_buffed do
		if s.flip_x ~= flip then
			flip = s.flip_x

			for i, p in pairs(particles) do
				p.particle_system.emit_offset = s.flip_x and this.flip_offset or nil
			end
		end

		coroutine.yield()
	end

	for _, p in pairs(particles) do
		p.particle_system.emit = false
	end

	goto label_212_0
end

scripts.aura_10yr_fireball = {}

function scripts.aura_10yr_fireball.update(this, store)
	local start_y = store.visible_coords and store.visible_coords.top or REF_H
	local bdt
	local a = this.aura
	local owner = store.entities[a.source_id]

	if not owner then
		log.error("owner %s was not found. bailing out", a.source_od)
	else
		do
			local bdy = math.abs(owner.pos.y - start_y)
			local tpl = E:get_template(a.entity)

			bdt = bdy / tpl.bullet.max_speed
		end

		for i = 1, a.loops do
			local target, __, pred_pos = U.find_foremost_enemy(store.enemies, owner.pos, a.min_range, a.max_range, bdt, a.vis_flags, a.vis_ban)
			local b = E:create_entity(a.entity)

			if target then
				local dh = start_y - pred_pos.y
				local dx = dh * 0.4

				b.pos.x, b.pos.y = pred_pos.x + dx, start_y
				b.bullet.to = V.v(pred_pos.x, pred_pos.y)
			else
				local tx = owner.pos.x + math.random(-20, 20)
				local ty = owner.pos.y + math.random(-20, 20)
				local dh = start_y - ty
				local dx = dh * 0.4

				b.pos.x, b.pos.y = tx + dx, start_y
				b.bullet.to = V.v(tx, ty)
			end

			b.bullet.from = V.vclone(b.pos)

			queue_insert(store, b)
			U.y_wait(store, a.delay)
		end
	end

	queue_remove(store, this)
end

scripts.aura_10yr_bomb = {}

function scripts.aura_10yr_bomb.update(this, store)
	local a = this.aura

	local function do_attack(pos, last_attack)
		local fx = E:create_entity(a.fx)

		fx.pos.x, fx.pos.y = pos.x, pos.y

		if not last_attack then
			fx.render.sprites[2].scale = V.v(0.8, 0.8)
		end

		fx.render.sprites[2].ts = store.tick_ts
		fx.tween.ts = store.tick_ts

		queue_insert(store, fx)

		local radius = last_attack and a.last_attack_damage_radius or a.damage_radius
		local targets = U.find_enemies_in_range(store.enemies, pos, 0, radius, a.vis_flags, a.vis_bans)

		if targets then
			for _, t in pairs(targets) do
				local d = E:create_entity("damage")

				d.value = math.random(a.damage_min, a.damage_max)
				d.damage_type = a.damage_type
				d.source_id = this.id
				d.target_id = t.id

				queue_damage(store, d)

				if (last_attack or math.random() < a.stun_chance) and U.flags_pass(t.vis, this.stun) then
					local m = E:create_entity(this.stun.mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = t.id

					queue_insert(store, m)
				end
			end

			log.paranoid(">>>> aura_10yr_bomb POS:%s,%s  damaged:%s", pos.x, pos.y, table.concat(table.map(targets, function(k, v)
				return v.id
			end), ","))
		end
	end

	local pi, spi, ni, tni, target, origin
	local target_info = U.find_enemies_in_paths(store.enemies, this.pos, a.min_nodes, a.max_nodes, nil, a.vis_flags, a.vis_bans)

	if not target_info or #target_info < a.min_count then
		log.error("aura_10yr_bomb could not find valid enemies in the hero paths")
	else
		target = target_info[1].enemy
		origin = target_info[1].origin
		pi, spi, ni = unpack(origin)
		tni = target.nav_path.ni

		for i = 1, a.steps do
			local nni = ni + i * a.step_nodes * km.sign(tni - ni)
			local oni = ni + i * a.step_nodes * km.sign(tni - ni) * -1

			spi = i == a.steps and 1 or (spi == 2 or spi == 3) and 1 or math.random() < 0.5 and 2 or 3

			U.y_wait(store, a.step_delay)

			local spos = P:node_pos(pi, spi, nni)

			do_attack(spos, i == a.steps)

			if i == 1 then
				local opos = P:node_pos(pi, spi, oni)

				do_attack(opos, false)
			end
		end
	end

	queue_remove(store, this)
end

scripts.aura_spectral_knight = {}

function scripts.aura_spectral_knight.update(this, store)
	U.y_wait(store, this.aura.delay)

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	return scripts.aura_apply_mod.update(this, store)
end

scripts.aura_skeleton_big = {}
function scripts.aura_skeleton_big.update(this, store)
	U.y_wait(store, this.aura.delay)

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	return scripts.aura_apply_mod.update(this, store)
end

scripts.aura_abomination = {}
function scripts.aura_abomination.update(this, store)
	U.y_wait(store, this.aura.delay)

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	return scripts.aura_apply_mod.update(this, store)
end

scripts.mod_slow_curse = {}

function scripts.mod_slow_curse.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target or U.has_modifier_types(store, target, MOD_TYPE_SLOW, MOD_TYPE_RAGE) then
		return false
	end

	return scripts.mod_slow.insert(this, store)
end

scripts.mod_thorn = {}

function scripts.mod_thorn.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) queue/insertion", this.template_name, this.id)

		if U.flags_pass(target.vis, this.modifier) then
			this._target_prev_bans = target.vis.bans
			target.vis.bans = U.flag_set(target.vis.bans, F_THORN)
		end
	else
		log.debug("%s (%s) queue/removal", this.template_name, this.id)

		if this._target_prev_bans then
			target.vis.bans = this._target_prev_bans
		end
	end
end

function scripts.mod_thorn.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) dequeue/insertion", this.template_name, this.id)

		if this._target_prev_bans then
			target.vis.bans = this._target_prev_bans
		end
	end
end

function scripts.mod_thorn.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local s = this.render.sprites[1]

	s.ts = store.tick_ts

	if target and target.health and not target.health.dead and this._target_prev_bans ~= nil and (not target.enemy.counts.mod_thorn or target.enemy.counts.mod_thorn < this.max_times_applied) then
		SU.stun_inc(target)

		s.prefix = s.size_prefixes[target.unit.size]
		s.scale = s.size_scales[target.unit.size]

		return true
	else
		return false
	end
end

function scripts.mod_thorn.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		target.health.ignore_damage = false

		SU.stun_dec(target)
	end

	return true
end

function scripts.mod_thorn.update(this, store)
	local hit_ts
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		queue_remove(store, this)

		return
	end

	if this.max_times_applied then
		if not target.enemy.counts.mod_thorn then
			target.enemy.counts.mod_thorn = 0
		end

		target.enemy.counts.mod_thorn = target.enemy.counts.mod_thorn + 1
	end

	this.pos = target.pos

	local target_flip = target.render.sprites[1].flip_x

	U.animation_start(this, "start", target_flip, store.tick_ts, false)

	while not U.animation_finished(this) do
		if target.health.dead then
			goto label_223_0
		end

		coroutine.yield()
	end

	m.ts = store.tick_ts
	hit_ts = store.tick_ts

	U.animation_start(this, "loop", target_flip, store.tick_ts, true)

	while store.tick_ts - m.ts <= m.duration + 1e-09 do
		if this.interrupt or target.health.dead then
			break
		end

		if store.tick_ts - hit_ts >= this.damage_every then
			hit_ts = store.tick_ts

			local d = SU.create_attack_damage(this, target.id, this)

			queue_damage(store, d)
		end

		coroutine.yield()
	end

	::label_223_0::

	U.y_animation_play(this, "end", target_flip, store.tick_ts, false)
	queue_remove(store, this)
	signal.emit("mod-applied", this, target)
end

scripts.mod_ray_arcane = {}

function scripts.mod_ray_arcane.update(this, store)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local dps = this.dps
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)
		return
	end

	local function apply_damage(value)
		local d = E:create_entity("damage")
		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds
		queue_damage(store, d)
		total_damage = total_damage + value
	end

	local raw_damage = math.random(dps.damage_min, dps.damage_max) * m.damage_factor
	local extra_damage = math.max(0, raw_damage - target.health.hp)
	local total_cycles = m.duration / dps.damage_every
	local dps_damage = math.floor((raw_damage - extra_damage) / total_cycles)
	local first_damage = raw_damage - extra_damage - dps_damage * total_cycles

	this.pos = target.pos
	dps.ts = store.tick_ts
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if total_cycles <= cycles then
			log.paranoid(">>>>> id:%s - mod_ray_arcane cycles:%s raw_damage:%s dps_damage:%s first_damage:%s total_damage:%s", this.id, cycles, raw_damage, dps_damage, first_damage, total_damage)
			apply_damage(extra_damage)

			break
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.hit_offset.x, target.unit.hit_offset.y
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			apply_damage(dps_damage + (cycles == 1 and first_damage or 0))
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.mod_ray_arcane_disintegrate = {}

function scripts.mod_ray_arcane_disintegrate.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		return
	end

	this.pos = target.pos
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

        if store.tick_ts - m.ts >= m.duration then
            if band(target.vis.flags, F_BOSS) == 0 and band(target.vis.bans, F_INSTAKILL) == 0 then
                local d = E:create_entity("damage")
                d.source_id = this.id
                d.target_id = target.id
                d.damage_type = m.damage_type
                d.value = m.damage
                d.pop = m.pop
                d.pop_chance = m.pop_chance
                d.pop_conds = m.pop_conds
                queue_damage(store, d)
                break
            else
                local d = E:create_entity("damage")
                d.source_id = this.id
                d.target_id = target.id
                d.damage_type = bor(DAMAGE_TRUE)
                d.value = (100 + target.health.hp_max * 0.047) * m.damage_factor
                d.pop = m.pop
                d.pop_chance = m.pop_chance
                d.pop_conds = m.pop_conds
                queue_damage(store, d)
                break
            end
        end
        if this.render and m.use_mod_offset and target.unit.hit_offset then
            this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.hit_offset.x,
                target.unit.hit_offset.y
        end

        coroutine.yield()

	end

	queue_remove(store, this)
end

scripts.mod_rocketeer_speed_buff = {}

function scripts.mod_rocketeer_speed_buff.insert(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
	target._angles_walk = target.render.sprites[1].angles.walk
	target.already_speed_up = true
	target.render.sprites[1].angles.walk = this.walk_angles
    U.speed_mul(target, this.fast.factor)
	return true
end

function scripts.mod_rocketeer_speed_buff.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.render.sprites[1].angles.walk = target._angles_walk
		U.speed_div(target, this.fast.factor)

		return true
	end

	return false
end

scripts.mod_troll_rage = {}

function scripts.mod_troll_rage.insert(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
    U.speed_inc(target, this.extra_speed)

    if target.template_name ~= "enemy_troll_brute" and target.template_name ~= "enemy_troll_chieftain" then
        SU.armor_inc(target, this.extra_armor)
    end

	local ma = target.melee.attacks[1]

	if ma then
		ma.damage_min = ma.damage_min + this.extra_damage_min
		ma.damage_max = ma.damage_max + this.extra_damage_max
	end

	return true
end

function scripts.mod_troll_rage.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
        U.speed_dec(target, this.extra_speed)

        if target.template_name ~= "enemy_troll_brute" and target.template_name ~= "enemy_troll_chieftain" then
            SU.armor_dec(target, this.extra_armor)
        end

		local ma = target.melee.attacks[1]

		if ma then
			ma.damage_min = ma.damage_min - this.extra_damage_min
			ma.damage_max = ma.damage_max - this.extra_damage_max
		end
	end

	return true
end

scripts.mod_demon_shield = {}

function scripts.mod_demon_shield.insert(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
	target.health.on_damage = scripts.mod_demon_shield.on_damage
	this._hits = 0
	this._hit_sources = {}
	this._blood_color = target.unit.blood_color
	target.unit.blood_color = BLOOD_NONE
	target._shield_mod = this

	return true
end

function scripts.mod_demon_shield.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.health.on_damage = nil
		target._shield_mod = nil
		target.unit.blood_color = this._blood_color
	end

	return true
end

function scripts.mod_demon_shield.on_damage(this, store, damage)
	local mod = this._shield_mod

	if not mod then
		log.error("mod_demon_shield.on_damage for enemy %s has no mod pointer", this.id)

		return true
	end

	if U.flag_has(damage.damage_type, bor(DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE, DAMAGE_EAT, DAMAGE_IGNORE_SHIELD)) then
		queue_remove(store, mod)

		return true
	end

	if U.flag_has(damage.damage_type, DAMAGE_ONE_SHIELD_HIT) then
		if not mod._hit_sources[damage.source_id] then
			mod._hit_sources[damage.source_id] = true
			mod._hits = mod._hits + 1
		end
	elseif not U.flag_has(damage.damage_type, DAMAGE_NO_SHIELD_HIT) then
		mod._hits = mod._hits + 1
	end

	if mod._hits >= mod.shield_ignore_hits then
		queue_remove(store, mod)
	end

	return false
end

scripts.mod_giant_rat_poison = {}

function scripts.mod_giant_rat_poison.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or not scripts.mod_dps.insert(this, store) then
		return false
	end

	target.unit.damage_factor = target.unit.damage_factor * this.reduced_damage_factor

	return true
end

function scripts.mod_giant_rat_poison.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.unit then
		target.unit.damage_factor = target.unit.damage_factor / this.reduced_damage_factor
	end

	return true
end

scripts.mod_gerald_courage = {}

function scripts.mod_gerald_courage.insert(this, store)
	local m = this.modifier
	local buff = this.courage
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit then
		return false
	end

    local heal = (buff.heal_once_factor+m.level*buff.heal_inc) * target.health.hp_max

    if band(target.vis.flags, F_HERO) ~= 0 then
        SU.magic_armor_inc(target, buff.magic_armor_inc * m.level * 0.5)
        SU.armor_inc(target, buff.armor_inc * m.level * 0.5)
        target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp + heal * 0.5)
        SU.damage_inc(target, buff.damage_inc * m.level + buff.damage_inc_base)
    else
        SU.magic_armor_inc(target, buff.magic_armor_inc * m.level)
	    SU.armor_inc(target, buff.armor_inc * m.level)
        target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp + heal)
        SU.damage_inc(target, buff.damage_inc * m.level + buff.damage_inc_base)
    end

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end
		end
	end

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_gerald_courage.remove(this, store)
	local m = this.modifier
	local buff = this.courage
	local target = store.entities[this.modifier.target_id]

	if target then
        if band(target.vis.flags, F_HERO) ~= 0 then
            SU.magic_armor_dec(target, buff.magic_armor_inc * m.level * 0.5)
            SU.armor_dec(target, buff.armor_inc * m.level * 0.5)
            SU.damage_dec(target, buff.damage_inc * m.level + buff.damage_inc_base)
        else
            SU.magic_armor_dec(target, buff.magic_armor_inc * m.level)
		    SU.armor_dec(target, buff.armor_inc * m.level)
            SU.damage_dec(target, buff.damage_inc * m.level + buff.damage_inc_base)
        end
	end

	return true
end

scripts.mod_hero_thor_chainlightning = {}

function scripts.mod_hero_thor_chainlightning.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]
	local cl = this.chainlightning

	if target and target.health and not target.health.dead then
		local d = E:create_entity("damage")

		d.source_id = m.source_id
		d.target_id = m.target_id
		d.damage_type = cl.damage_type
		d.value = cl.damage

		queue_damage(store, d)

		local mod = E:create_entity(cl.mod)

		mod.modifier.ts = store.tick_ts
		mod.modifier.source_id = m.source_id
		mod.modifier.target_id = target.id

		queue_insert(store, mod)
	end

	U.y_wait(store, cl.chain_delay)

	local chain_pos = V.vclone(source.pos)
	local af = source.render.sprites[1].flip_x

	chain_pos.x = chain_pos.x + cl.offset.x * (af and -1 or 1)
	chain_pos.y = chain_pos.y + cl.offset.y

	local targets = U.find_enemies_in_range(store.enemies, chain_pos, cl.min_range, cl.max_range, cl.vis_flags or 0, cl.vis_bans or 0)

	if targets then
        -- local last_num = 0
        for i = 1, cl.count do
            local num = math.random(1, #targets)
            local t = targets[num]
            local dest = V.vclone(t.pos)
            local b = E:create_entity(cl.bullet)

            b.pos = V.vclone(chain_pos)
            b.bullet.from = V.vclone(b.pos)
            b.bullet.to = dest
            b.bullet.target_id = t.id
            b.bullet.source_id = m.source_id
            b.bullet.level = m.level
            -- if last_num == num then
                -- b.bullet.damage_factor = b.bullet.damage_factor * 0.5
            -- end
            -- last_num = num
            queue_insert(store, b)
        end
		-- local random_targets = table.random_order(targets)
		-- local count = 0

		-- for _, t in pairs(random_targets) do

		-- 	if count >= cl.count then
		-- 		break
		-- 	end

		-- 	local dest = V.vclone(t.pos)
		-- 	local b = E:create_entity(cl.bullet)

		-- 	b.pos = V.vclone(chain_pos)
		-- 	b.bullet.from = V.vclone(b.pos)
		-- 	b.bullet.to = dest
		-- 	b.bullet.target_id = t.id
		-- 	b.bullet.source_id = m.source_id
		-- 	b.bullet.level = m.level

		-- 	queue_insert(store, b)

		-- 	count = count + 1
		-- end
	end

	queue_remove(store, this)
end

scripts.mod_hero_thor_thunderclap = {}

function scripts.mod_hero_thor_thunderclap.update(this, store)
	local tc = this.thunderclap
	local m = this.modifier
	local target = store.entities[m.target_id]
	local mods = {
		tc.mod_stun,
		tc.mod_fx
	}

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = V.vclone(target.pos)

	if target.health and not target.health.dead then
		local d = E:create_entity("damage")

		d.source_id = m.source_id
		d.target_id = m.target_id
		d.damage_type = tc.damage_type
		d.value = tc.damage

		queue_damage(store, d)

		local mod = E:create_entity(tc.mod_stun)

		mod.modifier.ts = store.tick_ts
		mod.modifier.source_id = m.source_id
		mod.modifier.target_id = m.target_id

		queue_insert(store, mod)
	end

	S:queue(tc.sound)
	U.y_wait(store, tc.explosion_delay)

	local targets = U.find_enemies_in_range(store.enemies, target.pos, 0, tc.max_range, tc.vis_flags or 0, tc.vis_bans or 0, function(e)
		return e.id ~= m.target_id and e.health and not e.health.dead
	end)

	if targets then
		for _, t in ipairs(targets) do
			d = E:create_entity("damage")
			d.damage_type = tc.secondary_damage_type
			d.value = tc.secondary_damage
			d.source_id = m.source_id
			d.target_id = t.id

			queue_damage(store, d)

			for _, tm in ipairs(mods) do
				local mod = E:create_entity(tm)

				mod.modifier.ts = store.tick_ts
				mod.modifier.source_id = m.source_id

				if mod == tc.mod_stun then
					mod.modifier.duration = U.frandom(tc.stun_duration_min, tc.stun_duration_max)
				end

				mod.modifier.target_id = t.id
				mod.modifier.level = m.level

				queue_insert(store, mod)
			end
		end
	end

	local fx = E:create_entity(tc.fx)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	U.y_wait(store, fts(24))
	queue_remove(store, this)
end

scripts.mod_witch_frog = {}

function scripts.mod_witch_frog.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[1].z = target.render.sprites[1].z
	this.pos = target.pos

	return true
end

function scripts.mod_witch_frog.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		queue_remove(store, this)

		return
	end

	local damage_type = target.hero and m.hero_damage_type or m.damage_type

	if band(target.health.immune_to, damage_type) ~= 0 then
		queue_remove(store, this)

		return
	end

	local d = E:create_entity("damage")

	d.damage_type = target.hero and m.hero_damage_type or m.damage_type
	d.value = math.random(m.damage_min, m.damage_max)
	d.source_id = m.source_id
	d.target_id = target.id

	queue_damage(store, d)

	if target.hero then
		queue_remove(store, this)

		return
	end

	U.y_wait(store, this.frog_delay)

	local af = target.render.sprites[1].flip_x
	local t = this.tween
	local t_end = t.props[1].keys[2]

	this.render.sprites[1].flip_x = af
	this.render.sprites[1].hidden = false

	U.y_wait(store, this.fx_delay + this.animation_delay - this.frog_delay)
	U.animation_start(this, "jump", nil, store.tick_ts, true)

	t_end[2].x = t_end[2].x * (af and -1 or 1)
	t.disabled = false
	t.ts = store.tick_ts

	U.y_wait(store, t_end[1])
	U.y_animation_wait(this)
	U.animation_start(this, "idle", nil, store.tick_ts, true)
	U.y_wait(store, this.animation_delay)
	U.y_animation_play(this, "puff", nil, store.tick_ts, 1)
	queue_remove(store, this)
end

scripts.mod_spectral_knight = {}

function scripts.mod_spectral_knight.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	for _, s in pairs(this.render.sprites) do
		s.ts = store.tick_ts
	end

	this.pos = target.pos
	m.ts = store.tick_ts
	target.unit.damage_factor = target.unit.damage_factor * this.damage_factor_increase

	return true
end

function scripts.mod_spectral_knight.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.unit.damage_factor = target.unit.damage_factor / this.damage_factor_increase
	end

	return true
end

scripts.mod_skeleton_big = {}
function scripts.mod_skeleton_big.insert(this, store)
    local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	for _, s in pairs(this.render.sprites) do
		s.ts = store.tick_ts
	end

	this.pos = target.pos
	m.ts = store.tick_ts
	target.health.damage_factor = target.health.damage_factor - this.health_damage_factor_dec

	return true
end
function scripts.mod_skeleton_big.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.health.damage_factor = target.health.damage_factor + this.health_damage_factor_dec
	end

	return true
end

scripts.mod_gulaemon_fly = {}

function scripts.mod_gulaemon_fly.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) queue/insertion", this.template_name, this.id)

        U.speed_mul(target, this.speed_factor)
	else
		log.debug("%s (%s) queue/removal", this.template_name, this.id)
        U.speed_div(target, this.speed_factor)
	end
end

function scripts.mod_gulaemon_fly.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) dequeue/insertion", this.template_name, this.id)
        U.speed_div(target, this.speed_factor)
	end
end

function scripts.mod_gulaemon_fly.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts

	return true
end

function scripts.mod_gulaemon_fly.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target._should_land = true
	end

	return true
end

function scripts.mod_gulaemon_fly.update(this, store)
	local target
	local m = this.modifier

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or store.tick_ts - m.ts > m.duration or P:nodes_to_defend_point(target.nav_path) < this.nodes_limit then
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.decal_sheep_big = {}

function scripts.decal_sheep_big.insert(this, store)
	if math.random() < this.delayed_play.required_clicks_fx_alt_chance then
		local d = this.delayed_play

		d.required_clicks_fx = d.required_clicks_fx_alt
		d.clicked_sound = d.clicked_sound_alt
	end

	return true
end

scripts.decal_fish = {}

function scripts.decal_fish.update(this, store, script)
	while true do
		this.render.sprites[1].hidden = true

		U.y_wait(store, math.random(5, 10))

		this.render.sprites[1].hidden = false

		U.animation_start(this, "jump", nil, store.tick_ts, false)

		this.ui.clicked = nil

		while not U.animation_finished(this) do
			if this.ui.clicked then
				AC:got(this.achievement_id)

				this.ui.clicked = nil
			end

			coroutine.yield()
		end
	end
end

scripts.graveyard_controller = {}

function scripts.graveyard_controller.update(this, store)
	local g = this.graveyard

	while not this.interrupt do
		local targets = table.filter(store.entities, function(k, v)
			return not v._in_graveyard and v.health and v.health.dead and band(v.vis.flags, g.vis_has) ~= 0 and band(v.vis.flags, g.vis_bans) == 0 and band(v.vis.bans, g.vis_flags) == 0 and store.tick_ts - v.health.death_ts >= g.dead_time and (not v.reinforcement or not v.reinforcement.hp_before_timeout) and (not g.excluded_templates or not table.contains(g.excluded_templates, v.template_name))
		end)

		if #targets == 0 then
			U.y_wait(store, g.check_interval)
		else
			for _, t in ipairs(targets) do
				if this.interrupt then
					return
				end

				t._in_graveyard = true

				for _, s in ipairs(g.spawns_by_health) do
					local e, s_pos, pi, spi, ni

					if t.health.hp_max > s[2] then
						-- block empty
					else
						s_pos = table.random(g.spawn_pos)

						local nearest_nodes = P:nearest_nodes(s_pos.x, s_pos.y, g.pi and {
							g.pi
						} or nil)

						if #nearest_nodes < 1 then
							log.error("graveyard controller %s could not spawn enemy. node not found near %s,%s", this.id, s_pos.x, s_pos.y)
						else
							pi, spi, ni = unpack(nearest_nodes[1])
							e = E:create_entity(s[1])
							e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, math.random(1, 3), ni
							e.pos = V.vclone(s_pos)
							e.render.sprites[1].name = "raise"
							e.motion.forced_waypoint = P:node_pos(e.nav_path)

							if not g.keep_gold and e.enemy then
								e.enemy.gold = 0
							end

							queue_insert(store, e)

							break
						end
					end
				end

				U.y_wait(store, g.spawn_interval)
			end
		end
	end

	queue_remove(store, this)
end

scripts.s11_lava_spawner = {}

function scripts.s11_lava_spawner.update(this, store)
	local cooldown = this.cooldown

	while store.wave_group_number < 1 do
		coroutine.yield()
	end

	while true do
		U.y_wait(store, cooldown)
		S:queue(this.sound)

		local e = E:create_entity(this.entity)

		e.pos = V.vclone(this.pos)
		e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = this.pi, 1, 1
		e.render.sprites[1].name = "raise"

		queue_insert(store, e)

		cooldown = this.cooldown_after

		if not U.is_seen(store, this.entity) then
			signal.emit("wave-notification", "icon", this.entity)
			U.mark_seen(store, this.entity)
		end
	end
end

scripts.decal_fredo = {}

function scripts.decal_fredo.update(this, store, script)
	local clicks = 0
	local s = this.render.sprites[1]

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1

			U.animation_start(this, "clicked", nil, store.tick_ts, false)
		end

		if clicks >= 8 then
			this.ui.can_click = false

			U.animation_start(this, "release", nil, store.tick_ts, false)
			U.y_animation_wait(this)
			AC:got("FREE_FREDO")
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.enemy_base_portal = {}

function scripts.enemy_base_portal.insert(this, store)
	if not scripts.enemy_basic.insert(this, store) then
		return false
	end

	local portal_templates = {
		"decal_demon_portal_big",
		"decal_inferno_portal",
		"decal_inferno_ground_portal",
		"veznan_portal"
	}
	local portal = table.filter(store.entities, function(_, e)
		return table.contains(portal_templates, e.template_name) and e.out_nodes and e.out_nodes[this.nav_path.pi]
	end)[1]

	if portal and portal.out_nodes[this.nav_path.pi] - this.nav_path.ni < 8 then
		local fx = E:create_entity(portal.fx_out)

		fx.pos = V.vclone(this.pos)
		fx.render.sprites[1].ts = store.tick_ts

		if this.unit and this.unit.mod_offset then
			fx.pos.x, fx.pos.y = fx.pos.x + this.unit.mod_offset.x, fx.pos.y + this.unit.mod_offset.y
		end

		queue_insert(store, fx)
	end

	if this.render.sprites[1].name == "raise" and this.template_name == "enemy_demon_legion" then
		this._raise_vis_bans = this.vis.bans
		this._raise_ignore_damage = this.health.ignore_damage
		this.vis.bans = bor(F_ALL)
		this.health.ignore_damage = true
		this.health_bar.hidden = true
	end

	return true
end

scripts.decal_demon_portal_big = {}

function scripts.decal_demon_portal_big.update(this, store)
	local function has_enemies_in_paths(group)
		if group and group.waves then
			for _, w in pairs(group.waves) do
				if w.path_index and this.out_nodes[w.path_index] then
					return true
				end
			end
		end

		return false
	end

	while true do
		while not has_enemies_in_paths(store.current_wave_group) and not has_enemies_in_paths(store.next_wave_group_ready) do
			coroutine.yield()
		end

		this.tween.ts = store.tick_ts
		this.tween.reverse = false

		::label_261_0::

		local current_wave = store.wave_group_number

		while current_wave == store.wave_group_number and not store.waves_finished do
			coroutine.yield()
		end

		if has_enemies_in_paths(store.current_wave_group) then
			goto label_261_0
		end

		this.tween.ts = store.tick_ts
		this.tween.reverse = true
	end
end

scripts.s15_rotten_spawner = {}

function scripts.s15_rotten_spawner.update(this, store)
	local cooldown, max_count, ts, last_wave

	while true do
		::label_263_0::

		while (not max_count or max_count == 0) and store.wave_group_number == last_wave do
			coroutine.yield()
		end

		if this.interrupt then
			break
		end

		if store.wave_group_number ~= last_wave then
			local wave_timers = this.spawn_timers[store.wave_group_number]

			cooldown, max_count = unpack(wave_timers or {
				cooldown,
				max_count
			})
			last_wave = store.wave_group_number
			ts = store.tick_ts
		end

		if not max_count or max_count == 0 then
			goto label_263_0
		end

		if cooldown < store.tick_ts - ts and max_count > 0 then
			for i = 1, max_count do
				do
					local e = E:create_entity(this.entity)
					local pos, pi, spi, ni = P:get_random_position(this.spawn_margin, bor(TERRAIN_LAND), nil, true)

					if not pos then
						local valid_nodes = P:get_valid_nodes(1)

						pi, spi, ni = math.random(1, 3), math.random(1, 3), math.random(30, P:get_defend_point_node(1) - 60)

						if not P:is_node_valid(pi, ni) then
							log.debug("s15_rotten_spawner: could not find random node")

							goto label_263_1
						end

						pos = P:node_pos(pi, spi, ni)
					end

					e.pos, e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pos, pi, spi, ni
					e.render.sprites[1].name = "raise"
					e.enemy.gold = 0

					queue_insert(store, e)
				end

				::label_263_1::
			end

			ts = store.tick_ts
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_s17_barricade = {}

function scripts.decal_s17_barricade.update(this, store, script)
	local boss

	while not boss do
		boss = LU.list_entities(store.enemies, this.boss_name)[1]

		if not boss then
			U.y_wait(store, 5)
		end
	end

	while boss and boss.nav_path and boss.nav_path.ni < this.destroy_node do
		coroutine.yield()
	end

	U.animation_start(this, "destroy", nil, store.tick_ts, false)
end

scripts.decal_scrat = {}

function scripts.decal_scrat.update(this, store, script)
	local clicks = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil

			local fx = E:create_entity(this.touch_fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			clicks = clicks + 1

			if clicks >= 10 then
				break
			end
		end

		coroutine.yield()
	end

	this.ui.can_click = false

	U.animation_start(this, "play", nil, store.tick_ts, false)
	U.y_animation_wait(this)

	this.render.sprites[1].hidden = true

	U.animation_start(this, "end", nil, store.tick_ts, false, 2)
	AC:got("DEFEAT_ACORN")
end

scripts.burning_floor_controller = {}

function scripts.burning_floor_controller.update(this, store, script)
	local auras = LU.list_entities(store.auras, "aura_burning_floor")
	local data = this.cooldowns[store.level_mode]
	local wdata, current_wave

	local function wave_changed()
		return current_wave ~= store.wave_group_number or store.waves_finished
	end

	if not auras or not data then
		-- block empty
	else
		while true do
			repeat
				coroutine.yield()

				wdata = data[store.wave_group_number]
			until wdata

			current_wave = store.wave_group_number

			local delay, duration = unpack(wdata)

			if U.y_wait(store, delay, wave_changed) then
				-- block empty
			else
				for _, a in pairs(auras) do
					a.aura.active = true
				end

				U.y_wait(store, duration, wave_changed)

				for _, a in pairs(auras) do
					a.aura.active = false
				end

				while not wave_changed() do
					coroutine.yield()
				end
			end
		end
	end

	if not auras then
		log.error("no aura_burning_floor entities available in this level, removing controller")
	elseif not data then
		log.error("no cooldowns table defined, removing controller")
	end

	queue_remove(store, this)
end

scripts.aura_burning_floor = {}

function scripts.aura_burning_floor.update(this, store, script)
	local a = this.aura

	while true do
		while not a.active do
			coroutine.yield()
		end

		this.tween.reverse = false
		this.tween.ts = store.tick_ts

		while not U.y_wait(store, a.cycle_time, function()
			return not a.active
		end) do
			local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

			if targets then
				for _, target in pairs(targets) do
					local m = E:create_entity(this.aura.mod)

					m.modifier.target_id = target.id
					m.modifier.source_id = this.id

					queue_insert(store, m)
				end
			end
		end

		this.tween.reverse = true
		this.tween.ts = store.tick_ts
	end
end

scripts.decal_s23_splinter_pizza = {}

function scripts.decal_s23_splinter_pizza.update(this, store, script)
	while not this.ui.clicked do
		coroutine.yield()
	end

	this.ui.clicked = nil

	U.animation_start(this, "clicked", nil, store.tick_ts, false)
	U.y_animation_wait(this)
	AC:got("SPLINTER")

	this.render.sprites[1].prefix = "decal_s23_splinter"

	return scripts.click_play.update(this, store, script)
end

scripts.decal_bat_flying = {}

function scripts.decal_bat_flying.insert(this, store, script)
	if this.snapping then
		local v_left = store.visible_coords.left
		local v_right = store.visible_coords.right
		local positions = {
			["top left"] = V.v(v_left, 0),
			top = V.v(0, 0),
			["top right"] = V.v(v_right - REF_W, 0),
			["bottom right"] = V.v(v_right - REF_W, 0),
			bottom = V.v(0, 0),
			["bottom left"] = V.v(v_left, 0)
		}

		this.pos = positions[this.snapping]
	end

	return true
end

scripts.decal_s24_nevermore = {}

function scripts.decal_s24_nevermore.update(this, store, script)
	while not this.ui.clicked do
		coroutine.yield()
	end

	this.ui.clicked = nil

	U.animation_start(this, "clicked", nil, store.tick_ts, false)
	U.y_animation_wait(this)
	U.animation_start(this, "fly", nil, store.tick_ts, true)

	this.tween.reverse = false
	this.tween.ts = store.tick_ts

	U.y_wait(store, this.leave_time)
	AC:got("NEVERMORE")
	queue_remove(store, this)
end

scripts.decal_s25_nessie = {}

function scripts.decal_s25_nessie.update(this, store, script)
	local pause_min, pause_max = unpack(this.pause_duration)
	local animation_min, animation_max = unpack(this.animation_duration)
	local pause_ts = 0
	local animation_ts = 0
	local current_pause, current_animation

	while true do
		::label_273_0::

		U.sprites_hide(this)

		this.ui.can_click = false
		pause_ts = store.tick_ts
		current_pause = U.frandom(pause_min, pause_max)

		while current_pause > store.tick_ts - pause_ts do
			coroutine.yield()
		end

		this.pos = this.out_pos[math.random(1, #this.out_pos)]

		U.sprites_show(this)

		this.ui.can_click = true

		U.animation_start(this, "bubble_in", nil, store.tick_ts, false)
		U.y_animation_wait(this)

		while this.render.sprites[1].runs < 1 do
			if this.ui.clicked then
				goto label_273_1
			end

			coroutine.yield()
		end

		animation_ts = U.frandom(animation_min, animation_max)

		U.animation_start(this, "bubble_play", nil, store.tick_ts, true)

		while animation_ts > this.render.sprites[1].runs * fts(22) do
			if this.ui.clicked then
				goto label_273_1
			end

			coroutine.yield()
		end

		U.sprites_hide(this)

		this.ui.can_click = false

		U.animation_start(this, "bubble_out", nil, store.tick_ts, false)
		U.y_animation_wait(this)

		goto label_273_0

		::label_273_1::

		this.ui.clicked = nil

		S:queue(this.sound)
		U.animation_start(this, "clicked", nil, store.tick_ts, false)
		U.y_wait(store, fts(90))
		S:queue(this.sound)
		U.y_animation_wait(this)
		AC:got("NESSIE")
		U.sprites_hide(this)
		coroutine.yield()
	end
end

scripts.enemy_tremor = {}

function scripts.enemy_tremor.update(this, store, script)
    local burrowed = true

    ::label_6_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            U.cleanup_blockers(store, this)

            if not burrowed and not U.get_blocker(store, this) then
                this.vis.bans = this.vis.bans_below_surface

                SU.remove_modifiers(store, this)
                U.animation_start(this, "burrow", nil, store.tick_ts, 1)

                while not U.animation_finished(this) do
                    coroutine.yield()
                end

                burrowed = true
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not cont then
                -- block empty
            else
                if blocker then
                    if burrowed then
                        local an, af = U.animation_name_facing_point(this, "raise", blocker.pos)

                        U.animation_start(this, an, af, store.tick_ts, 1)

                        while not U.animation_finished(this) do
                            coroutine.yield()
                        end

                        this.vis.bans = this.vis.bans_above_surface
                        burrowed = false
                    end

                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_6_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_6_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_munra = {}

function scripts.enemy_munra.update(this, store, script)
    local sa = this.timed_attacks.list[1]
    local ha = this.timed_attacks.list[2]
    local ok, blocker, ranged, heal_targets
    local cg = store.count_groups[sa.count_group_type]

    sa.ts = store.tick_ts
    ha.ts = store.tick_ts

    local function ready_to_sarcophagus()
        return enemy_ready_to_magic_attack(this, store, sa) and not this.health.dead and
                   this.nav_path.ni < P:get_defend_point_node(this.nav_path.pi) and
                   (not cg[sa.count_group_name] or cg[sa.count_group_name] < sa.count_group_max)
    end

    local function ready_to_heal()
        if not enemy_ready_to_magic_attack(this, store, ha) or this.health.dead then
            return false
        end

        local targets = table.filter(store.enemies, function(k, v)
            return v.enemy.can_accept_magic and v.id ~= this.id and  not v.health.dead and
                       v.health.hp < v.health.hp_max and U.is_inside_ellipse(v.pos, this.pos, ha.range)
        end)

        if #targets > 0 then
            return true, targets
        else
            return false
        end
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            if not this.did_sarcophagus then
                AC:got("MUMMYATTHEGATES")
            end

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
        else
            if ready_to_sarcophagus() then
                local pi, spi, ni = this.nav_path.pi, this.nav_path.spi, this.nav_path.ni
                local path = P:path(pi, 1)

                ni = km.clamp(1, P:get_defend_point_node(pi) - sa.nodes_limit,
                    ni + math.random(sa.node_random_min, sa.node_random_max))

                if not P:is_node_valid(pi, ni) then
                    log.debug("munra %s - cannot summon sarcophagus: node %i,%i is not valid", this.id, pi, ni)

                    sa.ts = sa.ts + 1
                else
                    local npos = P:node_pos(pi, 2, ni)

                    sa.ts = store.tick_ts

                    S:queue(sa.sound)
                    U.animation_start(this, sa.animation, nil, store.tick_ts, 1)

                    while store.tick_ts - sa.ts < sa.spawn_time do
                        if this.health.dead then
                            goto label_7_0
                        end

                        coroutine.yield()
                    end

                    local spawn = E:create_entity(sa.entity)

                    spawn.pos.x, spawn.pos.y = npos.x, npos.y
                    spawn.spawner.pi = pi
                    spawn.spawner.ni = ni
                    spawn.spawner.count_group_name = sa.count_group_name
                    spawn.spawner.count_group_type = sa.count_group_type
                    spawn.spawner.count_group_max = sa.count_group_max

                    queue_insert(store, spawn)

                    this.did_sarcophagus = true

                    while not U.animation_finished(this) do
                        if this.health.dead then
                            goto label_7_0
                        end

                        coroutine.yield()
                    end
                end
            end

            ok, heal_targets = ready_to_heal()

            if heal_targets then
                ha.ts = store.tick_ts

                S:queue(ha.sound)
                U.animation_start(this, ha.animation, nil, store.tick_ts, 1)

                while store.tick_ts - ha.ts < ha.shoot_time do
                    if this.health.dead then
                        goto label_7_0
                    end

                    coroutine.yield()
                end

                for i, target in ipairs(heal_targets) do
                    if i > ha.max_per_cast then
                        break
                    end

                    local new_mod = E:create_entity(ha.mod)

                    new_mod.modifier.target_id = target.id
                    new_mod.modifier.source_id = this.id

                    queue_insert(store, new_mod)
                end

                while not U.animation_finished(this) do
                    if this.health.dead then
                        goto label_7_0
                    end

                    coroutine.yield()
                end
            end

            ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_sarcophagus() or ready_to_heal()
            end)

            if not ok then
                -- block empty
            elseif blocker then
                if not SU.y_wait_for_blocker(store, this, blocker) then
                    -- block empty
                else
                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_heal() do
                        sa.ts = store.tick_ts

                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            break
                        end

                        coroutine.yield()
                    end
                end
            elseif ranged then
                while SU.can_range_soldier(store, this, ranged) and not ready_to_heal() and #this.enemy.blockers == 0 do
                    if not SU.y_enemy_range_attacks(store, this, ranged) then
                        break
                    end

                    coroutine.yield()
                end
            end
        end

        ::label_7_0::

        coroutine.yield()
    end
end

scripts.enemy_cannibal = {}

function scripts.enemy_cannibal.update(this, store, script)
    local terrain_type

    this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))

    if this.render.sprites[1].name == "raise" then
        if this.sound_events and this.sound_events.raise then
            S:queue(this.sound_events.raise)
        end

        this.health_bar.hidden = true

        U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

        if not this.health.dead then
            this.health_bar.hidden = nil
        end
    end

    local water_trail = E:create_entity("ps_water_trail")

    water_trail.particle_system.track_id = this.id

    queue_insert(store, water_trail)

    ::label_12_0::

    while true do
        if this.water then
            terrain_type = SU.enemy_water_change(store, this)
        end

        if this.health.dead then
            SU.y_enemy_death(store, this)

            water_trail.particle_system.emit = false

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local in_water = terrain_type == TERRAIN_WATER

            water_trail.particle_system.emit = in_water

            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, in_water)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_12_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_12_0
                        end

                        coroutine.yield()
                    end
                end

                if blocker and blocker.health.dead and not in_water and
                    band(blocker.health.last_damage_types,
                        bor(DAMAGE_DISINTEGRATE, DAMAGE_HOST, DAMAGE_EAT)) == 0 then
                    local target = blocker

                    if band(target.vis.bans, F_CANNIBALIZE) ~= 0 then
                        coroutine.yield()

                        goto label_12_0
                    end

                    U.unblock_all(store, this)

                    this.vis.bans = bor(this.vis.bans, F_BLOCK)
                    this.motion.forced_waypoint = V.v(target.pos.x, target.pos.y)

                    while SU.y_enemy_walk_step(store, this) do
                        if this.health.dead then
                            goto label_12_0
                        end

                        if not store.entities[target.id] then
                            goto label_12_1
                        end
                    end

                    this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))

                    U.animation_start(this, "cannibalize", nil, store.tick_ts, false)
                    S:queue(this.sound_events.cannibalize)

                    if this.health.hp_max < this.cannibalize.max_hp then
                        this.health.hp_max = this.health.hp_max + this.cannibalize.extra_hp
                    end

                    while not U.animation_finished(this) do
                        if not store.entities[target.id] then
                            break
                        end

                        this.health.hp = km.clamp(0, this.health.hp_max,
                            this.health.hp + math.ceil(this.cannibalize.hps * store.tick_length))

                        coroutine.yield()
                    end

                    ::label_12_1::

                    this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))
                    this.motion.forced_waypoint = nil

                    local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {this.nav_path.pi}, {this.nav_path.spi})

                    if nearest and nearest[1] and nearest[1][3] > this.nav_path.ni then
                        this.nav_path.ni = nearest[1][3]
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_hunter = {}

function scripts.enemy_hunter.insert(this, store, script)
    if not scripts.enemy_basic.insert(this, store, script) then
        return false
    end

    this.ranged.attacks[1].max_range = this.ranged.attacks[1].max_range + math.random(-70, 30) / 2

    return true
end

scripts.alien_egg = {}

function scripts.alien_egg.update(this, store, script)
    local sp = this.spawner
    local s = this.render.sprites[1]
    local last_subpath = 0

    while true do
        if this.do_destroy then
            S:queue(this.sound_events.destroy)
            U.y_animation_play(this, "destroy", nil, store.tick_ts)

            return
        end

        if this.do_spawn then
            this.do_spawn = nil

            if sp.interrupt then
                goto label_16_1
            end

            S:queue(this.sound_events.open)
            U.y_animation_play(this, "open", nil, store.tick_ts)

            for i = 1, sp.count do
                if sp.interrupt then
                    break
                end

                if this.do_destroy then
                    goto label_16_1
                end

                local spawn = E:create_entity(sp.entity)

                spawn.nav_path.pi = sp.pi

                if sp.random_subpath then
                    spawn.nav_path.spi = sp.allowed_subpaths[math.random(1, #sp.allowed_subpaths)]
                else
                    last_subpath = km.zmod(last_subpath + 1, #sp.allowed_subpaths)
                    spawn.nav_path.spi = sp.allowed_subpaths[last_subpath]
                end

                spawn.nav_path.ni = sp.ni + sp.node_offset
                spawn.pos.x, spawn.pos.y = this.pos.x, this.pos.y + sp.pos_offset.y

                if sp.forced_waypoint_offset then
                    spawn.motion.forced_waypoint = V.v(this.pos.x + sp.forced_waypoint_offset.x,
                        this.pos.y + sp.forced_waypoint_offset.y)
                end

                spawn.render.sprites[1].name = "idle"
                spawn.unit.spawner_id = this.id

                queue_insert(store, spawn)

                local spawn_ts = store.tick_ts

                while store.tick_ts - spawn_ts < sp.cycle_time do
                    if sp.interrupt then
                        goto label_16_0
                    end

                    coroutine.yield()
                end
            end

            ::label_16_0::

            U.y_wait(store, 1)
            U.y_animation_play(this, "close", nil, store.tick_ts)
        end

        coroutine.yield()

        ::label_16_1::

        sp.interrupt = nil
    end
end

scripts.enemy_alien_breeder = {}

function scripts.enemy_alien_breeder.get_info(this)
    local min, max = 10, 20

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.enemy_alien_breeder.insert(this, store, script)
    if not scripts.enemy_basic.insert(this, store, script) then
        return false
    end

    signal.emit("wave-notification", "icon", "enemy_alien_breeder")

    return true
end

function scripts.enemy_alien_breeder.update(this, store, script)
    local hugging = false
    local dead_when_hugging = false

    ::label_19_0::

    while true do
        if this.health.dead then
            if dead_when_hugging then
                this.unit.death_animation = "death_hugging"
            end

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_19_0
                    end

                    this.vis.bans = bor(this.vis.bans, F_TWISTER, F_BLOCK)

                    SU.stun_inc(blocker)

                    this.health_bar.hidden = true
                    hugging = true

                    local damage_value = blocker.health.hp / (blocker.hero and 5 or 2.5)

                    damage_value = km.clamp(1, blocker.health.hp_max, damage_value)

                    local fh_offset = this.facehug_offsets[blocker.template_name]

                    if not fh_offset and blocker.hero then
                        fh_offset = this.facehug_offsets.hero_default
                    end

                    fh_offset = fh_offset or this.facehug_offsets.soldier_default

                    local x_offset = (fh_offset.x + 3) * (this.pos.x < blocker.pos.x and -1 or 1)
                    local y_offset = 3 + fh_offset.y
                    local dest = V.v(blocker.pos.x, blocker.pos.y - 1)
                    local dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
                    local eta = dist / this.motion.real_speed

                    this.tween.props[1].keys = {{0, V.v(0, 0)}, {eta, V.v(x_offset, y_offset)}}
                    this.tween.disabled = false

                    U.set_destination(this, dest)
                    U.animation_start(this, "jump", nil, store.tick_ts)

                    while not this.motion.arrived do
                        if this.health.dead then
                            SU.stun_dec(blocker)

                            goto label_19_0
                        end

                        U.walk(this, store.tick_length)
                        coroutine.yield()
                    end

                    this.tween.disabled = true

                    U.animation_start(this, "face_hug", nil, store.tick_ts, true)

                    while not blocker.health.dead do
                        if this.health.dead then
                            SU.stun_dec(blocker)

                            dead_when_hugging = true

                            goto label_19_0
                        end

                        local d = E:create_entity("damage")

                        d.value = damage_value
                        d.source_id = this.id
                        d.target_id = blocker.id
                        d.damage_type = bor(DAMAGE_HOST, DAMAGE_TRUE)
                        d.track_kills = this.track_kills ~= nil

                        queue_damage(store, d)

                        local ts = store.tick_ts

                        while store.tick_ts - ts < 1 and not blocker.health.dead and not this.health.dead do
                            coroutine.yield()
                        end
                    end

                    SU.stun_dec(blocker)

                    if #this.track_kills.killed > 0 and this.track_kills.killed[1] == blocker.id then
                        queue_remove(store, this)

                        if not table.contains(this.spawn_bans, blocker.template_name) then
                            signal.emit("wave-notification", "icon", "enemy_alien_reaper")

                            local e = E:create_entity("enemy_alien_reaper")

                            e.nav_path.pi, e.nav_path.spi = this.nav_path.pi, this.nav_path.spi
                            e.nav_path.ni = this.nav_path.ni + 2
                            e.render.sprites[1].flip_x = this.render.sprites[1].flip_x
                            e.enemy.gold = 0

                            queue_insert(store, e)
                        end

                        return
                    end

                    this.vis.bans = band(this.vis.bans, bnot(F_TWISTER))
                    this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))
                    this.health_bar.hidden = true
                    hugging = false
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_shaman_necro = {}

function scripts.enemy_shaman_necro.update(this, store, script)
    local na = this.timed_attacks.list[1]
    local ok, blocker, ranged

    na.ts = store.tick_ts

    local function ready_to_cast()
        return enemy_ready_to_magic_attack(this, store, na)
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
        else
            if ready_to_cast() then
                na.ts = store.tick_ts

                local dead_enemies = table.filter(store.enemies, function(_, e)
                    return e.health.dead and e.unit and not e.unit.hide_after_death and
                               band(e.health.last_damage_types, bor(DAMAGE_EAT, DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE,
                            DAMAGE_EXPLOSION, DAMAGE_FX_EXPLODE)) == 0 and band(e.vis.bans, F_UNDEAD) == 0 and
                               table.contains(na.allowed_templates, e.template_name) and
                               U.is_inside_ellipse(e.pos, this.pos, na.max_range)
                end)

                if #dead_enemies == 0 then
                    -- block empty
                else
                    for _, dead in pairs(dead_enemies) do
                        dead.vis.bans = bor(dead.vis.bans, F_UNDEAD)
                    end

                    S:queue("EnemyHealing", {
                        delay = fts(9)
                    })
                    U.animation_start(this, na.animation, nil, store.tick_ts, false)

                    while store.tick_ts - na.ts < na.cast_time do
                        if this.health.dead then
                            goto label_20_0
                        end

                        coroutine.yield()
                    end

                    S:queue(na.sound)

                    for _, dead in pairs(dead_enemies) do
                        dead.health.delete_after = 0

                        local e = E:create_entity("enemy_cannibal_zombie")

                        e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = dead.nav_path.pi, dead.nav_path.spi,
                            dead.nav_path.ni
                        e.render.sprites[1].name = "raise"
                        e.render.sprites[1].flip_x = dead.render.sprites[1].flip_x

                        queue_insert(store, e)
                    end

                    U.y_animation_wait(this)
                end
            end

            ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_cast()
            end)

            if not ok then
                -- block empty
            elseif blocker then
                if not SU.y_wait_for_blocker(store, this, blocker) then
                    -- block empty
                else
                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            break
                        end

                        coroutine.yield()
                    end
                end
            elseif ranged then
                while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and not ready_to_cast() do
                    if not SU.y_enemy_range_attacks(store, this, ranged) then
                        break
                    end

                    coroutine.yield()
                end
            end
        end

        ::label_20_0::

        coroutine.yield()
    end
end

scripts.enemy_cannibal_volcano = {}

function scripts.enemy_cannibal_volcano.update(this, store, script)
    local ok, blocker, ranged, action
    local cheer_count = 0
    local action_nodes = {
        [56] = "throw",
        [5] = "cheer",
        [43] = "cheer",
        [28] = "cheer"
    }

    local function ready_for_action()
        return action_nodes[this.nav_path.ni]
    end

    local function show_help_banner()
        local help = E:create_entity("fx")

        help.render.sprites[1].name = "volcano_help_banner"
        help.render.sprites[1].ts = store.tick_ts
        help.pos = V.v(this.pos.x, this.pos.y + 70)

        queue_insert(store, help)

        return help
    end

    local function show_throw_virgin()
        local e = E:create_entity("fx")

        e.render.sprites[1].name = "volcano_virgin_death"
        e.render.sprites[1].ts = store.tick_ts
        e.render.sprites[1].anchor.y = 0.15
        e.pos = V.vclone(this.pos)

        queue_insert(store, e)
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            local e = E:create_entity("decal_volcano_virgin")

            e.pos = V.vclone(this.pos)
            this.phase = "princess_saved"

            queue_insert(store, e)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
        else
            action = ready_for_action()

            if action == "cheer" then
                this.nav_path.ni = this.nav_path.ni + 1
                cheer_count = cheer_count + 1

                local cheer_cycles = 16
                local cheer_duration = fts(9)
                local scream_every = 6 * cheer_duration

                U.animation_start(this, "cheers", nil, store.tick_ts, true)
                U.y_wait(store, cheer_duration)

                for i = 1, cheer_count do
                    S:queue(this.sound_events.scream)

                    local help_banner = show_help_banner()

                    if U.y_wait(store, scream_every, function()
                        return this.health.dead or #this.enemy.blockers > 0
                    end) then
                        queue_remove(store, help_banner)

                        goto label_24_0
                    end
                end

                while cheer_cycles > this.render.sprites[1].runs do
                    if this.health.dead or #this.enemy.blockers > 0 then
                        break
                    end

                    coroutine.yield()
                end
            elseif action == "throw" then
                this.nav_path.ni = this.nav_path.ni + 1

                U.animation_start(this, "throw", nil, store.tick_ts, false)
                S:queue(this.sound_events.throw, {
                    delay = fts(39)
                })
                U.y_wait(store, fts(9))
                show_help_banner()
                S:queue(this.sound_events.scream)
                U.y_wait(store, fts(33))
                show_throw_virgin()
                U.y_animation_wait(this)

                this.phase = "princess_thrown"

                U.y_animation_play(this, "lol", nil, store.tick_ts, 8)

                local dist = 25
                local eta = dist / this.motion.real_speed
                local fade_step = 255 / (eta / store.tick_length)

                U.animation_start(this, "away", false, store.tick_ts, true)
                U.set_destination(this, V.v(this.pos.x + dist, this.pos.y))

                this.health.hp = 0

                while not this.motion.arrived do
                    U.walk(this, store.tick_length)

                    this.render.sprites[1].alpha = km.clamp(0, 255, this.render.sprites[1].alpha - fade_step)

                    coroutine.yield()
                end

                queue_remove(store, this)

                return
            end

            ::label_24_0::

            ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_for_action()
            end)

            if not ok then
                -- block empty
            elseif not blocker or not SU.y_wait_for_blocker(store, this, blocker) then
                -- block empty
            else
                while SU.can_melee_blocker(store, this, blocker) do
                    if not SU.y_enemy_melee_attacks(store, this, blocker) then
                        break
                    end

                    coroutine.yield()
                end
            end
        end

        coroutine.yield()
    end
end

scripts.enemy_nightscale = {}

function scripts.enemy_nightscale.update(this, store, script)
    local terrain_type
    local h = this.hidden
    local hide_times = 0

    local function ready_to_hide()
        return hide_times < h.max_times and this.enemy.can_do_magic and not this.unit.is_stunned and terrain_type ==
                   TERRAIN_LAND and this.health.hp / this.health.hp_max <= h.trigger_health_factor and
                   P:nodes_to_defend_point(this.nav_path) > h.nodeslimit
    end

    ::label_30_0::

    while true do
        if this.cliff then
            terrain_type = SU.enemy_cliff_change(store, this)
        end

        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
            coroutine.yield()
        else
            if ready_to_hide() then
                hide_times = hide_times + 1

                U.unblock_all(store, this)

                this.vis.bans = bor(F_BLOCK, F_RANGED, F_BLOOD, F_TWISTER)

                S:queue(this.sound_events.hide)
                U.y_animation_play(this, "hide", nil, store.tick_ts)

                this.render.sprites[1].alpha = 40
                h.ts = store.tick_ts

                while store.tick_ts - h.ts < h.duration and not this.health.dead and this.enemy.can_do_magic and
                    P:nodes_to_defend_point(this.nav_path) > h.nodeslimit do
                    if this.unit.is_stunned then
                        U.animation_start(this, "idle", nil, store.tick_ts, true)
                        coroutine.yield()
                    else
                        SU.y_enemy_walk_step(store, this)
                    end
                end

                this.render.sprites[1].alpha = 255
                this.vis.bans = 0
            end

            local ignore_soldiers = terrain_type == TERRAIN_CLIFF
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers,
                function(store, this)
                    return ready_to_hide()
                end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_30_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_hide() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_30_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_darter = {}

function scripts.enemy_darter.update(this, store, script)
    local terrain_type
    local b = this.blink

    b.ts = store.tick_ts

    local last_blink_hp = this.health.hp

    local function ready_to_blink()
        if this.enemy.can_do_magic and terrain_type == TERRAIN_LAND and last_blink_hp ~= this.health.hp and
            store.tick_ts - b.ts > b.cooldown and P:nodes_to_defend_point(this.nav_path) > b.nodeslimit and
            P:get_end_node(this.nav_path.pi) - this.nav_path.ni > b.nodeslimit_conn then
            return true
        else
            last_blink_hp = this.health.hp

            return false
        end
    end

    ::label_33_0::

    while true do
        if this.cliff then
            terrain_type = SU.enemy_cliff_change(store, this)
        end

        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_blink() then
                b.ts = store.tick_ts

                U.unblock_all(store, this)

                this.vis.bans = bor(F_ALL)
                this.render.sprites[1].hidden = true
                this.health_bar.hidden = true

                SU.hide_modifiers(store, this, true)
                SU.hide_auras(store, this, true)
                S:queue(this.sound_events.blink)

                local fx = E:create_entity(b.fx)

                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                fx.render.sprites[1].ts = store.tick_ts

                queue_insert(store, fx)

                this.nav_path.ni = this.nav_path.ni + math.random(b.nodes_offset_min, b.nodes_offset_max)
                this.nav_path.ni = math.min(this.nav_path.ni, P:get_end_node(this.nav_path.pi) - b.nodeslimit_conn)

                local npos = P:node_pos(this.nav_path)

                this.pos.x, this.pos.y = npos.x, npos.y

                U.y_wait(store, b.travel_time)
                S:queue(this.sound_events.blink)

                local fx = E:create_entity(b.fx)

                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y - 1
                fx.render.sprites[1].ts = store.tick_ts

                queue_insert(store, fx)

                this.render.sprites[1].hidden = false
                this.health_bar.hidden = false
                this.vis.bans = 0

                SU.show_modifiers(store, this, true)
                SU.show_auras(store, this, true)
            end

            local ignore_soldiers = terrain_type == TERRAIN_CLIFF
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers,
                function(store, this)
                    return ready_to_blink()
                end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_33_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_blink() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_33_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_savant = {}

function scripts.enemy_savant.update(this, store, script)
    local pa = this.timed_attacks.list[1]

    pa.cooldown = math.random(pa.min_cooldown, pa.max_cooldown)

    local ok, blocker, ranged
    local cg = store.count_groups[pa.count_group_type]

    pa.ts = store.tick_ts

    local function ready_to_portal()
        return enemy_ready_to_magic_attack(this, store, pa) and
                   (not cg[pa.count_group_name] or cg[pa.count_group_name] < pa.count_group_max) and
                   P:nodes_to_defend_point(this.nav_path) > pa.nodes_limit and
                   P:is_node_valid(this.nav_path.pi, this.nav_path.ni + pa.node_offset + 1)
    end

    ::label_36_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_portal() then
                local pi, spi, ni = this.nav_path.pi, this.nav_path.spi, this.nav_path.ni
                local path = P:path(pi, 1)

                ni = ni + pa.node_offset

                local npos = P:node_pos(pi, 1, ni)

                S:queue(pa.sound)
                U.y_animation_play(this, pa.animations[1], nil, store.tick_ts)

                local portal = E:create_entity(pa.entity)

                portal.pos.x, portal.pos.y = npos.x, npos.y
                portal.portal.spawner_id = this.id
                portal.portal.pi = pi
                portal.portal.spi = 1
                portal.portal.ni = ni
                portal.portal.count_group_name = pa.count_group_name
                portal.portal.count_group_type = pa.count_group_type
                portal.portal.count_group_max = pa.count_group_max
                portal.portal.finished = false

                queue_insert(store, portal)
                U.animation_start(this, pa.animations[2], npos.x < this.pos.x, store.tick_ts, true)

                while not portal.portal.finished and #this.enemy.blockers == 0 and this.enemy.can_do_magic and
                    not this.health.dead do
                    coroutine.yield()
                end

                portal.portal.finished = true

                U.y_animation_play(this, pa.animations[3], nil, store.tick_ts)

                pa.ts = store.tick_ts
            end

            ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_portal()
            end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_36_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_36_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
                        if not SU.y_enemy_range_attacks(store, this, ranged) then
                            goto label_36_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.savant_portal = {}

function scripts.savant_portal.update(this, store, script)
    local p = this.portal
    local pi = p.pi
    local spi = 1
    local ni, spawn_ts
    local cg = store.count_groups[p.count_group_type]
    local count = 0
    local spawner = store.entities[p.spawner_id]
    local spawn_name, spawn, fx

    p.ts = store.tick_ts

    U.y_animation_play(this, "start", nil, store.tick_ts, 1)
    S:queue(this.sound_events.loop)
    U.animation_start(this, "loop", nil, store.tick_ts, true)

    while store.tick_ts - p.ts < p.duration and count < p.max_count and not p.finished and spawner and
        not spawner.health.dead do
        if cg[p.count_group_name] and cg[p.count_group_name] >= p.count_group_max then
            coroutine.yield()
        else
            for _, ep in ipairs(p.entities) do
                if math.random() <= ep[1] then
                    spawn_name = ep[2]

                    break
                end
            end

            spawn = E:create_entity(spawn_name)
            spi = km.zmod(spi + 1, 3)
            ni = p.ni + math.random(p.node_var[1], p.node_var[2])
            spawn.nav_path.pi, spawn.nav_path.spi, spawn.nav_path.ni = pi, spi, ni
            spawn.pos = P:node_pos(spawn.nav_path)
            spawn.enemy.gold = 0
            spawn.unit.spawner_id = this.id

            E:add_comps(spawn, "count_group")

            spawn.count_group.name = p.count_group_name
            spawn.count_group.type = p.count_group_type

            queue_insert(store, spawn)
            S:queue(this.sound_events.spawn)

            fx = E:create_entity(p.spawn_fx)
            fx.pos.x, fx.pos.y = spawn.pos.x, spawn.pos.y - 1
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)

            spawn_ts = store.tick_ts

            while store.tick_ts - spawn_ts < p.cycle_time and not p.finished do
                coroutine.yield()
            end
        end

        spawner = store.entities[p.spawner_id]
    end

    S:stop(this.sound_events.loop)

    p.finished = true

    U.y_animation_play(this, "end", nil, store.tick_ts, 1)
    queue_remove(store, this)
end

scripts.enemy_quetzal = {}

function scripts.enemy_quetzal.update(this, store, script)
    local ta = this.timed_attacks.list[1]

    ta.ts = store.tick_ts
    ta.cooldown = U.frandom(ta.min_cooldown, ta.max_cooldown)

    local eggs_count = 0

    local function ready_to_lay()
        return enemy_ready_to_magic_attack(this, store, ta) and eggs_count < ta.max_count
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_lay() then
                ta.ts = store.tick_ts
                eggs_count = eggs_count + 1

                local pi, spi, ni = this.nav_path.pi, this.nav_path.spi, this.nav_path.ni
                local e = E:create_entity(ta.bullet)

                e.pos.x, e.pos.y = this.pos.x, this.pos.y
                e.spawner.pi = pi
                e.spawner.spi = spi
                e.spawner.ni = ni

                queue_insert(store, e)
            end

            SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_lay()
            end)
        end
    end
end

scripts.enemy_sniper = {}

function scripts.enemy_sniper.insert(this, store)
    local result = scripts.enemy_basic.insert(this, store)

    if result then
        local a = this.ranged.attacks[1]
        a.max_range = a.max_range + math.random(-a.range_var, a.range_var)
    end

    return result
end

function scripts.enemy_sniper.update(this, store)
    ::label_44_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_44_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_44_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    local b
                    local ra = this.ranged.attacks[1]
                    local an, af, aidx = U.animation_name_facing_point(this, ra.animations[1], ranged.pos)

                    U.y_animation_play(this, an, af, store.tick_ts, 1)

                    ::label_44_1::

                    if ranged and ranged._sniper_id == this.id then
                        ranged._sniper_id = nil
                    end

                    targets = U.find_soldiers_in_range(store.soldiers, this.pos, ra.min_range, ra.max_range,
                        ra.vis_flags, ra.vis_bans)

                    if not targets then
                        -- block empty
                    else
                        table.sort(targets, function(e1, e2)
                            return not e1._sniper_id and e2._sniper_id
                        end)

                        ranged = targets[1]

                        if not ranged._sniper_id then
                            ranged._sniper_id = this.id
                        end

                        while store.tick_ts - ra.ts <= ra.cooldown do
                            coroutine.yield()

                            if this.health.dead or #this.enemy.blockers ~= 0 then
                                goto label_44_2
                            end

                            if not SU.can_range_soldier(store, this, ranged) then
                                goto label_44_1
                            end
                        end

                        an, af, aidx = U.animation_name_facing_point(this, ra.animations[2], ranged.pos)

                        U.animation_start(this, an, af, store.tick_ts, false)
                        U.y_wait(store, ra.shoot_time)

                        b = E:create_entity(ra.bullet)
                        b.pos.x = this.pos.x + (af and -1 or 1) * ra.bullet_start_offset[aidx].x
                        b.pos.y = this.pos.y + ra.bullet_start_offset[aidx].y
                        b.bullet.from = V.vclone(b.pos)
                        b.bullet.to = V.v(ranged.pos.x + ranged.unit.hit_offset.x,
                            ranged.pos.y + ranged.unit.hit_offset.y)
                        b.bullet.source_id = this.id
                        b.bullet.target_id = ranged.id

                        queue_insert(store, b)

                        ra.ts = store.tick_ts

                        while not U.animation_finished(this) do
                            coroutine.yield()
                        end

                        goto label_44_1
                    end

                    ::label_44_2::

                    if ranged and ranged._sniper_id == this.id then
                        ranged._sniper_id = nil
                    end

                    an, af = U.animation_name_facing_point(this, ra.animations[3], ranged.pos)

                    U.y_animation_play(this, an, af, store.tick_ts, 1)
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_blacksurge = {}

function scripts.enemy_blacksurge.update(this, store, script)
    local terrain_type
    local ta = this.timed_attacks.list[1]
    local h = this.hidden

    h.ts = -h.cooldown

    local function ready_to_hide()
        return enemy_ready_to_magic_attack(this, store, h) and terrain_type == TERRAIN_LAND and this.health.hp > 0 and
                   this.health.hp / this.health.hp_max <= h.trigger_health_factor and
                   P:nodes_to_defend_point(this.nav_path) > h.nodeslimit
    end

    local function ready_to_curse()
        if not enemy_ready_to_magic_attack(this, store, ta) or terrain_type ~= TERRAIN_LAND then
            return false
        end

        local towers = table.filter(store.towers, function(_, e)
            return not e.tower_holder and e.tower and e.tower.can_be_mod and not e.tower.blocked and
                       U.is_inside_ellipse(e.pos, this.pos, ta.range)
        end)

        return #towers > 0
    end

    local water_trail = E:create_entity("ps_water_trail")

    water_trail.particle_system.track_id = this.id

    queue_insert(store, water_trail)

    ::label_46_0::

    while true do
        if this.water then
            terrain_type = SU.enemy_water_change(store, this)
            water_trail.particle_system.emit = terrain_type == TERRAIN_WATER
        end

        if this.health.dead then
            SU.y_enemy_death(store, this)

            water_trail.particle_system.emit = false

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_curse() then
                ta.ts = store.tick_ts

                U.animation_start(this, ta.animation, nil, store.tick_ts, 1)

                while store.tick_ts - ta.ts < ta.shoot_time do
                    if this.health.dead then
                        goto label_46_0
                    end

                    if this.unit.is_stunned then
                        goto label_46_0
                    end

                    coroutine.yield()
                end

                local towers = table.filter(store.towers, function(_, e)
                    return not e.tower_holder and e.tower and e.tower.can_be_mod and not e.tower.blocked and
                               U.is_inside_ellipse(e.pos, this.pos, ta.range)
                end)

                for i, tower in ipairs(towers) do
                    if i > ta.max_count then
                        break
                    end

                    local m = E:create_entity(ta.mod)

                    m.modifier.target_id = tower.id
                    m.modifier.source_id = this.id
                    m.pos = tower.pos

                    queue_insert(store, m)
                end

                if #towers > 0 then
                    S:queue(ta.sound)
                end

                while not U.animation_finished(this) do
                    coroutine.yield()
                end
            end

            if ready_to_hide() then
                SU.remove_modifiers(store, this)
                U.unblock_all(store, this)

                this.vis.bans = h.vis_bans
                this.health.immune_to = bnot(bor(DAMAGE_INSTAKILL, DAMAGE_EAT))

                local orig_prefix = this.render.sprites[1].prefix

                this.render.sprites[1].prefix = this.render.sprites[1].prefix .. h.sprite_suffix

                U.animation_start(this, "hide", nil, store.tick_ts, 1)

                while not U.animation_finished(this) do
                    if this.health.dead then
                        goto label_46_1
                    end

                    coroutine.yield()
                end

                h.ts = store.tick_ts

                while store.tick_ts - h.ts < h.duration and P:nodes_to_defend_point(this.nav_path) > h.nodeslimit do
                    if band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK) ~= TERRAIN_LAND then
                        goto label_46_1
                    end

                    if this.health.dead or this.health.hp <= 0 then
                        goto label_46_1
                    end

                    if this.unit.is_stunned then
                        coroutine.yield()
                    else
                        if store.tick_ts - h.ts < this.regen.duration and store.tick_ts - this.regen.ts >
                            this.regen.cooldown then
                            this.regen.ts = store.tick_ts
                            this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.regen.health)
                        end

                        SU.y_enemy_walk_step(store, this)
                    end
                end

                U.animation_start(this, "show", nil, store.tick_ts, 1)

                while not U.animation_finished(this) do
                    coroutine.yield()
                end

                ::label_46_1::

                this.vis.bans = 0
                this.health.immune_to = DAMAGE_NONE
                this.render.sprites[1].prefix = orig_prefix

                goto label_46_0
            end

            local ignore_soldiers = terrain_type == TERRAIN_WATER
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers,
                function(store, this)
                    return ready_to_hide() or ready_to_curse()
                end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_46_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_hide() and not ready_to_curse() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_46_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    while SU.can_range_soldier(store, this, ranged) and not ready_to_hide() and not ready_to_curse() do
                        if not SU.y_enemy_range_attacks(store, this, ranged) then
                            goto label_46_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_bluegale = {}

function scripts.enemy_bluegale.update(this, store, script)
    local terrain_type
    local sa = this.timed_attacks.list[1]
    local ok, blocker, ranged, ignore_soldiers

    local function ready_to_cast()
        return enemy_ready_to_magic_attack(this, store, sa) and terrain_type == TERRAIN_LAND
    end

    sa.ts = store.tick_ts

    local water_trail = E:create_entity("ps_water_trail")

    water_trail.particle_system.track_id = this.id

    queue_insert(store, water_trail)

    while true do
        if this.water then
            terrain_type = SU.enemy_water_change(store, this)
        end

        if this.health.dead then
            SU.y_enemy_death(store, this)

            water_trail.particle_system.emit = false

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_cast() then
                sa.ts = store.tick_ts - sa.cooldown + 0.5

                local pi, spi, ni = this.nav_path.pi, this.nav_path.spi, this.nav_path.ni
                local path = P:path(pi, 1)

                ni = ni + math.random(sa.node_random_min, sa.node_random_max)

                local npos = P:node_pos(pi, 1, ni)

                if not P:is_node_valid(pi, ni) or GR:cell_is(npos.x, npos.y, TERRAIN_WATER) or ni + sa.nodes_limit >=
                    #path then
                    log.paranoid("bluegale - cannot cast: node is not valid")
                else
                    npos.x = npos.x + math.random(-30, 30)
                    npos.y = npos.y + math.random(-50, 80)
                    sa.ts = store.tick_ts

                    S:queue(sa.sound)
                    U.animation_start(this, sa.animation, nil, store.tick_ts, false)

                    while store.tick_ts - sa.ts < sa.shoot_time do
                        if this.health.dead then
                            goto label_52_0
                        end

                        coroutine.yield()
                    end

                    local e = E:create_entity(sa.bullet)

                    e.aura.source_id = this.id
                    e.pos = npos

                    queue_insert(store, e)
                    U.y_animation_wait(this)
                end
            end

            ignore_soldiers = terrain_type == TERRAIN_WATER
            water_trail.particle_system.emit = ignore_soldiers
            ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, function(this, store)
                return ready_to_cast()
            end)

            if not ok then
                -- block empty
            elseif blocker then
                if not SU.y_wait_for_blocker(store, this, blocker) then
                    -- block empty
                else
                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_cast() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            break
                        end

                        coroutine.yield()
                    end
                end
            elseif ranged then
                while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and not ready_to_cast() do
                    if not SU.y_enemy_range_attacks(store, this, ranged) then
                        break
                    end

                    coroutine.yield()
                end
            end
        end

        ::label_52_0::

        coroutine.yield()
    end
end

scripts.enemy_deviltide_shark = {}

function scripts.enemy_deviltide_shark.get_info(this)
    local t = E:get_template("enemy_deviltide")

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = t.melee.attacks[1].damage_min,
        damage_max = t.melee.attacks[1].damage_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.enemy_deviltide_shark.update(this, store, script)
    local n = this.nav_path
    local water_trail = E:create_entity("ps_water_trail")

    water_trail.particle_system.track_id = this.id

    queue_insert(store, water_trail)

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            water_trail.particle_system.emit = false

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local next, new = P:next_entity_node(this, store.tick_length)

            if not next then
                log.warning("enemy %s ran out of nodes to walk", this.id)
                coroutine.yield()

                return
            end

            U.set_destination(this, next)

            local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

            U.animation_start(this, an, af, store.tick_ts, -1)
            U.walk(this, store.tick_length)
            coroutine.yield()

            this.motion.speed.x, this.motion.speed.y = 0, 0

            local npos = P:node_pos(n.pi, n.spi, n.ni + 6)

            if band(GR:cell_type(npos.x, npos.y), TERRAIN_LAND) ~= 0 then
                this.vis.flags = F_NONE
                this.vis.bans = F_ALL
                this.health.immune_to = DAMAGE_ALL

                SU.remove_modifiers(store, this)

                this.health_bar.hidden = true
                this.ui.can_click = false
                this.ui.can_select = false
                water_trail.particle_system.emit = false

                S:queue(this.sound_events.deploy)
                U.animation_start(this, "deploy", nil, store.tick_ts, 1)

                while store.tick_ts - this.render.sprites[1].ts < this.payload_time do
                    coroutine.yield()
                end

                local e = E:create_entity(this.payload)

                e.pos.x, e.pos.y = V.add(this.pos.x, this.pos.y, 71, 4)
                e.nav_path.pi = this.nav_path.pi
                e.nav_path.spi = this.nav_path.spi
                e.nav_path.ni = this.nav_path.ni + 11
                e.health.hp = this.health.hp

                queue_insert(store, e)

                while not U.animation_finished(this) do
                    coroutine.yield()
                end

                queue_remove(store, this)

                return
            end
        end
    end
end

scripts.phantom_warrior_aura = {}

function scripts.phantom_warrior_aura.update(this, store)
    local a = this.aura

    a.ts = store.tick_ts

    local last_ts = store.tick_ts
    local source = store.entities[a.source_id]

    if not source then
        queue_remove(store, this)

        return
    end

    this.pos = source.pos

    while true do
        source = store.entities[a.source_id]

        if not source or source.health.dead then
            queue_remove(store, this)

            return
        end

        if not source.enemy.can_do_magic then
            -- block empty
        elseif store.tick_ts - last_ts >= a.cycle_time then
            last_ts = store.tick_ts

            local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans,
                function(e)
                    return not table.contains(a.banned_templates, e.template_name)
                end)

            if targets then
                for _, target in pairs(targets) do
                    local d = E:create_entity("damage")

                    d.damage_type = a.damage_type
                    d.value = a.damage_max * (target.hero and a.hero_damage_factor or 1)
                    d.target_id = target.id
                    d.source_id = this.id

                    queue_damage(store, d)

                    source.aura_applied = true
                end
            end
        end

        coroutine.yield()
    end
end

scripts.enemy_headless_horseman = {}

function scripts.enemy_headless_horseman.update(this, store)
    this.lifespan.ts = store.tick_ts

    local ra = this.ranged.attacks[1]
    local flip = this.idle_flip
    local bans = this.vis.bans

    if this.custom_spawn_data and this.custom_spawn_data.lifespan then
        this.lifespan.duration = this.custom_spawn_data.lifespan
    end

    this.health_bar.hidden = true
    this.vis.bans = F_ALL

    U.y_animation_play(this, "rise", this.pos.x > this.motion.forced_waypoint.x, store.tick_ts, 1)

    while SU.y_enemy_walk_step(store, this) do
        -- block empty
    end

    this.vis.bans = bans
    this.health_bar.hidden = nil

    ::label_62_0::

    while true do
        if this.health.dead then
            local delay = fts(4)
            local off_x = 25

            for i = 1, 3 do
                local e = E:create_entity("fx_coin_jump")

                e.render.sprites[1].ts = store.tick_ts + delay * (i - 1)
                e.pos.x = this.pos.x + (i - 1) * off_x * (this.render.sprites[1].flip_x and -1 or 1)
                e.pos.y = this.pos.y
                e.sound_events.insert_args = {
                    delay = delay * (i - 1)
                }

                queue_insert(store, e)
            end

            SU.y_enemy_death(store, this)

            return
        end

        if store.tick_ts - this.lifespan.ts > this.lifespan.duration then
            this.health_bar.hidden = true
            this.vis.bans = F_ALL
            this.vis.flags = F_NONE

            U.unblock_all(store, this)
            SU.remove_modifiers(store, this)
            U.y_animation_play(this, "death", nil, store.tick_ts, 1)
            queue_remove(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local blocker = U.get_blocker(store, this)

            if blocker then
                if not SU.y_wait_for_blocker(store, this, blocker) then
                    goto label_62_0
                end

                while SU.can_melee_blocker(store, this, blocker) do
                    if not SU.y_enemy_melee_attacks(store, this, blocker) then
                        goto label_62_0
                    end

                    coroutine.yield()
                end
            else
                local ranged = U.find_nearest_soldier(store.soldiers, this.pos, ra.min_range, ra.max_range,
                    ra.vis_flags, ra.vis_bans)

                if ranged then
                    while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
                        if not SU.y_enemy_range_attacks(store, this, ranged) then
                            goto label_62_0
                        end

                        coroutine.yield()
                    end
                end
            end

            if store.tick_ts - flip.ts > flip.cooldown then
                flip.ts = store.tick_ts

                local new_pos = V.vclone(this.pos)

                flip.last_dir = -1 * flip.last_dir
                new_pos.x = new_pos.x + flip.last_dir * flip.walk_dist
                this.motion.forced_waypoint = new_pos

                local bans = this.vis.bans

                this.vis.bans = F_ALL

                while SU.y_enemy_walk_step(store, this) do
                    -- block empty
                end

                this.vis.bans = bans
            end

            U.animation_start(this, "idle", nil, store.tick_ts, true)
            coroutine.yield()
        end
    end
end

scripts.headless_horseman_spawner_aura = {}

function scripts.headless_horseman_spawner_aura.update(this, store)
    local source, sd, pi_idx

    source = store.entities[this.aura.source_id]

    if not source or source.health.dead then
        -- block empty
    else
        sd = source.custom_spawn_data

        if not sd or not sd.s_paths or not sd.s_list then
            log.debug("headless horseman spawner aura data not found or has errors for id:%s. removing spawner aura...",
                source.id)
        else
            this.aura.ts = store.tick_ts
            pi_idx = 1

            U.y_wait(store, 2)

            while true do
                source = store.entities[this.aura.source_id]

                if not source or source.health.dead then
                    break
                end

                local pi = sd.s_paths[pi_idx]

                pi_idx = km.zmod(pi_idx + 1, #sd.s_paths)

                local spawn_pos = P:node_pos(source.nav_path)
                local nodes = P:nearest_nodes(spawn_pos.x, spawn_pos.y, {pi})
                local ni = nodes[1][3]
                local spawn_queue = {}

                for _, item in pairs(sd.s_list) do
                    local qty, name = unpack(item)

                    for i = 1, qty do
                        table.insert(spawn_queue, {U.frandom(0, sd.s_delay), name, pi, math.random(1, 3), ni})
                    end
                end

                table.sort(spawn_queue, function(e1, e2)
                    return e1[1] < e2[1]
                end)

                local start_ts = store.tick_ts

                for i = 1, #spawn_queue do
                    local delay, name, pi, spi, ni = unpack(spawn_queue[i])
                    local ts = store.tick_ts - start_ts

                    if ts < delay then
                        U.y_wait(store, delay - ts)
                    end

                    local e = E:create_entity(name)

                    e.nav_path.pi = pi
                    e.nav_path.spi = spi
                    e.nav_path.ni = ni
                    e.render.sprites[1].name = "raise"
                    e.enemy.gold = 0

                    queue_insert(store, e)
                end

                U.y_wait(store, this.spawner.cycle_time - (store.tick_ts - start_ts))
            end
        end
    end

    queue_remove(store, this)
end

scripts.aura_damage_sprint = {}

function scripts.aura_damage_sprint.insert(this, store, script)
    local target = store.entities[this.aura.source_id]

    if not target or target.health.dead or not target.motion then
        return false
    end

    if not target.damage_sprint_factor then
        log.error("Target %s has no damage_sprint_factor property. Aura discarded.", this.aura.source_id)

        return false
    end

    this.last_sprint_factor = 1
    this.aura.ts = store.tick_ts

    return true
end

function scripts.aura_damage_sprint.remove(this, store, script)
    local target = store.entities[this.aura.source_id]

    if target and target.health and target.motion then
        U.speed_div(target, this.last_sprint_factor)
    end

    return true
end

function scripts.aura_damage_sprint.update(this, store, script)
    while true do
        local target = store.entities[this.aura.source_id]

        if not target or target.health.dead or not target.motion then
            queue_remove(store, this)

            return
        end

        if this.last_sprint_hp ~= target.health.hp then
            local hp, hp_max = target.health.hp, target.health.hp_max
            local sprint_factor = 1 + (hp_max - hp) / hp_max * target.damage_sprint_factor

            U.speed_mul(target, sprint_factor / this.last_sprint_factor )
            this.last_sprint_hp = target.health.hp
            this.last_sprint_factor = sprint_factor
        end

        coroutine.yield()
    end
end

scripts.bluegale_clouds = {}

function scripts.bluegale_clouds.insert(this, store, script)
    this.aura.ts = store.tick_ts

    if this.spawn_on_insert then
        for _, n in pairs(this.spawn_on_insert) do
            local e = E:create_entity(n)

            e.pos = V.vclone(this.pos)

            queue_insert(store, e)
        end
    end

    return true
end

function scripts.bluegale_clouds.update(this, store, script)
    local start_ts = store.tick_ts
    local points = {}
    local ang = U.frandom(math.pi / 3, 2 * math.pi / 3)
    local dist = U.frandom(this.clouds_min_radius, this.clouds_max_radius)

    points[1] = V.vclone(this.pos)

    for i = 2, this.clouds_count do
        local ox, oy = V.rotate(ang, dist, 0)

        oy = oy * ASPECT
        points[i] = V.v(this.pos.x + ox, this.pos.y + oy)
        ang = ang + U.frandom(math.pi / 3, 2 * math.pi / 3)

        if ang > 2 * math.pi then
            ang = 0
            dist = dist + U.frandom(this.clouds_min_radius, this.clouds_max_radius)
        end
    end

    for i, dest in ipairs(points) do
        local ah = E:create_entity("bluegale_heal_aura")

        ah.pos = V.v(dest.x, dest.y - 30)
        ah.aura.source_id = this.source_id

        queue_insert(store, ah)

        local ad = E:create_entity("bluegale_damage_aura")

        ad.pos = V.v(dest.x, dest.y - 30)
        ad.aura.source_id = this.source_id

        queue_insert(store, ad)
    end

    local duration = this.aura.duration

    for i, dest in ipairs(points) do
        local delay = i * 0.15
        local max_alpha = 255
        local c_dark = E:create_entity("decal_bluegale_cloud_dark")

        c_dark.pos.x, c_dark.pos.y = dest.x, dest.y
        c_dark.tween.props[1].keys = {{0, 0}, {0.1, max_alpha}, {duration, max_alpha}, {duration + 0.5, 0}}
        c_dark.render.sprites[1].ts = store.tick_ts + delay

        queue_insert(store, c_dark)

        local c_light = E:create_entity("decal_bluegale_cloud_bright")

        c_light.pos.x, c_light.pos.y = dest.x, dest.y
        c_light.tween.props[1].keys = {{0, 0}, {0.1, max_alpha}, {0.2, 0}, {1, 0}}
        c_light.tween.props[3].keys = {{0, false}, {duration + 0.5, true}}
        c_light.render.sprites[1].ts = store.tick_ts + delay

        queue_insert(store, c_light)

        local c_shadow = E:create_entity("decal_bluegale_cloud_shadow")

        c_shadow.pos.x, c_shadow.pos.y = dest.x, dest.y - 40
        c_shadow.tween.props[1].keys = {{0, 0}, {0.1, 255}, {duration, 255}, {duration + 0.5, 0}}
        c_shadow.render.sprites[1].ts = store.tick_ts + delay

        queue_insert(store, c_shadow)
    end

    U.y_wait(store, 1)

    while store.tick_ts - start_ts < this.aura.duration do
        S:queue("RTBluegaleStormAmbience")
        U.y_wait(store, U.frandom(1, 4))
    end

    queue_remove(store, this)
end

scripts.blazefang_explosion = {}

function scripts.blazefang_explosion.update(this, store, script)
    local b = this.bullet
    local targets = table.filter(store.soldiers, function(k, v)
        return not v.health.dead and U.is_inside_ellipse(v.pos, this.pos, b.damage_radius)
    end)

    for _, target in pairs(targets) do
        local d = E:create_entity("damage")

        d.source_id = this.id
        d.target_id = target.id
        d.value = b.damage_min + math.ceil(U.frandom(b.damage_min, b.damage_max))
        d.damage_type = b.damage_type

        queue_damage(store, d)
    end

    queue_remove(store, this)
end

scripts.decal_moon_activated = {}

function scripts.decal_moon_activated.update(this, store)
    local last_state = false

    while true do
        if store.level and store.level.moon_controller then
            local state = store.level.moon_controller.moon_active

            if last_state ~= state then
                this.tween.reverse = not state
                this.tween.ts = store.tick_ts
                last_state = state
            end
        end

        coroutine.yield()
    end
end

scripts.elvira_bat = {}

function scripts.elvira_bat.update(this, store)
    signal.emit("wave-notification", "icon", "enemy_elvira")
    U.animation_start(this, "fly", nil, store.tick_ts, true)
    U.set_destination(this, this.motion.forced_waypoint)

    while not this.motion.arrived and not this.spawner.interrupt do
        U.walk(this, store.tick_length)
        coroutine.yield()
    end

    if this.spawner.interrupt then
        U.y_animation_play(this, "death", nil, store.tick_ts)
        queue_remove(store, this)

        return
    end

    if this.payload then
        local e = E:create_entity(this.payload)
        e.pos.x, e.pos.y = this.pos.x, this.pos.y
        e.nav_path.pi = this.nav_path.pi
        e.nav_path.spi = this.nav_path.spi
        e.nav_path.ni = this.nav_path.ni
        e.render.sprites[1].name = "raise"
        e.health.hp_max = e.health.hp_max * this.health_factor
        e.health.hp = e.health.hp_max
        queue_insert(store, e)
    end

    queue_remove(store, this)
end

scripts.enemy_elvira = {}

function scripts.enemy_elvira.can_lifesteal(this, store, attack, target)
    return target.template_name ~= "soldier_death_rider" and target.template_name ~= "soldier_skeleton" and
               target.template_name ~= "soldier_skeleton_knight" and target.template_name ~= "soldier_frankenstein" and target.emplate_name ~= "hero_vampiress" and this.enemy.can_do_magic and this.health.hp /
               this.health.hp_max < attack.health_trigger_factor
end

scripts.mod_elvira_lifesteal = {}

function scripts.mod_elvira_lifesteal.insert(this, store)
    local source = store.entities[this.modifier.source_id]
    local target = store.entities[this.modifier.target_id]
    local moon_active = store.level.moon_controller and store.level.moon_controller.moon_active

    if source and source.health then
        local heal_hp = this.heal_hp

        if moon_active then
            heal_hp = heal_hp * this.moon.heal_hp_factor
        end

        source.health.hp = km.clamp(0, source.health.hp_max, source.health.hp + heal_hp)
    end

    if target and target.health then
        local value = this.damage

        if moon_active then
            value = value * this.moon.damage_factor
        end

        local d = E:create_entity("damage")

        d.value = value
        d.source_id = this.id
        d.target_id = target.id
        d.damage_type = DAMAGE_RUDE

        queue_damage(store, d)
    end

    return false
end

scripts.decal_taunting_dracula = {}

function scripts.decal_taunting_dracula.update(this, store)
    local taunt = this.taunt
    local pos_idx = math.random(1, 2)
    local s = this.render.sprites[1]
    local cooldown = math.random(taunt.cooldown[1], taunt.cooldown[2])
    local last_ts
    local moon = store.level and store.level.moon_controller
    local last_was_moon = false
    local last_wave

    local function show_taunt(pos_idx, fmt, idx, duration)
        local t = E:create_entity("decal_dracula_shoutbox")

        t.texts.list[1].text = _(string.format(fmt, idx))
        t.pos = taunt.taunt_positions[pos_idx]
        t.timed.duration = duration
        t.render.sprites[1].ts = store.tick_ts
        t.render.sprites[2].ts = store.tick_ts

        queue_insert(store, t)

        return t
    end

    this.showing = true
    this.pos = taunt.dracula_positions[pos_idx]
    s.hidden = false

    U.y_animation_play(this, "show", nil, store.tick_ts, 1)
    show_taunt(pos_idx, taunt.format_welcome, 1, taunt.duration)
    U.y_wait(store, taunt.duration)
    show_taunt(pos_idx, taunt.format_welcome, 2, taunt.duration)
    U.y_wait(store, taunt.duration)
    U.y_animation_play(this, "hide", nil, store.tick_ts, 1)

    s.hidden = true
    last_ts = store.tick_ts
    this.showing = false

    while true do
        if moon and moon.moon_active and not last_was_moon and store.tick_ts - last_ts > taunt.min_cooldown then
            last_was_moon = true
            this.showing = true
            this.pos = taunt.dracula_positions[pos_idx]
            s.hidden = false

            U.y_animation_play(this, "show", nil, store.tick_ts, 1)

            local taunt_idx = math.random(taunt.idx_moon[1], taunt.idx_moon[2])

            show_taunt(pos_idx, taunt.format_moon, taunt_idx, taunt.duration)
            U.y_wait(store, taunt.duration)
            U.y_animation_play(this, "hide", nil, store.tick_ts, 1)

            s.hidden = true
            last_ts = store.tick_ts
            pos_idx = math.random(1, 2)
            this.showing = false
        elseif cooldown < store.tick_ts - last_ts or last_wave ~= store.wave_group_number and store.tick_ts - last_ts >
            taunt.min_cooldown then
            last_was_moon = false
            this.showing = true
            this.pos = taunt.dracula_positions[pos_idx]
            s.hidden = false

            U.y_animation_play(this, "show", nil, store.tick_ts, 1)

            local taunt_idx = math.random(taunt.idx_generic[1], taunt.idx_generic[2])

            show_taunt(pos_idx, taunt.format_generic, taunt_idx, taunt.duration)
            U.y_wait(store, taunt.duration)
            U.y_animation_play(this, "hide", nil, store.tick_ts, 1)

            s.hidden = true
            last_ts = store.tick_ts
            pos_idx = math.random(1, 2)
            this.showing = false
        end

        last_wave = store.wave_group_number

        coroutine.yield()
    end
end

scripts.eb_xerxes = {}

function scripts.eb_xerxes.update(this, store)
    local taunt = this.taunt

    local function y_show_taunt(set, index, duration)
        index = index or math.random(taunt.sets[set].start_idx, taunt.sets[set].end_idx)
        duration = duration or taunt.duration
        taunt.ts = store.tick_ts
        taunt.next_ts = store.tick_ts + math.random(taunt.delay_min, taunt.delay_max)

        local t = E:create_entity("decal_xerxes_shoutbox")

        t.texts.list[1].text = _(string.format(taunt.sets[set].format, index))
        t.pos.x, t.pos.y = this.pos.x + taunt.offset.x, this.pos.y + taunt.offset.y
        t.render.sprites[1].ts = store.tick_ts
        t.render.sprites[2].ts = store.tick_ts

        queue_insert(store, t)
        U.y_wait(store, duration)

        t.tween.props[1].disabled = true
        t.tween.props[2].disabled = true
        t.tween.ts = store.tick_ts
        t.tween.reverse = true
        t.tween.remove = true

        return t
    end

    this.phase = "welcome"

    U.y_wait(store, 1.5)
    y_show_taunt("welcome", 1)
    y_show_taunt("welcome", 2)

    this.phase = "prebattle"

    while this.phase == "prebattle" do
        if store.tick_ts > taunt.next_ts then
            y_show_taunt(this.phase)
        end

        if store.wave_group_number > 0 then
            this.phase = "battle"
        end

        coroutine.yield()
    end

    local last_wave_number = 0
    local a = this.attacks
    local at = this.attacks.list[1]
    local ao = this.attacks.list[2]
    local ai = this.attacks.list[3]
    local wave_config

    while true do
        if store.tick_ts > taunt.next_ts then
            y_show_taunt(this.phase)
        end

        if store.wave_group_number ~= last_wave_number then
            log.debug("EB_XERXES: setting wave config for %s", store.wave_group_number)

            last_wave_number = store.wave_group_number
            wave_config = W:get_endless_boss_config(store.wave_group_number)
            a.chance = wave_config.chance
            a.cooldown = wave_config.cooldown
            a.multiple_attacks_chance = wave_config.multiple_attacks_chance
            a.power_chances = wave_config.power_chances
            a.ts = store.tick_ts
        end

        if store.tick_ts - a.ts > a.cooldown then
            log.debug("EB_XERXES: power cooldown complete")

            a.ts = store.tick_ts

            while math.random() < a.chance do
                local animation = table.random(a.animations)
                local a_idx = U.random_table_idx(a.power_chances)
                local aa = this.attacks.list[a_idx]
                local plevel = km.clamp(0, 9000000000,
                    store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

                if aa == at then
                    log.debug("EB_XERXES: power teleport starts")

                    local targets = table.filter(store.enemies, function(_, e)
                        return not e.pending_removal and e.nav_path and
                                   not e.health.dead and band(e.vis.flags, at.vis_bans) == 0 and
                                   band(e.vis.bans, at.vis_flags) == 0 and P:is_node_valid(e.nav_path.pi, e.nav_path.ni) and
                                   e.nav_path.ni > P:get_visible_start_node(e.nav_path.pi) + at.path_margins[1] and
                                   e.nav_path.ni < P:get_defend_point_node(e.nav_path.pi) - at.path_margins[2]
                    end)

                    if #targets < 1 then
                        log.debug("EB_XERXES: no enemies found for teleport")

                        goto label_214_0
                    end

                    U.animation_start(this, animation, nil, store.tick_ts, false)

                    local target = table.random(targets)
                    local pconf = wave_config.powers_config.teleport
                    local e = E:create_entity(at.aura)

                    e.aura.duration = pconf.duration + plevel * pconf.durationIncrement
                    e.aura.radius = pconf.range / 2
                    e.aura.targets_count = math.floor(pconf.maxTeleports + plevel * pconf.maxTeleportsIncrement)
                    e.aura.min_jump = pconf.minNodesToTeleport
                    e.aura.max_jump = pconf.maxNodesToTeleport

                    local api, aspi = target.nav_path.pi, 1
                    local ani = target.nav_path.ni + math.random(at.node_offset[1], at.node_offset[2])

                    ani = km.clamp(P:get_visible_start_node(api) + at.path_margins[1],
                        P:get_defend_point_node(api) - at.path_margins[2], ani)

                    log.debug("EB_XERXES/teleport aura insertion node: %s,%s,%s target ni:%s defend ni:%s", api, aspi,
                        ani, target.nav_path.ni, P:get_defend_point_node(api))

                    e.pos = P:node_pos(api, aspi, ani)

                    queue_insert(store, e)
                    U.y_animation_wait(this)
                elseif aa == ao then
                    log.debug("EB_XERXES: power obelisk starts")

                    local cg = store.count_groups[ao.count_group_type]

                    if cg[ao.count_group_name] and cg[ao.count_group_name] >= 0.66 * ao.count_group_max and
                        cg.enemy_munra and cg.enemy_munra > 0 then
                        goto label_214_0
                    end

                    U.y_animation_play(this, animation, nil, store.tick_ts, 1)

                    local pconf = wave_config.powers_config.obelysk
                    local pos, pi, spi, ni = P:get_random_position(ao.path_margins, TERRAIN_LAND, nil, true)

                    if not pos then
                        log.warning("EB_XERXES: pos for obelisk could not be found")

                        goto label_214_0
                    end

                    local e = E:create_entity(ao.entity)

                    e.pos = pos
                    e.spawner.pi = pi
                    e.spawner.ni = ni
                    e.spawner.count_group_type = ao.count_group_type
                    e.spawner.count_group_name = ao.count_group_name
                    e.spawner.count_group_max = ao.count_group_max
                    e.spawner.duration = pconf.duration + plevel * pconf.durationIncrement
                    e.spawner.cycle_time_min = pconf.autoSpawnMinInterval
                    e.spawner.cycle_time_max = pconf.autoSpawnMaxInterval
                    e.spawner.node_range = pconf.range

                    queue_insert(store, e)
                elseif aa == ai then
                    log.debug("EB_XERXES: power invisibility starts")

                    local pconf = wave_config.powers_config.invisibility
                    local radius = pconf.range / 2
                    local duration = pconf.duration + plevel * pconf.durationIncrement
                    local targets = table.filter(store.enemies, function(k, e)
                        return not e.pending_removal and e.nav_path and
                                   not e.health.dead and band(e.vis.flags, ai.vis_bans) == 0 and
                                   band(e.vis.bans, ai.vis_flags) == 0 and e.enemy.can_accept_magic and
                                   not table.contains(ai.excluded_templates, e.template_name) and
                                   P:is_node_valid(e.nav_path.pi, e.nav_path.ni) and e.nav_path.ni >
                                   P:get_visible_start_node(e.nav_path.pi) + ai.path_margins[1] and e.nav_path.ni <
                                   P:get_defend_point_node(e.nav_path.pi) - ai.path_margins[2]
                    end)

                    if #targets < 1 then
                        log.debug("EB_XERXES: no enemies found for invisibility")

                        goto label_214_0
                    end

                    local best_count = -1
                    local best_targets, target

                    for _, t in pairs(targets) do
                        local nearby = table.filter(targets, function(_, e)
                            return U.is_inside_ellipse(e.pos, t.pos, radius)
                        end)

                        if best_count < #nearby then
                            best_targets = nearby
                            best_count = #nearby
                            target = t
                        end
                    end

                    U.animation_start(this, animation, nil, store.tick_ts, false)

                    local fx = E:create_entity(ai.fx)

                    fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
                    fx.render.sprites[1].ts = store.tick_ts
                    fx.render.sprites[2].ts = store.tick_ts

                    queue_insert(store, fx)
                    S:queue(ai.sound)

                    for _, t in pairs(best_targets) do
                        last_node = P:get_visible_end_node(t.nav_path.pi) - pconf.reapearBeforeEndNodes
                        last_node_eta = P:predict_enemy_time(t, last_node - t.nav_path.ni)

                        if last_node_eta > 0 then
                            local m = E:create_entity(ai.mod)

                            m.modifier.target_id = t.id
                            m.modifier.source_id = this.id
                            m.modifier.duration = math.min(duration, last_node_eta)
                            m.modifier.last_node = P:get_visible_end_node(target.nav_path.pi) -
                                                       pconf.reapearBeforeEndNodes

                            queue_insert(store, m)
                        end
                    end

                    U.y_animation_wait(this)
                end

                U.animation_start(this, "idle", nil, store.tick_ts)

                ::label_214_0::

                if math.random() >= a.multiple_attacks_chance then
                    break
                end
            end
        end

        coroutine.yield()
    end
end

scripts.xerxes_teleport_aura = {}

function scripts.xerxes_teleport_aura.update(this, store)
    local start_ts = store.tick_ts
    local a = this.aura
    local count = 0

    U.y_animation_play(this, "start", nil, store.tick_ts, 1)
    U.animation_start(this, "loop", nil, store.tick_ts, true)

    while store.tick_ts - start_ts < a.duration do
        local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

        if targets then
            for _, target in pairs(targets) do
                local m = E:create_entity(a.mod)

                m.modifier.source_id = this.id
                m.modifier.target_id = target.id
                m.nodes_offset = math.random(a.min_jump, a.max_jump)

                queue_insert(store, m)

                count = count + 1

                if count > a.targets_count then
                    goto label_219_0
                end
            end
        end

        coroutine.yield()
    end

    ::label_219_0::

    U.y_animation_play(this, "end", nil, store.tick_ts, 1)
    queue_remove(store, this)
end

scripts.xerxes_obelisk = {}

function scripts.xerxes_obelisk.update(this, store)
    local sp = this.spawner
    local start_ts = store.tick_ts
    local spawn_count = 0
    local cg = store.count_groups[sp.count_group_type]
    local sid = 1

    this.tween.ts = store.tick_ts

    U.y_animation_play(this, "start", nil, store.tick_ts, 1, sid)
    U.animation_start(this, "loop", nil, store.tick_ts, true, sid)

    while store.tick_ts - start_ts < sp.duration and
        (not cg[sp.count_group_name] or cg[sp.count_group_name] < sp.count_group_max) do
        spawn_count = spawn_count + 1

        local e = E:create_entity(sp.entity)

        e.nav_path.pi = sp.pi
        e.nav_path.spi = math.random(1, 3)
        e.nav_path.ni = math.random(sp.ni - sp.node_range, sp.ni + sp.node_range)
        e.unit.spawner_id = this.id
        e.pos = P:node_pos(e.nav_path)
        e.render.sprites[1].name = "raise"

        E:add_comps(e, "count_group")

        e.count_group.name = sp.count_group_name
        e.count_group.type = sp.count_group_type

        queue_insert(store, e)
        U.y_wait(store, U.frandom(sp.cycle_time_min, sp.cycle_time_max))
    end

    U.animation_start(this, "end", nil, store.tick_ts, false, sid)

    this.tween.ts = store.tick_ts
    this.tween.reverse = true
    this.tween.remove = true
end

scripts.mod_xerxes_invisibility = {}

function scripts.mod_xerxes_invisibility.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or target.health.dead then
        return false
    end

    if band(m.vis_bans, target.vis.flags) ~= 0 or band(m.vis_flags, target.vis.bans) ~= 0 then
        log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name,
            target.id, target.template_name)

        return false
    end

    if target.unit then
        local s = this.render.sprites[1]

        s.ts = U.frandom(0, 1)
        s.name = s.size_names[target.unit.size]
    end

    if target.enemy then
        U.unblock_all(store, target)
    end

    this.modifier.ts = store.tick_ts

    for _, s in pairs(target.render.sprites) do
        s.alpha = 70
    end

    this._vis_bans = target.vis.bans
    target.vis.bans = F_ALL

    signal.emit("mod-applied", this, target)

    return true
end

function scripts.mod_xerxes_invisibility.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if target then
        for _, s in pairs(target.render.sprites) do
            s.alpha = 255
        end

        target.vis.bans = this._vis_bans
    end

    return true
end

scripts.eb_alien = {}

function scripts.eb_alien.update(this, store)
    local function is_spit_target(e, attack, max_x)
        return e and e.soldier and not e.pending_removal and e.health and not e.health.dead and e.vis and
                   band(e.vis.flags, attack.vis_bans) == 0 and band(e.vis.bans, attack.vis_flags) == 0 and max_x >
                   e.pos.x
    end

    local function find_screech_targets(flags, bans)
        return table.filter(store.enemies, function(k, v)
            return not v.pending_removal and v.nav_path and not v.health.dead and
                       band(v.vis.flags, bans) == 0 and band(v.vis.bans, flags) == 0 and
                       (v.template_name == "enemy_alien_reaper" or v.template_name == "enemy_alien_breeder") and
                       P:is_node_valid(v.nav_path.pi, v.nav_path.ni)
        end)
    end

    while store.wave_group_number < 1 do
        coroutine.yield()
    end

    local last_wave_number = 0
    local wave_config
    local a = this.attacks

    while true do
        if store.wave_group_number ~= last_wave_number then
            last_wave_number = store.wave_group_number
            wave_config = W:get_endless_boss_config(store.wave_group_number)
            a.chance = wave_config.chance
            a.cooldown = wave_config.cooldown
            a.multiple_attacks_chance = wave_config.multiple_attacks_chance
            a.power_chances = wave_config.power_chances
            a.ts = store.tick_ts
        end

        if store.tick_ts - a.ts > a.cooldown then
            a.ts = store.tick_ts

            while math.random() < a.chance do
                local a_idx = U.random_table_idx(a.power_chances)
                local aa = this.attacks.list[a_idx]
                local plevel = km.clamp(0, 9000000000,
                    store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

                log.debug("EB_ALIEN | ts:%s wave:%s attack idx:%s, plevel:%s", store.tick_ts, store.wave_group_number,
                    a_idx, plevel)

                if a_idx == 1 then
                    local pconf = wave_config.powers_config.spit
                    local target

                    if store.main_hero and is_spit_target(store.main_hero, aa, pconf.spitMaxX) then
                        target = store.main_hero
                    else
                        for _, e in pairs(store.entities) do
                            if is_spit_target(e, aa, pconf.spitMaxX) then
                                target = e

                                break
                            end
                        end
                    end

                    if target then
                        U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, 1)
                        S:queue(aa.sound)
                        U.y_wait(store, aa.hit_time)

                        local b = E:create_entity(aa.bullet)

                        b.pos.x, b.pos.y = this.pos.x + aa.bullet_start_offset.x, this.pos.y + aa.bullet_start_offset.y
                        b.bullet.from = V.vclone(b.pos)
                        b.bullet.to = V.v(target.pos.x, target.pos.y)
                        b.bullet.target_id = target.id
                        b.bullet.damage_max = pconf.spitMaxDamage
                        b.bullet.damage_min = pconf.spitMinDamage
                        b.bullet.damage_radius = pconf.spitRange / 2

                        queue_insert(store, b)
                        U.y_animation_wait_group(this, 1)
                    end
                elseif a_idx == 2 then
                    local targets = find_screech_targets(aa.vis_flags, aa.vis_bans)

                    if #targets < 1 then
                        goto label_223_0
                    end

                    S:queue(aa.sound)
                    U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, 1)
                    U.y_wait(store, fts(9))

                    targets = find_screech_targets(aa.vis_flags, aa.vis_bans)

                    for _, t in pairs(targets) do
                        local pconf = wave_config.powers_config.screech
                        local mod = E:create_entity(aa.mod)

                        mod.modifier.target_id = t.id
                        mod.modifier.source_id = this.id
                        mod.modifier.duration = pconf.durationModifier + plevel * pconf.durationModifierIncrement
                        mod.speed_factor = pconf.speedModifierFactor
                        mod.damage_factor = pconf.damageModifierBonus + 1

                        queue_insert(store, mod)
                        log.debug("EB_ALIEN: apply screech to %s", t.id)
                    end

                    U.y_animation_wait_group(this, 1)
                elseif a_idx == 3 then
                    S:queue(aa.sound)
                    U.y_animation_play_group(this, aa.animation, nil, store.tick_ts, 1, 1)
                    U.y_wait(store, 1.5)

                    local e = E:create_entity(aa.entity)

                    e.enemy.gold = 0
                    e.nav_path.pi = table.random(aa.pis)
                    e.nav_path.spi = math.random(1, 3)
                    e.nav_path.ni = 1

                    queue_insert(store, e)
                    log.debug("EB_ALIEN: lay egg %s", e.id)
                elseif a_idx == 4 then
                    local pcd = wave_config.powers_config_dif.spawnLevelEggs
                    local count = 0
                    local sources = table.random_order(aa.spawn_sources)

                    for _, source in pairs(sources) do
                        for i, p in ipairs(source.points) do
                            local e = E:create_entity(aa.entity)

                            e.pos = V.vclone(p)
                            e.spawner.pi = source.pi
                            e.spawner.spi = i
                            e.spawner.count = math.random(pcd.minEnemiesPerEgg, pcd.maxEnemiesPerEgg)

                            queue_insert(store, e)
                        end

                        if math.random() >= pcd.multiPathChance then
                            break
                        end
                    end
                end

                U.animation_start_group(this, "idle", nil, store.tick_ts, true, 1)

                ::label_223_0::

                if math.random() >= a.multiple_attacks_chance then
                    break
                end
            end
        end

        coroutine.yield()
    end
end

scripts.alien_spit_aura = {}

function scripts.alien_spit_aura.insert(this, store)
    local wave_config = W:get_endless_boss_config(store.wave_group_number)

    if not wave_config then
        log.error("get_endless_boss_config failed for %s", this.template_name)

        return false
    end

    local pconf = wave_config.powers_config.spit
    local plevel =
        km.clamp(0, 9000000000, store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

    this.aura.duration = pconf.duration + plevel * pconf.durationIncrement
    this.aura.radius = pconf.poisonRange / 2

    if not scripts.aura_apply_mod.insert(this, store) then
        return false
    end

    local e = E:create_entity("alien_spit_aura_bubbles")

    e.pos.x, e.pos.y = this.pos.x, this.pos.y
    e.duration = 0.8 * this.aura.duration

    queue_insert(store, e)

    return true
end

scripts.alien_spit_aura_bubbles = {}

function scripts.alien_spit_aura_bubbles.update(this, store)
    local start_ts = store.tick_ts

    while true do
        U.y_wait(store, U.frandom(2, 3.25))

        if store.tick_ts - start_ts > this.duration then
            break
        end

        local bubble = E:create_entity(this.fx)
        local o = table.random(this.random_offsets)

        bubble.pos = V.v(this.pos.x + o.x, this.pos.y + o.y)
        bubble.render.sprites[1].ts = store.tick_ts

        queue_insert(store, bubble)
    end

    queue_remove(store, this)
end

scripts.mod_alien_spit = {}

function scripts.mod_alien_spit.insert(this, store)
    local wave_config = W:get_endless_boss_config(store.wave_group_number)

    if not wave_config then
        log.error("get_endless_boss_config failed for %s", this.template_name)

        return false
    end

    local pconf = wave_config.powers_config.spit
    local plevel =
        km.clamp(0, 9000000000, store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

    this.dps.damage_min = pconf.poisonDamage
    this.dps.damage_max = pconf.poisonDamage
    this.dps.damage_every = fts(pconf.poisonDamageFreq)
    this.modifier.duration = pconf.poisonDuration

    if not scripts.mod_dps.insert(this, store) then
        return false
    end

    return true
end

scripts.alien_breeder_spawner = {}

function scripts.alien_breeder_spawner.update(this, store)
    local s = this.render.sprites[1]
    local sp = this.spawner

    for i = 1, sp.count do
        U.y_wait(store, U.frandom(0.3, 0.75))

        s.hidden = false

        U.animation_start(this, "spawn", nil, store.tick_ts, false)
        U.y_wait(store, fts(4))

        local e = E:create_entity(sp.entity)

        e.pos.x, e.pos.y = this.pos.x, this.pos.y
        e.nav_path.pi = sp.pi
        e.nav_path.spi = sp.spi
        e.render.sprites[1].name = "idle"
        e.unit.spawner_id = this.id

        queue_insert(store, e)
        U.y_animation_wait(this)
    end

    queue_remove(store, this)
end

scripts.mod_alien_screech = {}

function scripts.mod_alien_screech.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead or not target.motion or not target.unit then
        log.debug("mod_alien_screech was not inserted to %", this.modifier.target_id)

        return false
    end
    U.speed_mul(target, this.speed_factor)
    target.unit.damage_factor = target.unit.damage_factor * this.damage_factor
    this.modifier.ts = store.tick_ts

    local s = this.render.sprites[1]

    s.flip_x = target.render.sprites[1].flip_x

    if target.template_name == "enemy_alien_breeder" then
        s.scale = V.v(0.75, 0.75)
        s.anchor.y = 0.35
    end

    return true
end

function scripts.mod_alien_screech.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead or not target.motion or not target.unit then
        return true
    end
    U.speed_div(target, this.speed_factor)
    target.unit.damage_factor = target.unit.damage_factor / this.damage_factor

    return true
end

scripts.eb_efreeti = {}

function scripts.eb_efreeti.get_info(this)
    return {
        damage_min = 500,
        damage_max = 800,
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_efreeti.insert(this, store, script)
    local next, new = P:next_entity_node(this, store.tick_length)

    if not next then
        log.debug("(%s) %s has no valid next node", this.id, this.template_name)

        return false
    end

    U.set_destination(this, next)

    if not this.pos or this.pos.x == 0 and this.pos.y == 0 then
        this.pos = P:node_pos(this.nav_path.pi, this.nav_path.spi, this.nav_path.ni)
    end

    return true
end

function scripts.eb_efreeti.update(this, store, script)
    local a_poly = this.attacks.list[1]
    local a_des = this.attacks.list[2]
    local a_sand = this.attacks.list[3]
    local a_spawn = this.attacks.list[4]
    local powers_ts = store.tick_ts
    local blocker

    local function do_death()
        local death_start_ts = store.tick_ts

        S:queue(this.sound_events.death)
        U.animation_start(this, "death", nil, store.tick_ts, false, 2)

        local image_x, image_y = 206, 198
        local anchor_x, anchor_y = 0.5, 0.1
        local fx_offsets_and_delays = {{V.v(127, 74), 1.1}, {V.v(78, 93), 1.2}, {V.v(108, 133), 1.3},
                                       {V.v(96, 47), 1.4}, {V.v(76, 106), 1.5}, {V.v(129, 101), 1.6},
                                       {V.v(136, 82), 1.7}, {V.v(101, 140), 1.8}, {V.v(79, 64), 1.9}}

        for _, p in pairs(fx_offsets_and_delays) do
            local pos, delay = unpack(p)
            local fx = E:create_entity("fx")

            fx.pos.x = this.pos.x + pos.x - image_x * anchor_x
            fx.pos.y = this.pos.y + pos.y - image_y * anchor_y
            fx.render.sprites[1].name = "efreeti_explosion"
            fx.render.sprites[1].ts = store.tick_ts + delay

            queue_insert(store, fx)
        end

        while store.tick_ts - death_start_ts < 1.9 do
            coroutine.yield()
        end

        this.render.sprites[1].hidden = true

        while store.tick_ts - death_start_ts < 2.2 do
            coroutine.yield()
        end

        local lamp = E:create_entity("decal")

        lamp.render.sprites[1].loop = false
        lamp.render.sprites[1].anchor.y = 0.09
        lamp.render.sprites[1].name = "efreeti_lamp_fall"
        lamp.render.sprites[1].ts = store.tick_ts
        lamp.render.sprites[1].z = Z_EFFECTS
        lamp.pos.x, lamp.pos.y = this.pos.x, this.pos.y

        queue_insert(store, lamp)

        while not U.animation_finished(this, 2) do
            coroutine.yield()
        end
    end

    local function spawn_efreeti_small(pos, subpath)
        local nodes = P:nearest_nodes(pos.x, pos.y)

        if #nodes > 0 then
            local pi, spi, ni = unpack(nodes[1])

            if subpath then
                spi = subpath
            end

            local e = E:create_entity("enemy_efreeti_small")

            e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, spi, ni

            queue_insert(store, e)

            local fx = E:create_entity("fx")

            fx.pos.x, fx.pos.y = pos.x, pos.y
            fx.render.sprites[1].name = "enemy_efreeti_small_raise"
            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].anchor.y = e.render.sprites[1].anchor.y
            fx.render.sprites[1].z = Z_OBJECTS
            fx.render.sprites[1].draw_order = 2

            queue_insert(store, fx)
        else
            log.debug("no nodes nearby %s,%s to spanw enemy_efreeti_small", pos.x, pos.y)
        end
    end

    local function can_polymorph()
        for _, e in pairs(store.soldiers) do
            if not e.health.dead and band(e.vis.bans, F_POLYMORPH) == 0 and
                U.is_inside_ellipse(e.pos, this.pos, a_poly.max_range) and
                not U.is_inside_ellipse(e.pos, this.pos, a_poly.min_range) then
                return true
            end
        end

        return false
    end

    local function do_polymorph()
        local targets = table.filter(store.soldiers, function(_, e)
            return  not e.health.dead  and band(e.vis.bans, F_POLYMORPH) == 0 and
                       U.is_inside_ellipse(e.pos, this.pos, a_poly.max_range) and
                       not U.is_inside_ellipse(e.pos, this.pos, a_poly.min_range)
        end)

        for i = 1, math.min(#targets, a_poly.max_count) do
            local target = targets[i]
            local d = E:create_entity("damage")

            d.damage_type = DAMAGE_EAT
            d.source_id = this.id
            d.target_id = target.id

            queue_damage(store, d)
            spawn_efreeti_small(target.pos)
        end
    end

    local function do_desintegrate()
        local targets = table.filter(store.soldiers, function(_, e)
            return  not e.health.dead and
                       U.is_inside_ellipse(e.pos, this.pos, a_des.max_range)
        end)

        for i = 1, math.min(#targets, a_des.max_count) do
            local target = targets[i]
            local d = E:create_entity("damage")

            d.damage_type = bor(DAMAGE_DISINTEGRATE, DAMAGE_INSTAKILL)
            d.source_id = this.id
            d.target_id = target.id

            queue_damage(store, d)
        end
    end

    local function can_sand()
        for _, e in pairs(store.towers) do
            if not e.tower_holder and not e.tower.blocked and
                V.dist2(e.pos.x, e.pos.y, this.pos.x, this.pos.y) < a_sand.max_range * a_sand.max_range then
                return true
            end
        end

        return false
    end

    local function do_sand()
        local towers = table.filter(store.towers, function(_, e)
            return not e.tower_holder and not e.tower.blocked and
                       V.dist(e.pos.x, e.pos.y, this.pos.x, this.pos.y) < a_sand.max_range
        end)

        for i = 1, math.min(#towers, a_sand.max_count) do
            local t = towers[i]
            local m = E:create_entity(a_sand.mod)

            m.modifier.target_id = t.id
            m.modifier.source_id = this.id
            m.pos = t.pos

            queue_insert(store, m)
        end
    end

    local function do_spawn(spawn_cycle)
        local places = this.health.hp < a_spawn.health_threshold and math.random(3, 4) or 2

        for i = 1, places do
            spawn_efreeti_small(a_spawn.coords[i], km.zmod(spawn_cycle, 3))
        end
    end

    this.phase = "spawn"
    this.health_bar.hidden = true

    local an, af = U.animation_name_facing_point(this, "idle", this.motion.dest)

    U.animation_start(this, an, af, store.tick_ts)

    this.render.sprites[1].ts = store.tick_ts
    this.render.sprites[3].ts = store.tick_ts

    U.y_wait(store, 1.5)
    S:queue(this.sound_events.laugh)

    this.tween.disabled = true

    U.y_animation_play(this, "laugh", nil, store.tick_ts, 6)

    this.health_bar.hidden = false
    this.vis.bans = this.vis.bans_in_battlefield
    this.phase = "loop"

    ::label_235_0::

    while true do
        if this.health.dead then
            this.phase = "dead"

            LU.kill_all_enemies(store, true)
            do_death()
            queue_remove(store, this)
            signal.emit("boss-killed", this)

            return
        end

        if this.unit.is_stunned then
            coroutine.yield()

            powers_ts = store.tick_ts
        else
            if store.tick_ts - powers_ts > this.attacks.cooldown then
                if math.random() < a_sand.chance then
                    if can_sand() then
                        S:queue(this.sound_events.sand)
                        U.animation_start(this, a_sand.animation, nil, store.tick_ts)
                        U.y_wait(store, a_sand.shoot_time)

                        if this.unit.is_stunned then
                            goto label_235_0
                        end

                        do_sand()
                        U.y_animation_wait(this, 2)
                        S:queue(this.sound_events.laugh)
                        U.y_animation_play(this, "laugh", nil, store.tick_ts, 6)

                        goto label_235_1
                    end
                elseif math.random() < a_poly.chance and can_polymorph() then
                    S:queue(this.sound_events.polymorph, {
                        delay = fts(15)
                    })
                    U.animation_start(this, a_poly.animation, nil, store.tick_ts, 1)
                    U.y_wait(store, a_poly.hit_time)

                    if this.unit.is_stunned then
                        goto label_235_0
                    end

                    do_polymorph()
                    U.y_animation_wait(this, 2)

                    goto label_235_1
                end

                S:queue(this.sound_events.spawn, {
                    delay = fts(15)
                })
                U.animation_start(this, a_spawn.animation, nil, store.tick_ts, 1)

                for i = 1, a_spawn.max_count do
                    U.y_wait(store, a_spawn.spawn_time)

                    if this.unit.is_stunned then
                        goto label_235_0
                    end

                    do_spawn(i)
                end

                U.y_animation_wait(this, 2)

                ::label_235_1::

                powers_ts = store.tick_ts
            end

            blocker = U.get_blocker(store, this)

            if blocker and SU.y_wait_for_blocker(store, this, blocker) then
                S:queue(this.sound_events.desintegrate, {
                    delay = fts(15)
                })
                U.animation_start(this, "attack", nil, store.tick_ts, 1)
                U.y_wait(store, a_des.hit_time)

                if this.unit.is_stunned then
                    goto label_235_0
                end

                do_desintegrate()
                U.y_animation_wait(this, 2)
            end

            if not U.get_blocker(store, this) then
                if not SU.y_enemy_walk_step(store, this) then
                    return
                end
            else
                coroutine.yield()
            end
        end
    end
end

scripts.eb_gorilla = {}

function scripts.eb_gorilla.get_info(this)
    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = this.melee.attacks[1].damage_min,
        damage_max = this.melee.attacks[1].damage_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_gorilla.insert(this, store, script)
    if this.melee then
        this.melee.order = U.attack_order(this.melee.attacks)
    end

    return true
end

function scripts.eb_gorilla.update(this, store, script)
    local a_spawn = this.attacks.list[1]
    local a_heal = this.attacks.list[2]
    local a_ranged = this.attacks.list[3]
    local on_tower = false
    local on_tower_ts, blocker

    local function y_jump(from, to, flight_time)
        local from = V.vclone(from)
        local g = -0.9 / (fts(1) * fts(1))

        if not flight_time then
            local dist = V.dist(to.x, to.y, from.x, from.y)

            flight_time = fts(23 + math.floor(dist * 1 / 60))
        end

        local speed = SU.initial_parabola_speed(from, to, flight_time, g)
        local ts = store.tick_ts
        local warped_time = (store.tick_ts - ts) * 2

        while warped_time <= flight_time do
            this.pos.x, this.pos.y = SU.position_in_parabola(warped_time, from, speed, g)

            coroutine.yield()

            warped_time = (store.tick_ts - ts) * 2
        end

        this.pos.x, this.pos.y = to.x, to.y

        coroutine.yield()
    end

    local enter_from = V.vclone(this.pos)
    local enter_to = P:node_pos(this.nav_path)

    U.animation_start(this, "fly", nil, store.tick_ts, true)

    this.render.sprites[1].z = Z_OBJECTS_SKY

    y_jump(enter_from, enter_to, 1)

    this.render.sprites[1].z = Z_OBJECTS

    S:queue(this.sound_events.drop_from_sky)
    U.y_animation_play(this, "jump_down_end", nil, store.tick_ts)
    S:queue(a_spawn.sound)
    U.y_animation_play(this, "call", nil, store.tick_ts)

    a_spawn.ts = store.tick_ts
    a_heal.ts = store.tick_ts
    a_ranged.ts = store.tick_ts
    on_tower_ts = store.tick_ts

    ::label_249_0::

    while true do
        if this.health.dead then
            S:queue(this.sound_events.death)
            LU.kill_all_enemies(store, true)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)

            return
        end

        if this.unit.is_stunned then
            coroutine.yield()
        else
            if on_tower then
                if store.tick_ts - on_tower_ts > this.on_tower_time then
                    local left_side = this.nav_path.pi == 1

                    if not left_side then
                        this.nav_path.ni = this.nav_path.ni + this.jump_down_advance_nodes
                    end

                    this.vis.bans = bor(this.vis.bans, F_FREEZE)

                    U.y_animation_play(this, "jump_down_start", nil, store.tick_ts)
                    U.animation_start(this, "fly", left_side, store.tick_ts, true)

                    this.render.sprites[1].z = Z_OBJECTS_SKY

                    y_jump(this.pos, P:node_pos(this.nav_path))

                    this.render.sprites[1].z = Z_OBJECTS
                    this.render.sprites[1].sort_y_offset = nil

                    S:queue(this.sound_events.drop_from_sky)
                    U.y_animation_play(this, "jump_down_end", nil, store.tick_ts)

                    on_tower = false
                    this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))
                    this.vis.bans = band(this.vis.bans, bnot(F_FREEZE))
                    a_spawn.ts = store.tick_ts

                    goto label_249_0
                end

                if store.tick_ts - this.idle_flip.ts > this.idle_flip.cooldown then
                    this.idle_flip.ts = store.tick_ts
                    this.vis.bans = bor(this.vis.bans, F_FREEZE)

                    U.y_animation_play(this, "tower_flip_start", nil, store.tick_ts)

                    local left_side = this.nav_path.pi == 1

                    if left_side then
                        this.pos.x, this.pos.y = this.tower_pos_right.x, this.tower_pos_right.y
                        this.nav_path.pi = 2
                    else
                        this.pos.x, this.pos.y = this.tower_pos_left.x, this.tower_pos_left.y
                        this.nav_path.pi = 1
                    end

                    this.render.sprites[1].flip_x = left_side

                    U.y_animation_play(this, "tower_flip_end", nil, store.tick_ts)

                    this.vis.bans = band(this.vis.bans, bnot(F_FREEZE))
                end

                if store.tick_ts - a_ranged.ts > a_ranged.cooldown then
                    local left_side = this.nav_path.pi == 1
                    local target = U.find_random_target(store.entities, this.pos, a_ranged.min_range,
                        a_ranged.max_range, a_ranged.vis_flags, a_ranged.vis_bans, function(e)
                            return e and e.pos and
                                       (left_side and e.pos.x < this.pos.x or not left_side and e.pos.x > this.pos.x)
                        end)

                    if target then
                        a_ranged.ts = store.tick_ts

                        U.animation_start(this, "throw_barrel", nil, store.tick_ts)
                        U.y_wait(store, a_ranged.shoot_time)

                        if this.unit.is_stunned then
                            goto label_249_0
                        end

                        local bullet = E:create_entity(a_ranged.bullet)
                        local offset = a_ranged.bullet_start_offset[1]

                        bullet.pos.x, bullet.pos.y = this.pos.x + (left_side and -1 or 1) * offset.x,
                            this.pos.y + offset.y
                        bullet.bullet.from = V.vclone(bullet.pos)
                        bullet.bullet.to = V.v(target.pos.x, target.pos.y)
                        bullet.bullet.target_id = target.id
                        bullet.bullet.rotation_speed = bullet.bullet.rotation_speed * (left_side and 1 or -1)

                        queue_insert(store, bullet)
                        U.y_animation_wait(this)
                    end
                end
            else
                if store.tick_ts - a_spawn.ts > a_spawn.cooldown then
                    a_spawn.ts = store.tick_ts

                    S:queue(a_spawn.sound)
                    U.y_animation_play(this, "call", nil, store.tick_ts)

                    if this.unit.is_stunned then
                        goto label_249_0
                    end

                    for i = 1, a_spawn.max_count do
                        local pi = math.random() < 0.5 and 1 or 2
                        local area = math.random() < 0.7 and 1 or 2
                        local right_side = pi == 2
                        local node_min, node_max = unpack(a_spawn.spawn_node_ranges[pi][area])
                        local ni = math.random(node_min, node_max)
                        local spi = math.random(1, 3)
                        local dest = P:node_pos(pi, spi, ni)
                        local e = E:create_entity(a_spawn.entity)

                        e.pos = right_side and V.v(store.visible_coords.right, dest.y) or
                                    V.v(store.visible_coords.left, dest.y)
                        e.render.sprites[1].flip_x = right_side
                        e.spawn_dest = dest
                        e.delay = 0.3 * (i - 1)

                        queue_insert(store, e)
                    end

                    a_spawn.ts = store.tick_ts

                    coroutine.yield()

                    if this.unit.is_stunned then
                        goto label_249_0
                    end

                    if this.health.dead then
                        goto label_249_0
                    end

                    local other_pi = this.nav_path.pi == 1 and 2 or 1

                    if #P:path(other_pi, 1) - this.nav_path.ni > this.nodes_limit then
                        U.unblock_all(store, this)

                        this.vis.bans = bor(this.vis.bans, F_BLOCK)
                        this.vis.bans = bor(this.vis.bans, F_FREEZE)

                        local fx = E:create_entity("fx_gorilla_boss_jump_smoke")

                        fx.pos = V.vclone(this.pos)
                        fx.render.sprites[1].ts = store.tick_ts + 0.45

                        queue_insert(store, fx)

                        local right_side = this.nav_path.pi == 2

                        U.y_animation_play(this, "jump", right_side, store.tick_ts, 1)
                        S:queue(this.sound_events.jump_to_tower)
                        U.animation_start(this, "fly", right_side, store.tick_ts, true)

                        this.render.sprites[1].z = Z_OBJECTS_SKY

                        if right_side then
                            y_jump(this.pos, this.tower_pos_right)
                        else
                            y_jump(this.pos, this.tower_pos_left)
                        end

                        this.render.sprites[1].z = Z_OBJECTS
                        this.render.sprites[1].sort_y_offset = -35

                        U.y_animation_play(this, "jump_reach", right_side, store.tick_ts, 1)

                        on_tower = true
                        on_tower_ts = store.tick_ts
                        this.idle_flip.ts = store.tick_ts
                        this.vis.bans = band(this.vis.bans, bnot(F_FREEZE))

                        goto label_249_0
                    end
                end

                if store.tick_ts - a_heal.ts > a_heal.cooldown and this.health.hp / this.health.hp_max < 0.9 then
                    a_heal.ts = store.tick_ts
                    this.health.hp = this.health.hp + km.clamp(0, this.health.hp_max, a_heal.points)

                    S:queue(a_heal.sound)

                    local fx = E:create_entity("fx_gorilla_boss_heal")

                    fx.pos = this.pos
                    fx.render.sprites[1].ts = store.tick_ts
                    fx.render.sprites[1].flip_x = this.render.sprites[1].flip_x

                    queue_insert(store, fx)
                    U.y_animation_play(this, "heal", nil, store.tick_ts)

                    goto label_249_0
                end

                blocker = U.get_blocker(store, this)

                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_249_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_249_0
                        end

                        coroutine.yield()
                    end
                end

                if not U.get_blocker(store, this) then
                    if not SU.y_enemy_walk_step(store, this) then
                        return
                    end

                    goto label_249_0
                end
            end

            coroutine.yield()
        end
    end
end

scripts.eb_umbra = {}

function scripts.eb_umbra.get_info(this)
    local b = E:get_template("ray_umbra")
    local min, max = b.bullet.damage_min, b.bullet.damage_max

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = 2 * min,
        damage_max = 2 * max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_umbra.insert(this, store, script)
    this.health_bar.black_bar_hp = this.health.hp_max

    return true
end

function scripts.eb_umbra.update(this, store, script)
    local as = this.attacks.list[1]
    local at = this.attacks.list[2]
    local ars = this.attacks.list[3]
    local art = this.attacks.list[4]
    local ap = this.attacks.list[5]
    local taunt = this.taunt
    local is_in_pieces = false
    local is_at_home = true
    local pieces = {}
    local max_pieces = 10
    local pieces_alive = max_pieces
    local death_cycles = 0
    local teleport_jumps = 0
    local last_jump_center = false
    local last_ray_towers_inner = false
    local piece_arrival_node = 4
    local hp_per_piece = this.health.hp_max / max_pieces
    local body_sid = 1
    local eyes_sid = 2
    local home_node = this.home_node

    local function update_cooldowns()
        if is_at_home then
            as.cooldown = as.cooldowns.at_home[pieces_alive]
            at.cooldown = at.cooldowns.at_home[pieces_alive]
            art.cooldown = art.cooldowns.at_home[pieces_alive]
        else
            as.cooldown = as.cooldowns.on_battlefield[pieces_alive]
            at.cooldown = at.cooldowns.on_battlefield[pieces_alive]
            art.cooldown = art.cooldowns.on_battlefield[pieces_alive]
        end

        as.ts = store.tick_ts
        at.ts = store.tick_ts
        art.ts = store.tick_ts
    end

    local function y_shoot_rays(attack, target, to_offset_y, fake_shot)
        to_offset_y = to_offset_y or 0
        this.render.sprites[eyes_sid].hidden = false

        local start_ts = store.tick_ts

        S:queue(attack.sound)
        U.animation_start(this, attack.animation, nil, store.tick_ts, false, eyes_sid)

        while store.tick_ts - start_ts < attack.shoot_time do
            coroutine.yield()
        end

        for _, o in pairs(attack.bullet_start_offset) do
            local r = E:create_entity(attack.bullet)

            r.bullet.from = V.v(this.pos.x + o.x, this.pos.y + o.y)
            r.bullet.to = V.v(target.pos.x, target.pos.y + to_offset_y)
            r.bullet.source_id = this.id
            r.bullet.target_id = target.id
            r.pos = V.vclone(r.bullet.from)

            if fake_shot then
                r.bullet.hit_fx = "fx_ray_umbra_explosion_smoke"
                r.bullet.damage_type = DAMAGE_NONE
            end

            queue_insert(store, r)
        end

        while not U.animation_finished(this, eyes_sid) do
            coroutine.yield()
        end

        this.render.sprites[eyes_sid].hidden = true
    end

    local function show_taunt(idx, duration, flip_x)
        local t = E:create_entity("decal_umbra_shoutbox")

        t.texts.list[1].text = _(string.format(taunt.format, idx))

        if flip_x then
            t.render.sprites[1].flip_x = true
            t.render.sprites[2].offset.x = -1 * t.render.sprites[2].offset.x
            t.pos = taunt.left_pos
        else
            t.pos = taunt.right_pos
        end

        t.timed.duration = duration
        t.render.sprites[1].ts = store.tick_ts
        t.render.sprites[2].ts = store.tick_ts

        local font_sizes = t.texts.list[1].font_sizes

        if idx == 1 then
            t.texts.list[1].font_size = font_sizes[1]
        elseif idx == 2 then
            t.texts.list[1].font_size = font_sizes[2]
        else
            t.texts.list[1].font_size = font_sizes[3]
        end

        queue_insert(store, t)

        return t
    end

    update_cooldowns()

    this.nav_path = home_node
    this.pos = P:node_pos(this.nav_path)
    this.phase = "intro"

    U.animation_start(this, "idle", nil, store.tick_ts, true, body_sid)
    U.y_wait(store, fts(113))

    local off = V.v(90, 8)
    local fake_target = {}
    local guy = store.level.guy

    fake_target.id = guy.id
    fake_target.pos = V.v(guy.pos.x + off.x, guy.pos.y + off.y)

    y_shoot_rays(ars, fake_target, nil, true)
    U.y_wait(store, 0.6)
    show_taunt(1, 2)
    U.y_wait(store, 2)
    show_taunt(2, 2)
    U.y_wait(store, 2)
    show_taunt(3, 2)
    U.y_wait(store, 2)

    this.health_bar.hidden = false
    this.phase = "loop"

    update_cooldowns()

    while true do
        if is_in_pieces then
            local callback_pieces = ap.callback_pieces[km.clamp(1, 3, death_cycles)]

            while store.tick_ts - ap.ts < ap.cooldown do
                coroutine.yield()

                for i = #pieces, 1, -1 do
                    local p = pieces[i]

                    if pieces_alive <= callback_pieces then
                        goto label_254_0
                    elseif piece_arrival_node > P:nodes_to_goal(p.nav_path) then
                        goto label_254_0
                    elseif p.health.dead then
                        pieces_alive = pieces_alive - 1

                        table.remove(pieces, i)
                        log.debug("died %s,  alive:%s, pieces:%s", p.id, pieces_alive, #pieces)
                    end
                end
            end

            ::label_254_0::

            log.debug("callback_pieces:%s, pieces:%s, pieces_alive:%s", callback_pieces, #pieces, pieces_alive)

            for i = 1, #pieces do
                local p = pieces[i]

                U.unblock_all(store, p)
                SU.remove_modifiers(store, p)

                p.motion.max_speed = p.motion.max_speed_called
                p.motion.real_speed = U.real_max_speed(p)
                SU.stun_dec(p, true)

                p.vis.bans = F_ALL
                p.health.immune_to = DAMAGE_ALL
                p.health_bar.hidden = true
                p.health.dead = false
                p.health.hp = p.health.hp_max
                p.render.sprites[1].hidden = false
                p.call_back = true

                if not p.main_script.co then
                    log.debug("rebooting umbra_piece coroutine")

                    p.main_script.runs = 1
                end
            end

            local recovered_hp = 0
            local pieces_returned = {}
            local recover_pos = P:node_pos(home_node.pi, 1, P:get_end_node(home_node.pi) - piece_arrival_node)

            while #pieces > 0 do
                for i = #pieces, 1, -1 do
                    local p = pieces[i]

                    if piece_arrival_node > P:nodes_to_goal(p.nav_path) then
                        table.remove(pieces, i)
                        table.insert(pieces_returned, p)

                        recovered_hp = recovered_hp + hp_per_piece
                        p.motion.max_speed = 0
                        p.motion.real_speed = U.real_max_speed(p)
                        S:queue("FrontiersFinalBossPiecesRegroup")

                        if this.render.sprites[1].hidden and #pieces_returned == 2 then
                            for _, pr in pairs(pieces_returned) do
                                pr.recovered = true
                                pr.health.dead = true
                                pr.pos = V.vclone(recover_pos)
                            end

                            this.render.sprites[1].hidden = false
                            this.render.sprites[1].scale = V.v(0.5, 0.5)

                            U.animation_start(this, "ball_idle", nil, store.tick_ts, true)
                        elseif #pieces_returned > 2 then
                            local scale = this.render.sprites[1].scale.x

                            scale = km.clamp(0.5, 1, scale + 0.1)
                            this.render.sprites[1].scale.x = scale
                            this.render.sprites[1].scale.y = scale
                            p.recovered = true
                            p.health.dead = true
                            p.pos = V.vclone(recover_pos)
                        end
                    end
                end

                coroutine.yield()
            end

            log.debug("waiting for fuse")
            U.y_wait(store, 0.5)
            log.debug("transform")
            S:queue("FrontiersFinalBossRespawn")

            this.render.sprites[1].scale.x = 1
            this.render.sprites[1].scale.y = 1

            U.y_animation_play(this, "transform", nil, store.tick_ts, 1)

            pieces_alive = #pieces_returned
            this.health.hp = recovered_hp
            this.health.hp_max = recovered_hp
            this.health.dead = false
            this.health.immune_to = DAMAGE_NONE
            this.health_bar.hidden = false
            this.vis.bans = this.vis.bans_at_home
            is_in_pieces = false

            update_cooldowns()

            force_taunt = true

            U.animation_start(this, "idle", nil, store.tick_ts, true, body_sid)
        else
            if this.health.dead then
                LU.kill_all_enemies(store, true)
                SU.remove_modifiers(store, this)
                U.unblock_all(store, this)

                if pieces_alive < ap.min_pieces_to_respawn then
                    this.phase = "death-animation"

                    S:stop_all()
                    S:queue("FrontiersFinalBossDeath")

                    local fx_explosions = {{V.v(99, 103), 0}, {V.v(99, 103), 0.9}, {V.v(99, 103), 1.8},
                                           {V.v(99, 103), 2.7}, {V.v(134, 54), 0.13}, {V.v(134, 54), 1.03},
                                           {V.v(134, 54), 1.93}, {V.v(134, 54), 2.83}, {V.v(147, 104), 0.26},
                                           {V.v(147, 104), 1.16}, {V.v(147, 104), 2.06}, {V.v(147, 104), 2.96},
                                           {V.v(68, 78), 0.4}, {V.v(68, 78), 1.3}, {V.v(68, 78), 2.2},
                                           {V.v(68, 78), 3.1}, {V.v(169, 76), 0.56}, {V.v(169, 76), 1.46},
                                           {V.v(169, 76), 2.33}, {V.v(118, 89), 0.73}, {V.v(118, 89), 1.63},
                                           {V.v(118, 89), 2.5}}
                    local fx_rays = {{V.v(119, 88), 0.96}, {V.v(119, 88), 1.2}, {V.v(119, 88), 1.43},
                                     {V.v(119, 88), 1.63}, {V.v(119, 88), 1.86}}

                    U.animation_start(this, "death", nil, store.tick_ts, true)
                    U.y_wait(store, 3)

                    local image_x, image_y = 238, 176
                    local anchor_x, anchor_y = 0.5, 0.18

                    for _, p in pairs(fx_explosions) do
                        local pos, delay = unpack(p)
                        local fx = E:create_entity("fx")

                        fx.pos.x = this.pos.x + pos.x - image_x * anchor_x
                        fx.pos.y = this.pos.y + pos.y - image_y * anchor_y
                        fx.render.sprites[1].name = "umbra_death_explosion"
                        fx.render.sprites[1].ts = store.tick_ts + delay

                        queue_insert(store, fx)
                    end

                    for _, p in pairs(fx_rays) do
                        local pos, delay = unpack(p)
                        local fx = E:create_entity("fx")

                        fx.pos.x = this.pos.x + pos.x - image_x * anchor_x
                        fx.pos.y = this.pos.y + pos.y - image_y * anchor_y
                        fx.render.sprites[1].name = "umbra_death_rays"
                        fx.render.sprites[1].ts = store.tick_ts + delay

                        queue_insert(store, fx)
                    end

                    local pos, delay = V.v(119, 85), 2.3
                    local fx = E:create_entity("fx")

                    fx.pos.x = this.pos.x + pos.x - image_x * anchor_x
                    fx.pos.y = this.pos.y + pos.y - image_y * anchor_y
                    fx.render.sprites[1].name = "umbra_death_blast_long"
                    fx.render.sprites[1].ts = store.tick_ts + delay

                    queue_insert(store, fx)
                    U.y_wait(store, 2.5)

                    local pos = V.v(119, 80)
                    local fx = E:create_entity("fx_umbra_white_circle")

                    fx.pos.x = this.pos.x + pos.x - image_x * anchor_x
                    fx.pos.y = this.pos.y + pos.y - image_y * anchor_y
                    fx.render.sprites[1].ts = store.tick_ts

                    queue_insert(store, fx)
                    U.y_wait(store, 1)

                    this.phase = "dead"

                    queue_remove(store, this)
                    signal.emit("boss-killed", this)

                    return
                else
                    S:queue("FrontiersFinalBossExplode")

                    this.health_bar.hidden = true
                    this.health.immune_to = DAMAGE_ALL
                    ap.ts = store.tick_ts

                    local fx = E:create_entity("fx_umbra_death_blast")

                    fx.render.sprites[1].name = "short"
                    fx.render.sprites[1].ts = store.tick_ts
                    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y

                    queue_insert(store, fx)

                    pieces = {}

                    for i = 1, pieces_alive do
                        local p = E:create_entity(ap.payload_entity)

                        p.nav_path.pi = table.random(ap.dest_pi)
                        p.nav_path.spi = math.random(1, 3)
                        p.nav_path.ni = math.random(P:get_start_node(p.nav_path.pi) + ap.initial_ni,
                            P:get_end_node(p.nav_path.pi) - ap.limit_ni)
                        p.pos = P:node_pos(p.nav_path)

                        if death_cycles > 0 then
                            p.piece_respawn_delay = p.piece_respawn_delay_repeating
                        end

                        table.insert(pieces, p)

                        local s = E:create_entity(ap.entity)

                        s.pos.x, s.pos.y = this.pos.x, this.pos.y
                        s.pos.x = s.pos.x + math.random(ap.start_offset_x[1], ap.start_offset_x[2])
                        s.pos.y = s.pos.y + math.random(ap.start_offset_y[1], ap.start_offset_y[2])
                        s.bullet.from = V.vclone(s.pos)
                        s.bullet.to = V.vclone(p.pos)

                        local dist = V.dist(s.bullet.from.x, s.bullet.from.y, s.bullet.to.x, s.bullet.to.y)

                        s.bullet.flight_time = s.bullet.flight_time + fts(dist / 30)
                        s.bullet.hit_payload = p
                        s.render.sprites[1].ts = store.tick_ts

                        queue_insert(store, s)
                    end

                    U.y_animation_play(this, "explode", nil, store.tick_ts, 1)

                    this.render.sprites[1].hidden = true
                    this.nav_path = home_node
                    this.pos = P:node_pos(this.nav_path)
                    this.vis.bans = this.vis.bans_in_pieces
                    is_at_home = true
                    is_in_pieces = true
                    death_cycles = death_cycles + 1

                    goto label_254_2
                end
            end

            if is_at_home and (force_taunt or store.tick_ts - taunt.ts > taunt.cooldown) and store.tick_ts - at.ts <
                at.cooldown - 2 then
                force_taunt = nil

                local i = math.random(taunt.start_idx, taunt.end_idx)
                local t = show_taunt(i, taunt.duration, math.random() < 0.5)

                taunt.ts = store.tick_ts + taunt.duration
                taunt.last_id = t.id
            end

            if not this.render.sprites[1].sync_flag or this.render.sprites[1].runs == 0 then
                -- block empty
            else
                if as.cooldown > 0 and store.tick_ts - as.ts > as.cooldown then
                    S:queue("FrontiersFinalBossPortal")
                    U.animation_start(this, as.animation, nil, store.tick_ts, false, body_sid)

                    local nleft = table.random(as.nodes_left)
                    local nright = table.random(as.nodes_right)
                    local nodes = {nleft, nright}

                    for _, n in pairs(nodes) do
                        local s = E:create_entity(as.entity)

                        s.pos = P:node_pos(n[1])
                        s.spawner.allowed_nodes = n
                        s.spawner.count = as.count_min +
                                              math.floor((max_pieces - pieces_alive) * as.add_per_missing_piece)

                        queue_insert(store, s)
                    end

                    while not U.animation_finished(this, body_sid) and not this.health.dead do
                        coroutine.yield()
                    end

                    as.ts = store.tick_ts

                    goto label_254_1
                end

                if store.tick_ts - at.ts > at.cooldown then
                    this.health_bar.hidden = true
                    this.health.ignore_damage = true

                    S:queue("FrontiersFinalBossTeleport")
                    U.y_animation_play(this, "teleport_out", nil, store.tick_ts, 1, body_sid)
                    U.unblock_all(store, this)

                    local jump_node

                    if is_at_home then
                        teleport_jumps = teleport_jumps + 1

                        local idx

                        if last_jump_center and teleport_jumps <= at.max_side_jumps then
                            idx = math.random(2, 3)
                            last_jump_center = false
                        else
                            idx = 1
                            last_jump_center = true
                        end

                        jump_node = at.nodes_battlefield[idx]
                        is_at_home = false

                        if taunt.last_id and store.entities[last_id] then
                            queue_remove(store, store.entities[last_id])

                            taunt.last_id = nil
                        end
                    else
                        jump_node = home_node
                        is_at_home = true
                        force_taunt = true
                    end

                    this.nav_path = jump_node
                    this.pos = P:node_pos(this.nav_path)
                    this.vis.bans = is_at_home and this.vis.bans_at_home or this.vis.bans_in_battlefield

                    U.y_animation_play(this, "teleport_in", nil, store.tick_ts, 1, body_sid)

                    this.health_bar.hidden = false
                    this.health.ignore_damage = is_at_home

                    update_cooldowns()

                    at.ts = store.tick_ts

                    goto label_254_1
                end

                if art.cooldown > 0 and store.tick_ts - art.ts > art.cooldown then
                    local start_ts = store.tick_ts
                    local inner, outer = {}, {}

                    for _, e in pairs(store.towers) do
                        if not e.tower_holder and not e.tower.blocked and
                            (not is_at_home or not table.contains(art.lower_towers, e.tower.holder_id)) and e.pos.y <
                            this.pos.y then
                            if table.contains(art.inner_towers, e.tower.holder_id) then
                                table.insert(inner, e)
                            else
                                table.insert(outer, e)
                            end
                        end
                    end

                    local set

                    if last_ray_towers_inner then
                        set = #outer > 0 and outer or inner
                    else
                        set = #inner > 0 and inner or outer
                    end

                    last_ray_towers_inner = set == inner

                    if #set > 0 then
                        log.debug("Umbra ray set: %s\n outer:%s\n inner:%s", getdump(table.map(set, function(k, v)
                            return v.tower.holder_id
                        end)), getdump(table.map(outer, function(k, v)
                            return v.tower.holder_id
                        end)), getdump(table.map(inner, function(k, v)
                            return v.tower.holder_id
                        end)))

                        local target = set[math.random(1, #set)]

                        S:queue("VeznanHoldCast")
                        y_shoot_rays(art, target, 20)

                        art.ts = start_ts + 2
                    else
                        art.ts = store.tick_ts - art.cooldown + 1
                    end

                    goto label_254_1
                end

                if store.tick_ts - ars.ts > ars.cooldown then
                    local target = U.find_nearest_soldier(store.soldiers, this.pos, ars.min_range, ars.max_range,
                        ars.vis_flags, ars.vis_bans, function(t)
                            return t.pos.y - 10 < this.pos.y
                        end)

                    if target then
                        y_shoot_rays(ars, target)

                        ars.ts = store.tick_ts
                    else
                        ars.ts = store.tick_ts - ars.cooldown + 0.5
                    end
                end

                ::label_254_1::

                U.animation_start(this, "idle", nil, store.tick_ts, true, body_sid)
            end
        end

        ::label_254_2::

        coroutine.yield()
    end
end

scripts.umbra_portal = {}

function scripts.umbra_portal.update(this, store, script)
    local sp = this.spawner
    local s = this.render.sprites[1]
    local spawn_ts

    if sp.animation_start then
        U.y_animation_play(this, sp.animation_start, nil, store.tick_ts, 1)
    end

    if sp.animation_loop then
        U.animation_start(this, sp.animation_loop, nil, store.tick_ts, true)
    end

    for i = 1, sp.count do
        if sp.interrupt then
            break
        end

        local no = table.random(sp.allowed_nodes)
        local spawn = E:create_entity(sp.entity)

        spawn.nav_path.pi = no.pi
        spawn.nav_path.spi = km.zmod(i, 3)
        spawn.nav_path.ni = no.ni + math.random(-sp.ni_var, sp.ni_var)
        spawn.unit.spawner_id = this.id
        spawn.pos = P:node_pos(spawn.nav_path)

        queue_insert(store, spawn)

        if sp.spawn_fx then
            fx = E:create_entity(sp.spawn_fx)
            fx.pos.x, fx.pos.y = spawn.pos.x, spawn.pos.y - 1
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)
        end

        spawn_ts = store.tick_ts

        while store.tick_ts - spawn_ts < sp.cycle_time do
            if sp.interrupt then
                goto label_262_0
            end

            coroutine.yield()
        end
    end

    ::label_262_0::

    if sp.animation_end then
        U.y_animation_play(this, sp.animation_end, nil, store.tick_ts, 1)
    end

    queue_remove(store, this)
end

scripts.enemy_umbra_piece = {}

function scripts.enemy_umbra_piece.update(this, store, script)
    this.health_bar.hidden = true

    U.y_animation_play(this, "fall", nil, store.tick_ts, 1)
    U.y_wait(store, this.piece_respawn_delay)
    S:queue(this.sound_events.raise)
    U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

    this.vis.bans = this.vis.bans_walking
    this.health_bar.hidden = false

    ::label_263_0::

    this.call_back = false

    U.animation_start(this, "idle", nil, store.tick_ts, true)

    ::label_263_1::

    while true do
        if this.recovered then
            U.y_animation_play(this, "fuse", nil, store.tick_ts, 1)
            queue_remove(store, this)

            return
        end

        if this.health.dead then
            coroutine.yield()

            if this.call_back then
                goto label_263_0
            end

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_263_1
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_263_1
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.umbra_guy = {}

function scripts.umbra_guy.update(this, store, script)
    local at = this.attacks.list[1]
    local taunt = this.taunt
    local last_lives = store.lives

    local function show_taunt(idx, duration)
        local t = E:create_entity("decal_umbra_guy_shoutbox")

        t.texts.list[1].text = _(string.format(taunt.format, idx))
        t.pos = taunt.normal_pos
        t.timed.duration = duration
        t.render.sprites[1].ts = store.tick_ts
        t.render.sprites[2].ts = store.tick_ts

        if #t.texts.list[1].text > 40 then
            t.texts.list[1].line_height = t.texts.list[1].line_heights[2]
        else
            t.texts.list[1].line_height = t.texts.list[1].line_heights[1]
        end

        queue_insert(store, t)

        return t
    end

    U.animation_start(this, "taunt", nil, store.tick_ts, true)

    while this.phase ~= "intro" do
        coroutine.yield()
    end

    show_taunt(1, 4)
    U.y_wait(store, 4)
    show_taunt(2, 4)
    U.y_wait(store, 4)

    at.ts = store.tick_ts
    taunt.ts = store.tick_ts
    this.phase = "intro-finished"

    while true do
        if this.phase == "death" then
            this.phase = "death-started"

            show_taunt(50, 3)
            U.animation_start(this, "idle", nil, store.tick_ts, true)
            U.y_wait(store, 4.1)
            U.animation_start(this, "death", nil, store.tick_ts, false)
            U.y_wait(store, fts(49))

            local t = show_taunt(0, fts(58))

            t.pos.x, t.pos.y = taunt.death_pos.x, taunt.death_pos.y

            U.y_animation_wait(this)
            queue_remove(store, this)

            return
        end

        if last_lives ~= store.lives and store.tick_ts - taunt.ts > taunt.cooldown / 2 then
            last_lives = store.lives

            local i = math.random(taunt.lost_life_idx[1], taunt.lost_life_idx[2])
            local t = show_taunt(i, taunt.duration)

            U.animation_start(this, "taunt", nil, store.tick_ts, true)
            U.y_wait(store, taunt.duration)

            taunt.ts = store.tick_ts

            if store.tick_ts - at.ts + 2 > at.cooldown then
                at.ts = at.ts + 2
            end

            goto label_264_0
        end

        if store.tick_ts - taunt.ts > taunt.cooldown then
            local i = math.random(taunt.normal_idx[1], taunt.normal_idx[2])
            local t = show_taunt(i, taunt.duration)

            U.animation_start(this, "taunt", nil, store.tick_ts, true)
            U.y_wait(store, taunt.duration)

            taunt.ts = store.tick_ts

            if store.tick_ts - at.ts + 2 > at.cooldown then
                at.ts = at.ts + 2
            end

            goto label_264_0
        end

        if store.wave_group_number > 0 and store.tick_ts - at.ts > at.cooldown then
            local target = U.find_random_target(store.entities, this.pos, 0, at.max_range, at.vis_flags, at.vis_bans)

            if not target then
                -- block empty
            else
                local start_ts = store.tick_ts

                log.debug(">>> %s: umbra_guy firing at (%s) %s", store.tick_ts, target.id, target.template_name)

                local i = math.random(taunt.attack_idx[1], taunt.attack_idx[2])

                show_taunt(i, taunt.attack_duration)

                taunt.ts = store.tick_ts + taunt.attack_duration

                U.animation_start(this, at.animation, ni, store.tick_ts, false)
                U.y_wait(store, at.shoot_time)

                local off = at.bullet_start_offset
                local toff = V.v(0, 0)

                if target.unit and target.unit.hit_offset then
                    toff.x, toff.y = target.unit.hit_offset.x, target.unit.hit_offset.y
                end

                local r = E:create_entity(at.bullet)

                r.bullet.from = V.v(this.pos.x + off.x, this.pos.y + off.y)
                r.bullet.to = V.v(target.pos.x + toff.x, target.pos.y + toff.y)
                r.bullet.source_id = this.id
                r.bullet.target_id = target.id
                r.pos = V.vclone(r.bullet.from)

                queue_insert(store, r)
                U.y_animation_wait(this)

                at.ts = store.tick_ts

                if store.tick_ts - taunt.ts + 2 > taunt.cooldown then
                    taunt.ts = taunt.ts + 2
                end
            end
        end

        ::label_264_0::

        U.animation_start(this, "idle", nil, store.tick_ts, true)
        coroutine.yield()
    end
end

scripts.eb_leviathan = {}

function scripts.eb_leviathan.get_info(this)
    return {
        damage_min = 500,
        damage_max = 800,
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_leviathan.insert(this, store, script)
    local next, new = P:next_entity_node(this, store.tick_length)

    if not next then
        log.debug("(%s) %s has no valid next node", this.id, this.template_name)

        return false
    end

    U.set_destination(this, next)

    if not this.pos or this.pos.x == 0 and this.pos.y == 0 then
        this.pos = P:node_pos(this.nav_path.pi, this.nav_path.spi, this.nav_path.ni)
    end

    return true
end

function scripts.eb_leviathan.update(this, store, script)
    local sid = 2
    local a_t = this.attacks.list[1]
    local tentacles = {}
    local tentacle_seq_idx = 1
    local tentacle_seq = this.tentacle_seq
    local tentacle_pos = this.tentacle_pos

    local function do_death()
        S:queue(this.sound_events.death)
        U.animation_start(this, "death", nil, store.tick_ts, false)

        this.render.sprites[1].hidden = true

        local fxs = {{V.v(-50, 35), fts(20)}, {V.v(-22, 49), fts(22)}, {V.v(-15, 16), fts(22)}, {V.v(30, 47), fts(24)},
                     {V.v(26, 10), fts(24)}, {V.v(3, 64), fts(26)}, {V.v(-33, 31), fts(27)}, {V.v(49, 53), fts(29)},
                     {V.v(48, 31), fts(31)}, {V.v(-38, 55), fts(33)}, {V.v(-14, 59), fts(36)}, {V.v(-3, 41), fts(36)},
                     {V.v(28, 48), fts(36)}, {V.v(-2, 37), fts(39)}, {V.v(4, 66), fts(39)}, {V.v(19, 53), fts(39)},
                     {V.v(3, 63), fts(45)}, {V.v(-25, 50), fts(45)}, {V.v(-18, 74), fts(45)}, {V.v(12, 38), fts(45)},
                     {V.v(47, 41), fts(45)}, {V.v(3, 44), fts(50)}, {V.v(-6, 59), fts(50)}, {V.v(12, 59), fts(50)},
                     {V.v(-4, 64), fts(58)}, {V.v(16, 59), fts(58)}, {V.v(3, 42), fts(58)}}
        local fx_scale = 1

        for i, p in ipairs(fxs) do
            fx_scale = fx_scale - (i % 5 == 0 and 0.1 or 0)

            local offset, delay = unpack(p)
            local fx = E:create_entity("fx_explosion_water")

            fx.pos.x = this.pos.x + offset.x
            fx.pos.y = this.pos.y + offset.y - 15
            fx.render.sprites[1].ts = store.tick_ts + delay
            fx.render.sprites[1].scale = V.v(fx_scale, fx_scale)

            queue_insert(store, fx)
        end

        U.y_animation_wait(this, sid)
    end

    this.phase = "spawn"

    U.sprites_hide(this)

    this.health_bar.hidden = true

    local fx = E:create_entity("fx_leviathan_incoming")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)
    U.y_wait(store, 3)
    S:queue("RTBossSpawn")

    this.render.sprites[sid].hidden = nil

    local an, af = U.animation_name_facing_point(this, "spawn", this.motion.dest)

    U.y_animation_play(this, an, af, store.tick_ts, 1, sid)

    local an, af = U.animation_name_facing_point(this, "idle", this.motion.dest)

    U.animation_start(this, an, af, store.tick_ts, true, sid)

    this.render.sprites[1].hidden = nil
    this.health_bar.hidden = nil
    this.phase = "loop"
    this.vis.bans = this.vis.bans_in_battlefield
    a_t.ts = store.tick_ts

    ::label_268_0::

    while true do
        if this.health.dead then
            this.phase = "dead"

            LU.kill_all_enemies(store, true)

            for _, t in pairs(tentacles) do
                t.interrupt = true
            end

            do_death()
            queue_remove(store, this)
            signal.emit("boss-killed", this)

            return
        end

        if this.unit.is_stunned then
            coroutine.yield()
        else
            if store.tick_ts - a_t.ts > a_t.cooldown then
                local seq = tentacle_seq[tentacle_seq_idx]

                tentacle_seq_idx = km.zmod(tentacle_seq_idx + 1, #tentacle_seq)

                for _, idx in pairs(seq) do
                    local tp = tentacle_pos[idx]
                    local e = E:create_entity("leviathan_tentacle")

                    e.pos.x, e.pos.y = tp[1], tp[2]
                    e.flip = tp[3]

                    LU.queue_insert(store, e)
                    table.insert(tentacles, e)
                    U.y_wait(store, U.frandom(0.1, 0.2))
                end

                while #tentacles > 0 do
                    U.y_wait(store, 0.25)

                    if this.health.dead then
                        goto label_268_0
                    end

                    for i = #tentacles, 1, -1 do
                        local t = tentacles[i]

                        if not store.entities[t.id] then
                            table.remove(tentacles, i)
                        end
                    end
                end

                a_t.ts = store.tick_ts
            end

            if not SU.y_enemy_walk_step(store, this) then
                return
            end
        end

        if false then
            coroutine.yield()
        end
    end
end

scripts.leviathan_tentacle = {}

function scripts.leviathan_tentacle.update(this, store)
    local s = this.render.sprites[1]

    s.flip_x = this.flip

    local search_pos = V.v(this.pos.x + (this.flip and -1 or 1) * this.search_off_x, this.pos.y)

    S:queue("RTBossTentacle")
    U.y_animation_play(this, "show", nil, store.tick_ts)
    U.animation_start(this, "wiggle", nil, store.tick_ts, true)

    local start_ts = store.tick_ts

    while not this.interrupt and store.tick_ts - start_ts < this.duration do
        U.y_wait(store, 2)

        local targets = table.filter(store.towers, function(k, e)
            return
                e and not e.tower_holder and e.tower.type ~= "build_animation" and not e.tower.blocked and
                    not table.contains(this.tower_bans, e.template_name) and
                    U.is_inside_ellipse(e.pos, search_pos, this.range)
        end)

        if #targets > 0 then
            local target = targets[1]

            SU.tower_block_inc(target)
            S:queue("RTBossTentacleAttack")
            U.y_animation_play(this, "attack", nil, store.tick_ts)
            U.animation_start(this, "hold", nil, store.tick_ts, true)

            start_ts = store.tick_ts

            while not this.interrupt and store.tick_ts - start_ts < this.duration do
                coroutine.yield()
            end

            SU.tower_block_dec(target)
            U.y_animation_play(this, "release", nil, store.tick_ts)

            break
        end
    end

    U.y_animation_play(this, "hide", nil, store.tick_ts)
    queue_remove(store, this)
end

scripts.eb_dracula = {}

-- function scripts.eb_dracula.get_info(this)
--     return {
--         damage_min = 150,
--         damage_max = 200,
--         type = STATS_TYPE_ENEMY,
--         hp = this.health.hp,
--         hp_max = this.health.hp_max,
--         armor = this.health.armor,
--         magic_armor = this.health.magic_armor,
--         lives = this.enemy.lives_cost
--     }
-- end

function scripts.eb_dracula.insert(this, store, script)
    this.melee.order = U.attack_order(this.melee.attacks)

    return true
end

function scripts.eb_dracula.can_lifesteal(this, store, attack, target)
    return target.template_name ~= "soldier_death_rider" and target.template_name ~= "soldier_skeleton" and
               target.template_name ~= "soldier_skeleton_knight" and target.template_name ~= "soldier_frankenstein" and target.template_name ~= "hero_vampiress"
end

function scripts.eb_dracula.update(this, store, script)
    local function y_fly_to(pos)
        U.animation_start(this, "bat_fly", nil, store.tick_ts, true)
        U.set_destination(this, pos)

        this.motion.max_speed = this.motion.max_speed_bat
        this.motion.real_speed = U.real_max_speed(this)
        while not this.motion.arrived do
            U.walk(this, store.tick_length)
            coroutine.yield()
        end

        local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {this.nav_path.pi})

        this.nav_path.ni = nodes[1][3]
        this.motion.max_speed = this.motion.max_speed_default
        this.motion.real_speed = U.real_max_speed(this)
    end

    this.phase = "intro"

    y_fly_to(V.v(520, 590))
    U.y_animation_play(this, "bat_exit", nil, store.tick_ts)
    U.animation_start(this, "idle", nil, store.tick_ts, true)

    local t = E:create_entity("decal_dracula_shoutbox")

    t.texts.list[1].text = _("DRACULA_TAUNT_FIGHT_0001")
    t.pos.x, t.pos.y = this.pos.x - 1, this.pos.y - 57
    t.timed.duration = 4.7
    t.render.sprites[1].ts = store.tick_ts
    t.render.sprites[2].ts = store.tick_ts

    queue_insert(store, t)
    U.y_wait(store, t.timed.duration + 1)

    this.phase = "fight"

    ::label_275_0::

    while true do
        if this.health.dead then
            U.unblock_all(store, this)

            if this.phase == "fight" then
                this.nav_path.pi = 3
                this.health_bar.hidden = true

                local _vis_bans = this.vis.bans

                this.vis.bans = bor(this.vis.bans, F_ALL)

                y_fly_to(V.v(525, 540))
                y_fly_to(V.v(525, 790))

                this.vis.bans = _vis_bans
                this.phase = "angry"
                this.health_bar.hidden = nil
                this.health.hp = this.health.hp_max
                this.health.dead = false
                this.motion.max_speed = this.motion.max_speed_angry
                this.motion.real_speed = U.real_max_speed(this)
                local e = E:create_entity("dracula_damage_aura")
                e.aura.source_id = this.id
                queue_insert(store, e)
            else
                this.phase = "dead"

                LU.kill_all_enemies(store, true)
                S:stop_all()
                S:queue(this.sound_events.death)
                U.y_animation_play(this, "death", nil, store.tick_ts)
                signal.emit("boss-killed", this)

                return true
            end
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local ok, blocker = SU.y_enemy_walk_until_blocked(store, this)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_275_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_275_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.dracula_damage_aura = {}

function scripts.dracula_damage_aura.update(this, store)
    local a = this.aura

    a.ts = store.tick_ts

    local last_ts = store.tick_ts
    local source = store.entities[a.source_id]

    if not source then
        queue_remove(store, this)

        return
    end

    this.pos = source.pos

    while not source.health.dead and source.enemy.can_do_magic do
        if store.tick_ts - last_ts >= a.cycle_time then
            local dt = store.tick_ts - last_ts

            last_ts = store.tick_ts

            local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

            if targets then
                for _, target in pairs(targets) do
                    local value = math.random(a.dps_min, a.dps_max)

                    value = value * dt * (target.hero and a.hero_damage_factor or 1)

                    if a.dist_factor_min_radius then
                        local dist_factor = U.dist_factor_inside_ellipse(target.pos, this.pos, a.radius,
                            a.dist_factor_min_radius)

                        value = math.ceil(value * (1 - dist_factor))
                    end

                    local d = E:create_entity("damage")

                    d.damage_type = a.damage_type
                    d.value = value
                    d.target_id = target.id
                    d.source_id = this.id

                    queue_damage(store, d)
                end
            end
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.mod_dracula_lifesteal = {}

function scripts.mod_dracula_lifesteal.update(this, store)
    local m = this.modifier
    local source = store.entities[m.source_id]
    local target = store.entities[m.target_id]

    m.ts = store.tick_ts

    local last_ts = store.tick_ts

    SU.stun_inc(target)

    while not source.health.dead and store.tick_ts - m.ts < m.duration do
        if store.tick_ts - last_ts > this.cycle_time then
            last_ts = store.tick_ts
            source.health.hp = km.clamp(0, source.health.hp_max, source.health.hp + this.heal_hp)
        end

        coroutine.yield()
    end

    SU.stun_dec(target)

    local d = E:create_entity("damage")

    d.value = this.damage
    d.source_id = this.id
    d.target_id = target.id
    d.damage_type = target.hero and DAMAGE_TRUE or DAMAGE_INSTAKILL

    queue_damage(store, d)
    queue_remove(store, this)
end

scripts.eb_saurian_king = {}

function scripts.eb_saurian_king.get_info(this)
    local m = E:get_template("mod_saurian_king_tongue")
    local min, max = m.modifier.damage_min, m.modifier.damage_max

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_saurian_king.insert(this, store, script)
    this.melee.order = U.attack_order(this.melee.attacks)

    return true
end

function scripts.eb_saurian_king.update(this, store, script)
    local ha = this.timed_attacks.list[1]

    local function ready_to_hammer()
        return enemy_ready_to_magic_attack(this, store, ha)
    end

    local function hammer_hit(idx)
        S:queue("SaurianKingBossQuake", {
            delay = fts(4)
        })

        local a = E:create_entity("aura_screen_shake")

        a.aura.amplitude = idx / #ha.max_damages

        queue_insert(store, a)

        local dmin, dmax = ha.min_damages[idx], ha.max_damages[idx]
        local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, ha.damage_radius, ha.vis_flags,
            ha.vis_bans)

        if targets then
            for _, target in pairs(targets) do
                local dist_factor = U.dist_factor_inside_ellipse(target.pos, this.pos, ha.damage_radius,
                    ha.max_damage_radius)
                local d = E:create_entity("damage")

                d.damage_type = ha.damage_type
                d.value = math.ceil(dmax - (dmax - dmin) * dist_factor)
                d.target_id = target.id
                d.source_id = this.id

                queue_damage(store, d)
            end
        end

        local fx = E:create_entity("decal_saurian_king_hammer")
        local o = ha.fx_offsets[km.zmod(idx, 2)]

        fx.pos = V.v(this.pos.x + o.x * (this.render.sprites[1].flip_x and -1 or 1), o.y + this.pos.y)
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end

    ha.ts = store.tick_ts

    ::label_281_0::

    while true do
        if this.health.dead then
            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)

            return true
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)

            ha.ts = store.tick_ts

            coroutine.yield()
        else
            if ready_to_hammer() then
                U.y_animation_play(this, ha.animations[1], nil, store.tick_ts)

                for i = 1, #ha.max_damages / 2 do
                    if this.health.dead then
                        goto label_281_1
                    end

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    U.animation_start(this, ha.animations[2], nil, store.tick_ts)
                    S:queue(ha.sound, {
                        delay = fts(3)
                    })
                    U.y_wait(store, ha.hit_times[1])

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    hammer_hit(2 * i - 1)
                    S:queue(ha.sound, {
                        delay = fts(10)
                    })
                    U.y_wait(store, ha.hit_times[2])

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    hammer_hit(2 * i)
                    U.y_animation_wait(this)
                end

                ha.ts = store.tick_ts
            end

            ::label_281_1::

            local ok, blocker = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_hammer()
            end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_281_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_hammer() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_281_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.mod_saurian_king_tongue = {}

function scripts.mod_saurian_king_tongue.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        return false
    end

    local d = E:create_entity("damage")

    d.damage_type = target.hero and DAMAGE_TRUE or DAMAGE_EAT
    d.value = math.random(m.damage_min, m.damage_max)
    d.target_id = target.id
    d.source_id = this.id

    queue_damage(store, d)

    return false
end

scripts.enemy_gorilla_small = {}

function scripts.enemy_gorilla_small.insert(this, store, script)
    local nodes = P:nearest_nodes(this.pos.x, this.pos.y)

    if #nodes < 1 then
        log.error("could not insert enemy_gorilla_small: no nodes near %s,%s", this.pos.x, this.pos.y)

        return false
    end

    this.nav_path.pi = nodes[1][1]
    this.nav_path.spi = nodes[1][2]
    this.nav_path.ni = nodes[1][3] + 3

    return scripts.enemy_basic.insert(this, store, script)
end

scripts.gorilla_small_liana = {}

function scripts.gorilla_small_liana.update(this, store, script)
    this.render.sprites[1].hidden = true

    U.y_wait(store, this.delay)

    this.render.sprites[1].hidden = false
    this.render.sprites[1].ts = store.tick_ts

    local right_side = this.render.sprites[1].flip_x

    U.y_wait(store, this.spawn_time - store.tick_length)

    local spawn = E:create_entity(this.spawn_name)
    local o = right_side and this.spawn_offset[1] or this.spawn_offset[2]

    spawn.pos.x, spawn.pos.y = this.pos.x + o.x, this.pos.y + o.y
    spawn.bullet.from = V.vclone(spawn.pos)
    spawn.bullet.to = V.vclone(this.spawn_dest)
    spawn.render.sprites[1].flip_x = right_side

    queue_insert(store, spawn)
    U.y_animation_wait(this)
    queue_remove(store, this)
end

scripts.decal_tunnel_light = {}

function scripts.decal_tunnel_light.update(this, store, script)
    while true do
        local empty = true

        for _, id in pairs(this.track_ids) do
            local e = store.entities[id]

            if #e.tunnel.picked_enemies > 0 then
                empty = false

                break
            end
        end

        this.render.sprites[1].hidden = empty

        coroutine.yield()
    end
end

scripts.decal_black_dragon = {}

function scripts.decal_black_dragon.update(this, store, script)
    local image_x = 192
    local start_x = store.visible_coords.left - image_x / 2
    local end_x = store.visible_coords.right + image_x / 2
    local wakeup_ts = 0
    local wakeup_cooldown = math.random(this.wakeup_cooldown_min, this.wakeup_cooldown_max)
    local force_wakeup = false
    local flame_comp_x = 180
    local fire_comp_x = 120
    local ps_flame_offset = V.v(-60, 88)
    local ps_fire_offset = V.v(-115, 0)
    local ps_flame = E:create_entity("ps_black_dragon_flame")

    ps_flame.particle_system.track_id = this.id
    ps_flame.particle_system.emit = false
    ps_flame.particle_system.track_offset = V.vclone(ps_flame_offset)

    queue_insert(store, ps_flame)

    local ps_fire = E:create_entity("ps_black_dragon_fire")

    ps_fire.particle_system.track_id = this.id
    ps_fire.particle_system.emit = false
    ps_fire.particle_system.track_offset = V.vclone(ps_fire_offset)

    queue_insert(store, ps_fire)

    local s = this.render.sprites[1]
    local zzz = this.render.sprites[2]
    local shadow = this.render.sprites[3]
    local flame_hit = this.render.sprites[4]
    local ma = this.attacks.list[1]
    local shadow_offset = 49
    local shadow_ref_height = 50

    shadow.scale = V.v(1, 1)

    local function update_shadow()
        local dy = this.pos.y - this.sleep_pos.y
        local scale = km.clamp(0, 1, 1 - dy / shadow_ref_height)

        shadow.scale.x, shadow.scale.y = scale, scale
        shadow.offset.y = shadow_offset - dy
    end

    ::label_173_0::

    while true do
        if this.attack_requested then
            local ar = this.attack_requested
            local ap = this.dragon_paths[ar.path]

            this.attack_requested = nil
            shadow.hidden = false

            update_shadow()
            S:queue(this.sound_events.wakeup, {
                delay = fts(13)
            })
            U.y_animation_play(this, "takeoff", nil, store.tick_ts, 1, 1)

            this.can_steal_gold = true

            U.animation_start(this, "flying", nil, store.tick_ts, true, 1)

            this.render.sprites[1].sort_y_offset = -200
            U.update_max_speed(this, this.speed_takeoff)
            U.set_destination(this, V.v(150, REF_H + 100))

            while not this.motion.arrived do
                U.walk(this, store.tick_length)
                update_shadow()
                coroutine.yield()
            end

            shadow.hidden = true

            local flip = start_x < end_x

            ps_flame.particle_system.track_offset.x = ps_flame_offset.x * (flip and -1 or 1)
            ps_fire.particle_system.track_offset.x = ps_fire_offset.x * (flip and -1 or 1)
            flame_hit.flip_x = flip
            s.flip_x = flip
            this.pos.x, this.pos.y = start_x, ap.y
            U.update_max_speed(this, this.speed_fly)
            U.set_destination(this, V.v(end_x, ap.y))

            local flame_on, fire_on = false, false
            local flame_i, flame_x = next(ap.x_ranges)
            local fire_i, fire_x = next(ap.x_ranges)

            s.loop_forced = true

            while not this.motion.arrived do
                if flame_x and flame_x < this.pos.x + flame_comp_x then
                    flame_i, flame_x = next(ap.x_ranges, flame_i)
                    flame_on = not flame_on

                    if flame_on then
                        S:queue(this.sound_events.fire)

                        ps_flame.particle_system.emit = true

                        U.animation_start(this, "firing", nil, store.tick_ts, true, 1)
                    else
                        ps_flame.particle_system.emit = false

                        U.animation_start(this, "flying", nil, store.tick_ts, true, 1)
                    end
                end

                if fire_x and fire_x < this.pos.x + fire_comp_x then
                    fire_i, fire_x = next(ap.x_ranges, fire_i)
                    fire_on = not fire_on
                    ps_fire.particle_system.emit = fire_on
                    flame_hit.hidden = not fire_on

                    if not fire_on then
                        local fx = E:create_entity("fx_black_dragon_flame_hit")

                        fx.pos.x, fx.pos.y = this.pos.x + (flip and 1 or -1) * flame_hit.offset.x,
                            this.pos.y + flame_hit.offset.y
                        fx.render.sprites[1].ts = store.tick_ts

                        queue_insert(store, fx)
                    end
                end

                if fire_on then
                    local towers = table.filter(store.towers, function(_, e)
                        return e.tower and not e.tower_holder and
                                   V.dist(e.pos.x, e.pos.y, this.pos.x + fire_comp_x, this.pos.y) < ma.range and
                                   not e.tower.blocked
                    end)

                    for i, tower in ipairs(towers) do
                        local m = E:create_entity(ma.mod)

                        m.pos = tower.pos
                        m.modifier.target_id = tower.id
                        m.modifier.source_id = this.id
                        m.modifier.duration = math.random(ar.min_time, ar.max_time)

                        queue_insert(store, m)
                    end
                end

                U.walk(this, store.tick_length)
                coroutine.yield()
            end

            s.loop_forced = false

            U.y_wait(store, 2)

            this.can_steal_gold = false
            shadow.hidden = false

            update_shadow()
            U.animation_start(this, "flying", false, store.tick_ts, true, 1)

            this.pos.x, this.pos.y = this.sleep_pos.x - 5, this.sleep_pos.y + 116
            U.update_max_speed(this, this.speed_takeoff)
            U.set_destination(this, this.sleep_pos)

            while not this.motion.arrived do
                U.walk(this, store.tick_length)
                update_shadow()
                coroutine.yield()
            end

            U.y_animation_play(this, "land", nil, store.tick_ts, 1, 1)
            U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

            shadow.hidden = false
            this.render.sprites[1].sort_y_offset = 0
        elseif force_wakeup or wakeup_cooldown < store.tick_ts - wakeup_ts then
            force_wakeup = nil
            wakeup_ts = store.tick_ts

            S:queue(this.sound_events.wakeup, {
                delay = fts(13)
            })
            U.y_animation_play(this, "wakeup", nil, store.tick_ts, 1, 1)

            wakeup_cooldown = math.random(this.wakeup_cooldown_min, this.wakeup_cooldown_max)
        else
            this.ui.clicked = nil
            zzz.hidden = false
            zzz.alpha = 255

            U.animation_start(this, "zzz", nil, store.tick_ts, false, 2)

            while not U.animation_finished(this, 2) do
                if this.ui.clicked then
                    this.ui.clicked = nil
                    this.tween.disabled = false
                    this.tween.props[1].time_offset = zzz.ts - store.tick_ts

                    U.y_wait(store, this.tween.props[1].keys[2][1])

                    this.tween.disabled = true
                    force_wakeup = true

                    goto label_173_0
                end

                coroutine.yield()
            end

            zzz.hidden = true
        end

        coroutine.yield()
    end
end

scripts.button_steal_dragon_gold = {}

function scripts.button_steal_dragon_gold.update(this, store, script)
    this.already_stolen = false

    while true do
        if this.ui.clicked then
            this.ui.clicked = nil

            if this.dragon.can_steal_gold and not this.already_stolen then
                this.already_stolen = true

                local gold_inc = math.floor(this.gold_to_steal / 10)

                for i = 1, 10 do
                    local fx = E:create_entity(this.fx)

                    fx.pos.x, fx.pos.y = this.pos.x + this.ui.click_rect.size.x / 2,
                        this.pos.y + this.ui.click_rect.size.y / 2
                    fx.render.sprites[1].ts = store.tick_ts
                    fx.tween.props[2] = E:clone_c("tween_prop")
                    fx.tween.props[2].name = "offset"
                    fx.tween.props[2].keys = {{0, V.v(0, 0)}, {0.8, V.v(10, 0)}}

                    queue_insert(store, fx)

                    store.player_gold = store.player_gold + gold_inc

                    U.y_wait(store, fts(5))
                end
            end
        end

        coroutine.yield()
    end
end

scripts.decal_umbra_crystals = {}

function scripts.decal_umbra_crystals.update(this, store, script)
    while this.phase ~= "crack" do
        coroutine.yield()
    end

    S:queue("FrontiersFinalBossSpawnCrack")

    this.render.sprites[2].ts = store.tick_ts + 0.19
    this.render.sprites[3].ts = store.tick_ts + 0.73
    this.render.sprites[4].ts = store.tick_ts + 1.2
    this.render.sprites[2].hidden = false
    this.render.sprites[3].hidden = false
    this.render.sprites[4].hidden = false

    U.y_wait(store, 2)
    U.animation_start(this, "spawn", nil, store.tick_ts, false, 1)
    U.y_wait(store, 2.05)

    this.render.sprites[2].hidden = true
    this.render.sprites[3].hidden = true
    this.render.sprites[4].hidden = true

    U.y_wait(store, 0.05)
    S:queue("FrontiersFinalBossSpawnExplode")

    local fx_ice_pieces = {{V.v(-1, 0), false, 0}, {V.v(-9, 25), false, 0.06}, {V.v(4, -14), false, 0.13},
                           {V.v(-1, 0), true, 0}, {V.v(-9, 25), true, 0.06}, {V.v(4, -14), true, 0.13}}

    for _, p in pairs(fx_ice_pieces) do
        local off, flip, delay = unpack(p)
        local fx = E:create_entity("umbra_crystals_piece")

        fx.pos.x, fx.pos.y = this.pos.x + off.x, this.pos.y + off.y
        fx.render.sprites[1].flip_x = flip
        fx.render.sprites[1].ts = store.tick_ts + delay

        queue_insert(store, fx)
    end
end

scripts.decal_tusken = {}

function scripts.decal_tusken.update(this, store, script)
    local a = this.bullet_attack

    a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

    while true do
        U.animation_start(this, "idle", nil, store.tick_ts)

        local targets = table.filter(store.soldiers, function(_, e)
            return e.soldier.target_id and not e.health.dead and
                       U.is_inside_ellipse(e.pos, this.target_center, a.max_range)
        end)

        if #targets == 0 then
            U.y_wait(store, 1)
        else
            local attack_ts = store.tick_ts
            local target = targets[1]

            if math.random() < 0.7 then
                target = store.entities[target.soldier.target_id]
            end

            if target and target.health and not target.health.dead then
                local b = E:create_entity(a.bullet)

                b.bullet.from = V.v(this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y)
                b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
                b.bullet.target_id = target.id
                b.bullet.source_id = this.id
                b.pos = V.vclone(b.bullet.from)

                U.animation_start(this, a.animation, nil, store.tick_ts)
                S:queue("SpecialTusken", {
                    delay = fts(19)
                })
                U.y_wait(store, a.shoot_time)
                queue_insert(store, b)
                S:queue("ShotgunSound")
                U.y_animation_wait(this)
                U.y_wait(store, a.cooldown - (store.tick_ts - attack_ts))
            end
        end
    end
end

scripts.sand_worm = {}

function scripts.sand_worm.update(this, store, script)
    local s = this.render.sprites[1]
    local a = this.area_attack

    s.hidden = true

    while true do
        U.y_wait(store, a.cooldown / 2)

        ::label_145_0::

        U.y_wait(store, a.cooldown / 2)

        local best_count = -1
        local target

        for _, ce in pairs(store.soldiers) do
            if ce.soldier.target_id and not ce.health.dead and band(ce.vis.flags, a.vis_bans) == 0 and
                band(ce.vis.bans, a.vis_flags) == 0 and P:valid_node_nearby(ce.pos.x, ce.pos.y) then
                local nearby = table.filter(store.soldiers, function(_, e)
                    return
                        e.soldier.target_id and e ~= ce and not e.health.dead and e.vis and
                            band(e.vis.flags, a.vis_bans) == 0 and band(e.vis.bans, a.vis_flags) == 0 and
                            U.is_inside_ellipse(e.pos, ce.pos, a.max_range)
                end)

                if best_count < #nearby then
                    target = ce
                end
            end
        end

        if not target then
            local targets = table.filter(store.soldiers, function(k, v)
                return not v.health.dead and band(v.vis.flags, a.vis_bans) == 0 and
                           band(v.vis.bans, a.vis_flags) == 0 and v.template_name ~= "soldier_djinn" and v.template_name ~=
                           "soldier_legionnaire" and P:valid_node_nearby(v.pos.x, v.pos.y)
            end)

            if #targets > 0 then
                target = table.random(targets)
            end
        end

        if not target then
            goto label_145_0
        end

        local nodes = P:nearest_nodes(target.pos.x, target.pos.y)

        if #nodes < 1 then
            goto label_145_0
        end

        local attack_pos = P:node_pos(nodes[1][1], 1, nodes[1][3])
        local fx = E:create_entity("fx_sand_worm_incoming")

        fx.pos = attack_pos
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
        S:queue("SpecialWormDirtSound")
        U.y_wait(store, a.hit_time)
        S:stop("SpecialWormDirtSound")
        queue_remove(store, fx)

        this.pos = attack_pos
        s.hidden = false

        U.animation_start(this, a.animation, nil, store.tick_ts, false)
        S:queue("SpecialWormBite")

        local victims = table.filter(store.entities, function(_, e)
            return (e.soldier or e.enemy) and e.vis and band(e.vis.flags, a.vis_bans) == 0 and
                       band(e.vis.bans, a.vis_flags) == 0 and U.is_inside_ellipse(e.pos, attack_pos, a.max_range)
        end)

        for _, v in pairs(victims) do
            if v.health.dead then
                v.render.sprites[1].hidden = true
            else
                local d = E:create_entity("damage")

                d.source_id = this.id
                d.target_id = v.id
                d.damage_type = a.damage_type

                queue_damage(store, d)
            end
        end

        local decal = E:create_entity("fx_sand_worm_out")

        decal.pos = attack_pos
        decal.render.sprites[1].ts = store.tick_ts

        queue_insert(store, decal)
        U.y_animation_wait(this)

        s.hidden = true
    end
end

scripts.spell_djinn = {}

function scripts.spell_djinn.insert(this, store, script)
    local target = store.entities[this.spell.target_id]

    if not target or band(target.vis.bans, F_POLYMORPH) ~= 0 then
        queue_remove(store, this)
        return false
    end

    local damage_spell = this.spell.level * this.spell.damage_inc + this.spell.damage_base
    local instakill = target.health.hp <= damage_spell

    if target.health.dead then
        queue_remove(store, this)
        return false
    end
    local d = E:create_entity("damage")
    if instakill then
        d.damage_type = DAMAGE_EAT
    else
        d.value = damage_spell
        d.damage_type = DAMAGE_TRUE
    end
    d.source_id = this.id
    d.target_id = target.id
    queue_damage(store, d)

    target.vis.bans = F_POLYMORPH

    local fx = E:create_entity("fx")
    fx.pos = V.vclone(target.pos)
    fx.render.sprites[1].ts = store.tick_ts
    fx.render.sprites[1].draw_order = 2
    fx.render.sprites[1].name = "fx_djinn_smoke"
    queue_insert(store, fx)

    if instakill then
        fx = E:create_entity(this.fx_options[math.random(1, #this.fx_options)])
        fx.pos = V.vclone(target.pos)
        fx.render.sprites[1].ts = store.tick_ts
        queue_insert(store, fx)
    end

    -- AC:inc_check("STUFFOMAKER", 1)
    queue_remove(store, this)
    return true
end

scripts.shock_djinn = {}

function scripts.shock_djinn.insert(this, store, script)
    local target = store.entities[this.spell.target_id]

    if not target or band(target.vis.bans, F_POLYMORPH) ~= 0 then
        queue_remove(store, this)
        return false
    end

    if target.health.dead then
        queue_remove(store, this)
        return false
    end

    local damage_spell = this.spell.level * this.spell.damage_inc + this.spell.damage_base

    local d = E:create_entity("damage")
    d.value = damage_spell
    d.damage_type = DAMAGE_TRUE
    d.source_id = this.id
    d.target_id = target.id
    queue_damage(store, d)

    local fx = E:create_entity("fx")
    fx.pos = V.vclone(target.pos)
    fx.render.sprites[1].ts = store.tick_ts
    fx.render.sprites[1].draw_order = 2
    fx.render.sprites[1].name = "fx_djinn_smoke"
    queue_insert(store, fx)

    local mod_shock = E:create_entity("mod_djinn_shock")
    mod_shock.modifier.duration = mod_shock.duration_base + this.spell.level * mod_shock.duration_inc
    mod_shock.modifier.target_id = target.id
    queue_insert(store, mod_shock)

    queue_remove(store, this)
    return true
end

scripts.pirate_cannons = {}

function scripts.pirate_cannons.update(this, store, script)
    local cooldown, decal
    local a = this.attacks.list[1]

    a.ts = store.tick_ts

    while true do
        a.cooldown = U.frandom(a.min_cooldown, a.max_cooldown)

        if store.tick_ts - a.ts > a.cooldown then
            local targets = table.filter(store.entities, function(_, e)
                return
                    e and e.soldier and e.health and not e.health.dead and e.soldier.target_id ~= nil and e.motion and
                        V.veq(e.motion.speed, V.v(0, 0)) and e.vis and band(e.vis.flags, a.vis_bans) == 0 and
                        band(e.vis.bans, a.vis_flags) == 0 and U.is_inside_ellipse(e.pos, this.pos, a.max_range) and
                        not U.is_inside_ellipse(e.pos, this.pos, a.min_range)
            end)
            local target = targets[math.random(1, #targets)]

            if not target then
                -- block empty
            else
                decal = E:create_entity("decal_pirate_cannon_target")
                decal.pos = V.vclone(target.pos)
                decal.render.sprites[1].ts = store.tick_ts

                queue_insert(store, decal)
                U.animation_start(this, "fire", nil, store.tick_ts, false)
                U.y_wait(store, a.shoot_time)
                S:queue("PirateBombShootSound")

                local dest = V.vclone(target.pos)

                U.y_wait(store, fts(28))

                local b1 = E:create_entity("bomb_pirate_cannon")
                local b2 = E:create_entity("bomb_pirate_cannon")

                b1.bullet.to = V.v(dest.x + U.random_sign() * math.random(a.min_error, a.max_error),
                    dest.y + U.random_sign() * math.random(a.min_error, a.max_error))
                b2.bullet.to = V.v(dest.x + U.random_sign() * math.random(a.min_error, a.max_error),
                    dest.y + U.random_sign() * math.random(a.min_error, a.max_error))
                b1.pos = b1.bullet.to
                b2.pos = b2.bullet.to

                queue_insert(store, b1)
                U.y_wait(store, fts(4))
                queue_insert(store, b2)
                U.y_animation_wait(this)

                a.ts = store.tick_ts
            end
        end

        coroutine.yield()
    end
end

scripts.bomb_pirate_cannon = {}

function scripts.bomb_pirate_cannon.update(this, store, script)
    local b = this.bullet

    S:queue(this.sound_events.hit)

    local targets = table.filter(store.entities, function(_, e)
        return e and e.health and not e.health.dead and e.vis and band(e.vis.flags, b.damage_bans) == 0 and
                   band(e.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(e.pos, b.to, b.damage_radius)
    end)

    for _, target in pairs(targets) do
        local d = E:create_entity("damage")

        d.damage_type = b.damage_type
        d.value = b.damage_min + math.ceil(U.frandom(0, b.damage_max - b.damage_min))
        d.source_id = this.id
        d.target_id = target.id

        queue_damage(store, d)
    end

    local p = SU.create_bullet_pop(store, this)

    queue_insert(store, p)

    local sfx = E:create_entity(b.hit_fx)

    sfx.pos = V.vclone(b.to)
    sfx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, sfx)

    local decal = E:create_entity(b.hit_decal)

    decal.pos = V.vclone(b.to)
    decal.render.sprites[1].ts = store.tick_ts

    queue_insert(store, decal)
    queue_remove(store, this)
end

scripts.decal_efreeti_door = {}

function scripts.decal_efreeti_door.update(this, store, script)
    local floor_sid, door_sid, statue_left_sid, statue_right_sid, eyes_sid, eyes_fx_sid = 1, 2, 4, 5, 6, 7

    while true do
        while this.phase ~= "eyes" do
            coroutine.yield()
        end

        local eyes, eyesfx = this.render.sprites[eyes_sid], this.render.sprites[eyes_fx_sid]

        eyes.ts = store.tick_ts
        eyes.hidden = false

        S:queue("BossEfreetiSpawnBoss")
        U.y_wait(store, 1.5)

        this.phase = "show_boss"
        eyesfx.ts = store.tick_ts
        eyesfx.hidden = false

        U.y_animation_wait(this, eyes_sid)

        eyes.hidden = true
        eyesfx.hidden = true

        while this.phase ~= "destruction" do
            coroutine.yield()
        end

        U.animation_start(this, "destruction", nil, store.tick_ts, false, door_sid)
        U.animation_start(this, "destruction", nil, store.tick_ts, false, floor_sid)
        S:queue("BossEfreetiDoors")
        U.y_wait(store, 0.9)

        for _, p in pairs(this.smoke_positions) do
            local fx = E:create_entity("fx")

            fx.pos.x, fx.pos.y = p.x, p.y
            fx.render.sprites[1].name = "efreeti_door_smoke"
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)
        end

        for _, p in pairs(this.stone_positions) do
            local fx = E:create_entity("fx")

            fx.pos.x, fx.pos.y = p[1].x, p[1].y
            fx.render.sprites[1].name = "efreeti_door_stone"
            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].scale = V.v(p[2], p[2])
            fx.render.sprites[1].flip_x = p[3]

            queue_insert(store, fx)
        end

        this.render.sprites[statue_left_sid].name = "left"
        this.render.sprites[statue_right_sid].name = "right"

        U.y_animation_wait(this, floor_sid)

        this.render.sprites[floor_sid].hidden = true

        U.y_wait(store, 3)

        this.phase = "finished"
    end
end

scripts.carnivorous_plant = {}

function scripts.carnivorous_plant.update(this, store, script)
    local a = this.area_attack

    U.animation_start(this, "inactive", nil, store.tick_ts, true)

    while store.wave_group_number < this.activates_on_wave do
        coroutine.yield()
    end

    U.y_animation_play(this, "activate", nil, store.tick_ts)
    U.animation_start(this, "idle", nil, store.tick_ts, true)

    local attack_ts = store.tick_ts

    while true do
        while store.tick_ts - attack_ts < a.cooldown do
            coroutine.yield()
        end

        local trigger

        for _, e in pairs(store.entities) do
            if (e.enemy or e.soldier) and e.health and not e.health.dead and band(e.vis.bans, a.vis_flags) == 0 and
                band(e.vis.flags, a.vis_bans) == 0 and U.is_inside_ellipse(e.pos, this.attack_pos, a.damage_radius) then
                trigger = e

                break
            end
        end

        if not trigger then
            attack_ts = store.tick_ts - a.cooldown + 1
        else
            attack_ts = store.tick_ts

            local attack_animation = this.attack_pos.y > this.pos.y and "attack_up" or "attack_down"

            U.animation_start(this, attack_animation, nil, store.tick_ts)
            U.y_wait(store, a.hit_time)
            S:queue("SpecialCarnivorePlant")

            local e = E:create_entity("pop_slurp")
            local x_off = this.render.sprites[1].flip_x and -40 or 40
            local y_off = this.attack_pos.y > this.pos.y and 40 or -50

            e.pos = V.v(this.pos.x + x_off, this.pos.y + e.pop_y_offset + y_off)
            e.render.sprites[1].r = math.random(-21, 21) * math.pi / 180
            e.render.sprites[1].ts = store.tick_ts

            queue_insert(store, e)

            local targets = table.filter(store.entities, function(_, e)
                return (e.enemy or e.soldier) and e.health and not e.health.dead and e.vis and
                           band(e.vis.bans, a.vis_flags) == 0 and band(e.vis.flags, a.vis_bans) == 0 and
                           U.is_inside_ellipse(e.pos, this.attack_pos, a.damage_radius)
            end)

            if #targets > 0 then
                for _, target in pairs(targets) do
                    local d = E:create_entity("damage")

                    d.damage_type = a.damage_type
                    d.source_id = this.id
                    d.target_id = target.id

                    queue_damage(store, d)
                end
            end

            U.y_animation_wait(this)
            U.animation_start(this, "idle", nil, store.tick_ts, true)
        end
    end
end
scripts.decal_bouncing_bridge = {}

function scripts.decal_bouncing_bridge.update(this, store, script)
    local last_loaded = false

    while true do
        local loaded = false

        for _, e in pairs(store.entities) do
            if (e.enemy or e.soldier) and not e.health.dead and e.vis and not U.flag_has(e.vis.flags, F_FLYING) and
                U.is_inside_ellipse(e.pos, this.pos, this.bridge_width / 2) then
                loaded = true

                break
            end
        end

        if loaded ~= last_loaded then
            if loaded then
                U.animation_start(this, "bounce", nil, store.tick_ts, true)
            else
                U.animation_start(this, "idle", nil, store.tick_ts)
            end

            last_loaded = loaded
        end

        U.y_wait(store, fts(10))
    end
end

scripts.decal_volcano_virgin = {}

function scripts.decal_volcano_virgin.update(this, store, script)
    U.y_animation_play(this, "heart", nil, store.tick_ts, 1)
    U.y_wait(store, 1)

    local dist = 25
    local eta = dist / this.motion.real_speed
    local fade_step = 255 / (eta / store.tick_length)

    U.animation_start(this, "walk", false, store.tick_ts, true)
    U.set_destination(this, V.v(this.pos.x + dist, this.pos.y))

    while not this.motion.arrived do
        U.walk(this, store.tick_length)

        this.render.sprites[1].alpha = km.clamp(0, 255, this.render.sprites[1].alpha - fade_step)

        coroutine.yield()
    end

    -- AC:got("SAVETHEPRINCESS")
    queue_remove(store, this)
end

scripts.decal_indiana_boulder = {}

function scripts.decal_indiana_boulder.update(this, store, script)
    while not U.walk(this, store.tick_length) do
        coroutine.yield()
    end

    queue_remove(store, this)
end


scripts.enemy_gunboat = {}

function scripts.enemy_gunboat.get_info(this)
    local b = E:get_template(this.attacks.list[1].bullet)
    local min, max = b.bullet.damage_min, b.bullet.damage_max

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.enemy_gunboat.update(this, store)
    local ba = this.attacks.list[1]

    ba.ts = store.tick_ts

    if not ba.stop_at_nodes then
        log.warning("Loading default shots for gunboat")

        ba.stop_at_nodes = {32, 52, 72}
        ba.shots_at_node = {2, 2, 2}
    end

    ::label_188_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
            coroutine.yield()
        else
            local idx = table.find(ba.stop_at_nodes, this.nav_path.ni)

            if idx then
                this.nav_path.ni = this.nav_path.ni + 1

                local shots = ba.shots_at_node[idx]

                if shots <= 0 then
                    -- block empty
                else
                    U.y_animation_play(this, ba.animations[1], nil, store.tick_ts, 1)

                    for i = 1, shots do
                        if this.health.dead then
                            goto label_188_0
                        end

                        U.animation_start(this, ba.animations[2], nil, store.tick_ts)
                        U.y_wait(store, ba.shoot_time)

                        while this.unit.is_stunned do
                            if this.health.dead then
                                goto label_188_0
                            end

                            coroutine.yield()
                        end

                        local shoot_pos
                        local target = U.find_random_target(store.entities, this.pos, ba.min_range, ba.max_range,
                            ba.vis_flags, ba.vis_bans)

                        log.debug("GUNBOAT TARGET: %s", target and target.id or "nil")

                        if target then
                            shoot_pos = target.pos
                        else
                            shoot_pos = P:get_random_position(10, bor(TERRAIN_LAND))
                        end

                        if shoot_pos then
                            local b = E:create_entity(ba.bullet)

                            b.pos.x, b.pos.y = this.pos.x + ba.bullet_start_offset.x,
                                this.pos.y + ba.bullet_start_offset.y
                            b.bullet.from = V.vclone(b.pos)
                            b.bullet.to = V.vclone(shoot_pos)
                            b.bullet.source_id = this.id

                            queue_insert(store, b)
                        end

                        while not U.animation_finished(this) or this.unit.is_stunned do
                            if this.health.dead then
                                goto label_188_0
                            end

                            coroutine.yield()
                        end
                    end

                    U.y_animation_play(this, ba.animations[3], nil, store.tick_ts, 1)
                end

                goto label_188_0
            end

            SU.y_enemy_walk_step(store, this)
        end
    end
end

scripts.decal_whale = {}

function scripts.decal_whale.insert(this, store, script)
    this.pos = P:node_pos(this.nav_path.pi, 1, 1)
    this.pos.x = this.pos.x + this.path_origin_offset.x
    this.pos.y = this.pos.y + this.path_origin_offset.y

    if not this.spawn_data then
        log.error("spawn_data required for decal_whale")

        return false
    end

    return true
end

function scripts.decal_whale.update(this, store, script)
    log.debug("whale starting")

    local cover_s = this.render.sprites[4]
    local eye_s = this.render.sprites[5]
    local blink_cooldown = math.random(2, 4)
    local fx = E:create_entity("fx_whale_incoming")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)

    local wait_ts = store.tick_ts + 3.5

    while wait_ts > store.tick_ts do
        coroutine.yield()
    end

    S:queue("RTWhaleSpawn")

    for i = 1, 3 do
        this.render.sprites[i].hidden = false

        U.animation_start(this, "show", nil, store.tick_ts, 1, i)
    end

    while not U.animation_finished(this) do
        coroutine.yield()
    end

    for i = 1, 3 do
        this.render.sprites[i].hidden = false

        U.animation_start(this, "idle", nil, store.tick_ts, -1, i)
    end

    cover_s.hidden = false
    eye_s.hidden = false

    while not store.wave_signals[this.spawn_data.whale_hide_signal] do
        if blink_cooldown < store.tick_ts - eye_s.ts then
            blink_cooldown = math.random(2, 4)

            U.animation_start(this, "blink", nil, store.tick_ts, 1, 5)
        end

        coroutine.yield()
    end

    cover_s.hidden = true
    eye_s.hidden = true

    for i = 1, 3 do
        this.render.sprites[i].hidden = false

        U.animation_start(this, "hide", nil, store.tick_ts, 1, i)
    end

    while not U.animation_finished(this) do
        coroutine.yield()
    end

    queue_remove(store, this)
    log.debug("whale ended")
end

scripts.pirate_watchtower_parrot = {}

function scripts.pirate_watchtower_parrot.update(this, store)
    local sp = this.render.sprites[1]
    local fm = this.force_motion
    local ca = this.custom_attack
    local dest = V.vclone(this.idle_pos)

    local function force_move_step(dest, max_speed, ramp_radius)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local df = (not ramp_radius or ramp_radius < dist) and 1 or math.max(dist / ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(495, V.mul(10 * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(max_speed, fm.v.x, fm.v.y)
        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
        fm.a.x, fm.a.y = V.mul(-0.05 / store.tick_length, fm.v.x, fm.v.y)
        sp.flip_x = this.pos.x < dest.x
    end

    sp.offset.y = this.flight_height

    while true do
        if store.tick_ts - ca.ts > ca.cooldown and not this.owner.tower.blocked then
            local target = U.find_nearest_enemy(store.enemies, tpos(this.owner), 0, this.owner.attacks.range,
                ca.vis_flags, ca.vis_bans)

            if not target then
                SU.delay_attack(store, ca, 0.13333333333333333)
            else
                log.debug("fly to get bomb")
                U.animation_start(this, "fly", nil, store.tick_ts, true)

                dest.x, dest.y = this.bombs_pos.x, this.bombs_pos.y

                local dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

                while dist > 10 do
                    force_move_step(dest, this.flight_speed_busy, this.ramp_dist_busy)
                    coroutine.yield()

                    target = store.entities[target.id]

                    if not target or target.health.dead then
                        ca.ts = store.tick_ts

                        goto label_185_0
                    end

                    dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
                end

                log.debug("carry bomb")
                U.animation_start(this, "carry", nil, store.tick_ts, true)

                dest.x, dest.y = target.pos.x, target.pos.y
                dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

                while dist > 40 do
                    force_move_step(dest, this.flight_speed_busy)
                    coroutine.yield()

                    dest.x, dest.y = target.pos.x, target.pos.y
                    dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
                end

                log.debug("drop bomb")

                local e = E:create_entity(ca.bullet)

                e.pos.x, e.pos.y = this.pos.x, this.pos.y + this.flight_height - 8
                e.bullet.from = V.vclone(e.pos)
                e.bullet.source_id = this.id

                queue_insert(store, e)

                local t_off = P:predict_enemy_node_advance(target, e.bullet.flight_time)
                local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + t_off)

                e.bullet.to = V.vclone(t_pos)
                ca.ts = store.tick_ts
                dest.x, dest.y = this.idle_pos.x, this.idle_pos.y
            end
        end

        ::label_185_0::

        U.animation_start(this, "idle", nil, store.tick_ts, true)

        if V.dist(dest.x, dest.y, this.idle_pos.x, this.idle_pos.y) > 43 or
            V.dist(dest.x, dest.y, this.pos.x, this.pos.y) < 10 then
            dest = U.point_on_ellipse(this.idle_pos, 30, U.frandom(0, 2 * math.pi))
        end

        force_move_step(dest, this.flight_speed_idle, this.ramp_dist_idle)
        coroutine.yield()
    end
end

scripts.hero_steam_frigate = {}

function scripts.hero_steam_frigate.get_info(this)
    local b = E:get_template("steam_frigate_barrel")
    local min, max = b.bullet.damage_min, b.bullet.damage_max

    return {
        type = STATS_TYPE_SOLDIER,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
    }
end

function scripts.hero_steam_frigate.insert(this, store, script)
    return true
end

function scripts.hero_steam_frigate.update(this, store, script)
    local h = this.health
    local he = this.hero
    local ba = this.ranged.attacks[1]
    local ma = this.timed_attacks.list[1]
    local smoke_sprite = this.render.sprites[3]
    local throw_min_dist_x = 29
    local mines_alive = {}

    local function get_mine_targets()
        return P:get_all_valid_pos(this.pos.x, this.pos.y, ma.min_range, ma.max_range, ma.valid_terrains, function(x, y)
            return math.abs(this.pos.x - x) > throw_min_dist_x
        end)
    end

    local mine_targets = get_mine_targets()

    while true do
        mines_alive = table.filter(mines_alive, function(_, m)
            return store.entities[m.id] ~= nil
        end)

        while this.nav_rally.new do
            if SU.y_hero_new_rally(store, this) then
                goto label_470_0
            end

            mine_targets = get_mine_targets()
        end

        if store.tick_ts - ba.ts > ba.cooldown then
            local enemy, _, pred_pos = U.find_foremost_enemy(store.enemies, this.pos, ba.min_range, ba.max_range,
                ba.node_prediction, ba.vis_flags, ba.vis_bans, function(entity)
                    return math.abs(this.pos.x - entity.pos.x) > throw_min_dist_x
                end)

            if enemy then
                local start_ts = store.tick_ts
                local an, af, ai = U.animation_name_facing_point(this, ba.animation, pred_pos)

                U.animation_start(this, an, af, store.tick_ts)

                while store.tick_ts - start_ts < ba.shoot_time do
                    if this.nav_rally.new then
                        goto label_470_0
                    end

                    if this.health.dead then
                        goto label_470_0
                    end

                    if this.unit.is_stunned then
                        goto label_470_0
                    end

                    coroutine.yield()
                end

                ba.ts = start_ts

                local b = E:create_entity(ba.bullet)
                local offset = ba.bullet_start_offset[1]

                b.pos.x, b.pos.y = this.pos.x + (af and -1 or 1) * offset.x, this.pos.y + offset.y
                b.bullet.from = V.vclone(b.pos)
                b.bullet.to = pred_pos
                b.bullet.target_id = enemy.id

                queue_insert(store, b)

                while not U.animation_finished(this) do
                    if this.nav_rally.new then
                        goto label_470_0
                    end

                    if this.health.dead then
                        goto label_470_0
                    end

                    if this.unit.is_stunned then
                        goto label_470_0
                    end

                    coroutine.yield()
                end
            end
        end

        if store.tick_ts - ma.ts > ma.cooldown and #mines_alive < ma.max_mines and #mine_targets > 0 then
            local start_ts = store.tick_ts
            local target_pos = mine_targets[math.random(1, #mine_targets)]
            local an, af = U.animation_name_facing_point(this, ma.animation, target_pos)

            U.animation_start(this, an, af, store.tick_ts, false)

            while store.tick_ts - start_ts < ma.shoot_time do
                if this.nav_rally.new then
                    goto label_470_0
                end

                if this.health.dead then
                    goto label_470_0
                end

                if this.unit.is_stunned then
                    goto label_470_0
                end

                coroutine.yield()
            end

            ma.ts = start_ts

            local m = E:create_entity(ma.bullet)
            local offset = ma.bullet_start_offset[1]

            m.pos.x, m.pos.y = this.pos.x + (af and -1 or 1) * offset.x, this.pos.y + offset.y
            m.bullet.from = V.vclone(m.pos)
            m.bullet.to = target_pos

            queue_insert(store, m)
            table.insert(mines_alive, m)

            while not U.animation_finished(this) do
                if this.nav_rally.new then
                    goto label_470_0
                end

                if this.health.dead then
                    goto label_470_0
                end

                if this.unit.is_stunned then
                    goto label_470_0
                end

                coroutine.yield()
            end
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true)

        ::label_470_0::

        coroutine.yield()
    end
end

scripts.steam_frigate_mine = {}

function scripts.steam_frigate_mine.update(this, store, script)
    local b = this.bullet

    this.lifespan.ts = store.tick_ts

    while store.tick_ts - b.ts < b.flight_time do
        b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
        this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)
        this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length

        coroutine.yield()
    end

    this.pos.x, this.pos.y = b.to.x, b.to.y

    S:queue("SpecialMermaid")

    this.render.sprites[1].hidden = true
    this.render.sprites[2].hidden = false

    U.y_animation_play(this, "splash", nil, store.tick_ts, 1, 2)
    U.animation_start(this, "idle", nil, store.tick_ts, -1, 2)

    while store.tick_ts - this.lifespan.ts < this.lifespan.duration do
        coroutine.yield()

        if U.find_enemies_in_range(store.enemies, this.pos, 0, this.trigger_radius, b.vis_flags, b.vis_bans) then
            local fx

            if GR:cell_is(this.pos.x, this.pos.y, TERRAIN_WATER) then
                S:queue(this.sound_events.hit_water)

                fx = E:create_entity("fx_explosion_water")
            else
                S:queue(this.sound_events.hit)

                fx = E:create_entity("fx_explosion_fragment")
            end

            fx.pos = V.vclone(this.pos)
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)

            local enemies = U.find_enemies_in_range(store.enemies, this.pos, 0, b.damage_radius, b.damage_flags,
                b.damage_bans)

            for _, enemy in pairs(enemies) do
                local d = E:create_entity("damage")

                d.damage_type = b.damage_type
                d.value = math.ceil(U.frandom(b.damage_min, b.damage_max))
                d.source_id = this.id
                d.target_id = enemy.id

                queue_damage(store, d)
            end

            queue_remove(store, this)

            return
        end
    end

    U.y_animation_play(this, "sink", nil, store.tick_ts, 1, 2)
    queue_remove(store, this)
end

scripts.tower_neptune_holder = {}

function scripts.tower_neptune_holder.get_info(this)
    local t = E:get_template("tower_neptune")
    local b = E:get_template(t.attacks.list[1].bullet)
    local min, max = b.bullet.damage_min_levels[1], b.bullet.damage_max_levels[1]
    local range = 2000
    local cooldown = t.attacks.list[1].cooldown

    return {
        type = STATS_TYPE_TOWER,
        damage_min = min,
        damage_max = max,
        range = range,
        cooldown = cooldown
    }
end

scripts.tower_neptune = {}

function scripts.tower_neptune.get_info(this)
    local level = this.powers.ray.level
    local b = E:get_template(this.attacks.list[1].bullet)
    local min, max = b.bullet.damage_min_levels[level], b.bullet.damage_max_levels[level]
    local range = 2000
    local cooldown = this.attacks.list[1].cooldown

    return {
        type = STATS_TYPE_TOWER,
        damage_min = min,
        damage_max = max,
        range = range,
        cooldown = cooldown
    }
end

function scripts.tower_neptune.insert(this, store, script)
    return true
end

function scripts.tower_neptune.update(this, store, script)
    local pow = this.powers.ray
    local a = this.attacks.list[1]

    a.ts = store.tick_ts - a.cooldown + 0.03333333333333333

    local charging = false
    local sid_charging = 4
    local sid_gem_1 = 5
    local sid_gem_2 = 6
    local sid_gem_3 = 7
    local sid_eyes = 8
    local sid_trident_glow = 2
    local sid_trident = 9
    local sid_tip = 10
    local sid_gems = {sid_gem_1, sid_gem_2, sid_gem_3}
    local s = this.render.sprites

    while true do
        if pow.changed then
            pow.changed = nil

            if pow.level == 2 then
                s[sid_gem_2].hidden = false
            end

            if pow.level == 3 then
                s[sid_gem_3].hidden = false
            end

            a.ts = store.tick_ts - a.cooldown
            charging = true
        end

        if store.tick_ts - a.ts < a.cooldown and not charging then
            this.user_selection.allowed = false
            charging = true
            s[sid_charging].hidden = false
            s[sid_charging].name = "charging"
            s[sid_tip].hidden = true

            for _, gsid in pairs(sid_gems) do
                s[gsid].name = "empty"
                s[gsid].loop = true
            end

            s[sid_eyes].name = "empty"
            s[sid_trident].name = "empty"
            s[sid_trident_glow].hidden = true
        end

        if store.tick_ts - a.ts > a.cooldown then
            if charging then
                this.user_selection.allowed = true
                this.user_selection.new_pos = nil
                charging = false
                s[sid_charging].name = "charged"

                for _, gsid in pairs(sid_gems) do
                    s[gsid].name = "ready"
                    s[gsid].loop = true
                    s[gsid].fps = 15
                end

                s[sid_trident_glow].hidden = false
            end

            if this.user_selection.in_progress then
                s[sid_tip].hidden = false
                s[sid_tip].loop = true
                s[sid_tip].name = "pick"
            else
                s[sid_tip].hidden = true
            end

            if this.user_selection.new_pos then
                local pos = this.user_selection.new_pos

                this.user_selection.new_pos = nil
                a.ts = store.tick_ts
                s[sid_charging].hidden = true
                s[sid_trident_glow].hidden = true

                for _, gsid in pairs(sid_gems) do
                    s[gsid].fps = 30

                    U.animation_start(this, "shoot", nil, store.tick_ts, 1, gsid)
                end

                U.animation_start(this, "shoot", nil, store.tick_ts, 1, sid_tip)
                U.animation_start(this, "shoot", nil, store.tick_ts, 1, sid_eyes)
                U.animation_start(this, "shoot", nil, store.tick_ts, 1, sid_trident)

                local b = E:create_entity(a.bullet)

                b.bullet.to = V.vclone(pos)
                b.bullet.level = pow.level
                b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y

                queue_insert(store, b)

                while not U.animation_finished(this, sid_eyes) do
                    coroutine.yield()
                end
            end
        end

        coroutine.yield()
    end
end

scripts.ray_neptune = {}

function scripts.ray_neptune.update(this, store, script)
    local b = this.bullet
    local s = this.render.sprites[1]
    local damage_min = this.bullet.damage_min_levels[this.bullet.level]
    local damage_max = this.bullet.damage_max_levels[this.bullet.level]
    local angle = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

    s.r = angle
    s.scale = V.v(1, 1)
    s.scale.x = V.dist(b.to.x, b.to.y, this.pos.x, this.pos.y) / this.image_width
    s.ts = store.tick_ts

    local fx = E:create_entity(b.hit_fx)

    fx.pos.x, fx.pos.y = b.to.x, b.to.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)

    local enemies = table.filter(store.enemies, function(k, v)
        if v.enemy and v.health and not v.health.dead then
            if U.is_inside_ellipse(v.pos, b.to, b.damage_radius) then
                return true
            end

            if v.unit.hit_offset and
                U.is_inside_ellipse(V.v(v.pos.x, v.pos.y + v.unit.hit_offset.y), b.to, b.damage_radius) then
                return true
            end

            if v.unit.hit_rect and b.damage_rect then
                local dr = b.damage_rect
                local hr = v.unit.hit_rect
                local r1 = V.r(hr.pos.x + v.pos.x, hr.pos.y + v.pos.y, hr.size.x, hr.size.y)
                local r2 = V.r(dr.pos.x + b.to.x, dr.pos.y + b.to.y, dr.size.x, dr.size.y)

                return V.overlap(r1, r2)
            end
        end

        return false
    end)

    for _, enemy in pairs(enemies) do
        local d = E:create_entity("damage")

        d.source_id = this.id
        d.target_id = enemy.id
        d.value = math.random(damage_min, damage_max)
        d.damage_type = b.damage_type

        queue_damage(store, d)
    end

    while not U.animation_finished(this) do
        coroutine.yield()
    end

    queue_remove(store, this)
end

function scripts.hero_vampiress.insert(this, store, script)
    this.hero.fn_level_up(this, store)
    this.melee.order = U.attack_order(this.melee.attacks)
    local mod_name = this.track_kills.mod
    local m = E:create_entity(mod_name)
    m.modifier.target_id = this.id
    m.modifier.source_id = this.id
    m.pos = V.vclone(this.pos)
    queue_insert(store, m)

    return true
end

function scripts.hero_vampiress.update(this, store, script)
    local h = this.health
    local he = this.hero
    local r = this.nav_rally
    local brk, sta, should_fly, already_flying
    local orig_prefix = this.render.sprites[1].prefix
    local orig_vis_bans = this.vis.bans
    local orig_speed = this.motion.max_speed
    local a, skill
    U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while r.new do
                if not already_flying then
                    should_fly = V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > this.fly_to.min_distance

                    if should_fly then
                        already_flying = true
                        this.vis.bans = F_ALL
                        this.health.ignore_damage = true
                        this.render.sprites[1].prefix = this.fly_to.animation_prefix
                        this.render.sprites[2].hidden = false
                        U.update_max_speed(this, this.motion.max_speed_bat)
                        U.animation_start(this, "enter", nil, store.tick_ts)
                        -- U.y_wait(store, fts(7))

                        local fx = E:create_entity("fx_vampiress_transform")

                        fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                        fx.render.sprites[1].ts = store.tick_ts

                        queue_insert(store, fx)
                        U.y_animation_wait(this)
                    end
                end

                if SU.y_hero_new_rally(store, this) then
                    goto label_477_0
                end

                if already_flying and not r.new then
                    already_flying = nil
                    this.render.sprites[2].hidden = true
                    U.y_animation_play(this, "exit", nil, store.tick_ts)
                    this.render.sprites[1].prefix = orig_prefix
                    U.update_max_speed(this, orig_speed)
                    this.vis.bans = orig_vis_bans
                    this.health.ignore_damage = false
                end
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts)
            end

            a = this.timed_attacks.list[1]
            skill = this.hero.skills.slayer
            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.trigger_radius, a.vis_flags,
                    a.vis_bans)

                if not targets then
                    SU.delay_attack(store, a, 0.13333333333333333)
                else
                    local start_ts = store.tick_ts

                    S:queue(a.sound)
                    U.animation_start(this, a.animation, nil, store.tick_ts, false)
                    a.ts = store.tick_ts
                    while store.tick_ts - start_ts < a.hit_time do
                        if SU.hero_interrupted(this) then
                            goto label_477_0
                        end

                        coroutine.yield()
                    end

                    targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.damage_radius, a.vis_flags,
                        a.vis_bans)

                    if targets then
                        for _, e in pairs(targets) do
                            local d = E:create_entity("damage")

                            d.source_id = this.id
                            d.target_id = e.id
                            d.value = (math.random(a.damage_min, a.damage_max) + this.damage_buff) * this.unit.damage_factor
                            d.damage_type = a.damage_type
                            d.track_kills = true
                            if table.contains(a.extra_damage_templates, e.template_name) then
                                d.value = d.value * a.extra_damage_factor
                            end

                            queue_damage(store, d)
                        end
                    end

                    while not U.animation_finished(this) do
                        if SU.hero_interrupted(this) then
                            goto label_477_0
                        end

                        coroutine.yield()
                    end

                    SU.hero_gain_xp_from_skill(this, skill)
                end
            end

            if this.melee then
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk or sta ~= A_NO_TARGET then
                    goto label_477_0
                end
            end

            if SU.soldier_go_back_step(store, this) then
                -- block empty
            else
                SU.soldier_idle(store, this)
                SU.soldier_regen(store, this)
            end
        end

        ::label_477_0::

        coroutine.yield()
    end
end

scripts.mod_vampiress_gain = {
    update = function(this, store, script)
        local m = this.modifier
        local target = store.entities[m.target_id]
        this.pos = target.pos
        target.gain_count = 0
        local max_gain_count = this.max_gain_count
        while true do
            local has_kills = false
            for _, kid in pairs(target.track_kills.killed) do
                if target.gain_count < max_gain_count then
                    target.health.hp_max = target.health.hp_max + this.gain.hp
                    target.melee.attacks[1].damage_min = target.melee.attacks[1].damage_min + this.gain.damage
                    target.melee.attacks[1].damage_max = target.melee.attacks[1].damage_max + this.gain.damage
                    target.health.armor = target.health.armor + this.gain.armor
                    target.health.magic_armor = target.health.magic_armor + this.gain.magic_armor
                    if not target.render.sprites[1].scale then
                        target.render.sprites[1].scale = V.v(1+this.gain.size, 1+this.gain.size)
                    else
                        target.render.sprites[1].scale.x = target.render.sprites[1].scale.x + this.gain.size
                        target.render.sprites[1].scale.y = target.render.sprites[1].scale.y + this.gain.size
                    end
                    target.melee.attacks[2].cooldown = target.melee.attacks[2].cooldown - this.gain.cooldown
                    target.timed_attacks.list[1].cooldown = target.timed_attacks.list[1].cooldown - this.gain.cooldown
                    target.timed_attacks.list[1].damage_radius = target.timed_attacks.list[1].damage_radius + this.gain.radius
                    target.motion.max_speed_bat = target.motion.max_speed_bat + this.gain.speed

                    U.update_max_speed(target, this.gain.speed)
                    target.gain_count = target.gain_count + 1
                end
                scripts.heal(target, this.gain.heal)
                has_kills = true
            end
            if has_kills then
                target.track_kills.killed = {}
            end
            coroutine.yield()
        end
    end
}



scripts.ray_frankenstein = {}

function scripts.ray_frankenstein.insert(this, store)
    if not store.entities[this.bullet.target_id] then
        return false
    end

    return true
end

function scripts.ray_frankenstein.update(this, store)
    local b = this.bullet
    local s = this.render.sprites[1]
    local target = store.entities[b.target_id]
    local source = store.entities[b.source_id]
    local dest = b.to

    s.scale = V.v(1, 1)

    local function update_sprite()
        if target and target.motion then
            dest.x, dest.y = target.pos.x, target.pos.y

            if target.unit and target.unit.hit_offset then
                dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
            end
        end

        if source and source.motion then
            this.pos.x, this.pos.y = source.pos.x, source.pos.y

            if source.unit and source.unit.hit_offset then
                this.pos.x, this.pos.y = this.pos.x + source.unit.hit_offset.x, this.pos.y + source.unit.hit_offset.y
            end
        end

        local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

        s.r = angle
        s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
        s.scale.y = 0.4 + km.clamp(0, 0.6, s.scale.x * 0.6)
    end

    if target then
        s.ts = store.tick_ts

        update_sprite()

        if target.template_name == "soldier_frankenstein" and not target.health.dead then
            scripts.heal(target, this.frankie_heal_hp)
        elseif target.template_name == "hero_thor" then
            scripts.heal(target, target.lightning_heal)
        else
            local mod = E:create_entity(b.mod)
            mod.modifier.level = b.level
            mod.modifier.source_id = b.source_id
            mod.modifier.target_id = target.id
            mod.dps.damage_max = mod.dps.damage_max * this.bounce_damage_factor
            mod.dps.damage_min = mod.dps.damage_min * this.bounce_damage_factor
            mod.dps.damage_inc = mod.dps.damage_inc * this.bounce_damage_factor
            queue_insert(store, mod)
        end

        table.insert(this.seen_targets, target.id)

        if not this.bounces then
            this.bounces = this.bounces_lvl[b.level]
        end

        if this.bounces > 0 then
            U.y_wait(store, this.bounce_delay)

            local bounce_target = U.find_nearest_target(store.entities, dest, 0, this.bounce_range,
                this.bounce_vis_flags, this.bounce_vis_bans, function(v)
                    return (not table.contains(this.seen_targets, v.id)) and (v.enemy or v.template_name == "hero_thor")
                end)

            bounce_target = bounce_target or
                                U.find_nearest_soldier(store.soldiers, dest, 0, this.bounce_range,
                    this.bounce_vis_flags, this.bounce_vis_bans, function(v)
                        return v.template_name == "soldier_frankenstein" and not v.health.dead and
                                   not table.contains(this.seen_targets, v.id)
                    end)

            if bounce_target then
                log.paranoid("bounce from %s to %s dist:%s", target.id, bounce_target.id,
                    V.dist(dest.x, dest.y, bounce_target.pos.x, bounce_target.pos.y))

                local r = E:create_entity(this.template_name)

                r.pos = V.vclone(dest)
                r.bullet.level = b.level
                r.bullet.to = V.vclone(target.pos)
                r.bullet.target_id = bounce_target.id
                r.bullet.source_id = target.id

                if bounce_target.template_name == "hero_thor" then
                    r.bounces = this.bounces + 1
                    r.bounce_range = this.bounce_range * 1.5
                else
                    r.bounces = this.bounces - 1
                end

                r.seen_targets = this.seen_targets
                if UP:get_upgrade("engineer_efficiency") then
                    r.bounce_damage_factor = 1
                else
                    r.bounce_damage_factor = math.max(this.bounce_damage_factor + this.bounce_damage_factor_inc,
                        this.bounce_damage_factor_min)
                end
                queue_insert(store, r)
            end
        end

        while not U.animation_finished(this) do
            update_sprite()
            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.fx_frankenstein_pound = {}

function scripts.fx_frankenstein_pound.insert(this, store)
    for i = 1, 5 do
        local p1 = V.v(math.random(8, 12), 0)
        local p2 = V.v(p1.x + math.random(34, 39), 0)
        local p3 = V.v(p2.x + math.random(4, 8), 0)
        local angle = (i - 1) * 2 * math.pi / 5 + math.random(-5, 5) / 180

        p1 = V.v(V.rotate(angle, p1.x, p1.y))
        p2 = V.v(V.rotate(angle, p2.x, p2.y))
        p3 = V.v(V.rotate(angle, p3.x, p3.y))
        p1.y = p1.y * ASPECT
        p2.y = p2.y * ASPECT
        p3.y = p3.y * ASPECT
        this.tween.props[2 * i].keys = {{0, p1}, {fts(10), p2}, {fts(16), p3}}
    end

    this.render.sprites[1].ts = store.tick_ts + fts(3)
    this.tween.ts = store.tick_ts

    return true
end

scripts.decal_moon_activated = {}

function scripts.decal_moon_activated.update(this, store)
    local last_state = false

    while true do
        if store.level and store.level.moon_controller then
            local state = store.level.moon_controller.moon_active

            if last_state ~= state then
                this.tween.reverse = not state
                this.tween.ts = store.tick_ts
                last_state = state
            end
        end

        coroutine.yield()
    end
end

scripts.moon_controller = {}

function scripts.moon_controller.update(this, store)
    local glow_sid, eyes_sid = 1, 4
    local glow_s = this.render.sprites[glow_sid]
    local eyes_s = this.render.sprites[eyes_sid]
    local moon = this.decal_moon_dark
    local moon_s = moon.render.sprites[1]
    local moon_light = this.decal_moon_light
    local overlay = this.moon_overlay
    local fade_time = overlay.tween.props[1].keys[2][1]
    local ptr = 1

    while true do
        local hold_start_ts
        local wave_start_ts = store.tick_ts
        local wave_number = store.wave_group_number

        local function fn_new_wave(store, time)
            return store.wave_group_number ~= wave_number
        end

        while this.waves[ptr] and this.waves[ptr][1] == wave_number and wave_number == store.wave_group_number do
            local d_wave, d_delay, d_duration = unpack(this.waves[ptr])
            local delay = d_delay - (store.tick_ts - wave_start_ts)
            local transit_time = this.transit_time

            if U.y_wait(store, delay - transit_time, fn_new_wave) then
                -- block empty
            else
                moon.tween.props[1].keys = {{0, math.pi / 5}, {transit_time, math.pi / 2}}
                moon.tween.disabled = nil
                moon.tween.ts = store.tick_ts

                if U.y_wait(store, 0.15 * transit_time, fn_new_wave) then
                    -- block empty
                elseif U.y_wait(store, 0.85 * transit_time, fn_new_wave) then
                    -- block empty
                else
                    moon_light.tween.ts = store.tick_ts
                    moon_light.tween.reverse = false
                    this.tween.ts = store.tick_ts
                    this.tween.reverse = false
                    overlay.tween.ts = store.tick_ts
                    overlay.tween.reverse = false

                    S:queue("MusicHalloweenMoon")

                    hold_start_ts = store.tick_ts
                    this.moon_active = true

                    signal.emit("moon-changed", true, store)

                    while d_duration > store.tick_ts - hold_start_ts do
                        if fn_new_wave(store) then
                            break
                        end

                        coroutine.yield()
                    end
                end

                log.debug("MOON: finishing for wave %s", wave_number)
                signal.emit("moon-changed", false, store)

                this.moon_active = false

                if store.wave_group_number ~= wave_number then
                    transit_time = transit_time / 4
                end

                if not this.tween.reverse then
                    this.tween.ts = store.tick_ts
                    this.tween.reverse = true
                end

                if not overlay.tween.reverse then
                    overlay.tween.ts = store.tick_ts
                    overlay.tween.reverse = true
                end

                if not moon_light.tween.reverse then
                    moon_light.tween.ts = store.tick_ts
                    moon_light.tween.reverse = true

                    U.y_wait(store, fade_time)
                end

                S:queue(string.format("MusicBattle_%02d", store.level_idx), {
                    seek = 19.774
                })

                moon.tween.props[1].keys = {{0, moon_s.r}, {transit_time, 4 * math.pi / 5}}
                moon.tween.ts = store.tick_ts

                if U.y_wait(store, transit_time, fn_new_wave) then
                    transit_time = (transit_time - (store.tick_ts - moon.tween.ts)) / 4
                    moon.tween.props[1].keys = {{0, moon_s.r}, {transit_time, 4 * math.pi / 5}}
                    moon.tween.ts = store.tick_ts

                    U.y_wait(store, transit_time)
                end
            end

            log.debug("MOON: skipping for wave %s", wave_number)

            ptr = ptr + 1
        end

        while wave_number == store.wave_group_number do
            coroutine.yield()
        end
    end
end

scripts.moon_enemy_aura = {}

function scripts.moon_enemy_aura.update(this, store)
    while true do
        local source = store.entities[this.aura.source_id]

        if not source or not source.health or source.health.dead or not store.level or not store.level.moon_controller then
            log.paranoid("X removing moon_enemy_aura for source id:%s", this.aura.source_id)
            queue_remove(store, this)

            return
        end

        if store.level.moon_controller.moon_active and not source.moon.active then
            log.debug("MOON: + activating for (%s) %s", source.id, source.template_name)

            source.moon.active = true

            if source.moon.speed_factor and source.motion then
                U.speed_mul(source, source.moon.speed_factor)
            end

            if source.moon.damage_factor and source.melee then
                source.unit.damage_factor = source.unit.damage_factor * source.moon.damage_factor
            end

            if source.moon.regen_hp and source.regen then
                source.regen.health = source.regen.health + source.moon.regen_hp
            end

            if source.moon.transform_name then
                local m = E:create_entity("mod_lycanthropy")

                m.modifier.target_id = source.id
                m.active = true
                m.moon.transform_name = source.moon.transform_name

                queue_insert(store, m)
            end
        elseif not store.level.moon_controller.moon_active and source.moon.active then
            log.debug("MOON: - deactivating for (%s) %s", source.id, source.template_name)

            source.moon.active = nil

            if source.moon.speed_factor and source.motion then
                U.speed_div(source, source.moon.speed_factor)
            end

            if source.moon.damage_factor and source.melee then
                source.unit.damage_factor = source.unit.damage_factor / source.moon.damage_factor
            end

            if source.moon.regen_hp and source.regen then
                source.regen.health = source.regen.health - source.moon.regen_hp
            end
        end

        coroutine.yield()
    end
end

scripts.points_spawner = {}

function scripts.points_spawner.update(this, store)
    if not this.spawner_points or not this.spawner_groups or not this.spawner_waves then
        log.error("points_spawner not initialized. points, grops or waves missing")
        queue_remove(store, this)

        return
    end

    while true do
        local wave_start_ts = store.tick_ts
        local current_wave = this.manual_wave or not store.waves_finished and store.wave_group_number or nil
        local spawn_queue = {}

        if this.spawner_waves[current_wave] and not this.interrupt then
            for _, w in pairs(this.spawner_waves[current_wave]) do
                local delay, delay_var, group, subpath, qty, force_all, int_min, int_max, template, custom_data =
                    unpack(w)

                log.paranoid("points_spawner %s wave: %s,%s,%s,%s,%s,%s,%s", current_wave, delay, group, qty, subpath,
                    force_all, int_min, int_max, template)

                local c_delay = delay
                local point_ids = this.spawner_groups[group] or {group}

                for i = 1, qty do
                    if force_all then
                        for _, point_id in pairs(point_ids) do
                            local point = this.spawner_points[point_id]
                            local spi = subpath > 0 and subpath or math.random(1, 3)
                            local this_delay = c_delay + U.frandom(0, delay_var)
                            for i = 1, store.patches.enemy_count_multiplier do
                                table.insert(spawn_queue, {this_delay / i, template, point.from, point.to, point.path, spi, custom_data})
                            end
                        end
                    else
                        if i == 1 then
                            c_delay = c_delay + U.frandom(0, delay_var)
                        end

                        local point_id = table.random(point_ids)
                        local point = this.spawner_points[point_id]
                        local spi = subpath > 0 and subpath or math.random(1, 3)
                        for i = 1, store.patches.enemy_count_multiplier do
                            table.insert(spawn_queue, {c_delay / i, template, point.from, point.to, point.path, spi, custom_data})
                        end
                    end

                    c_delay = c_delay + U.frandom(int_min, int_max)
                end
            end

            table.sort(spawn_queue, function(e1, e2)
                return e1[1] < e2[1]
            end)

            local ptr = 1

            while this.manual_wave and current_wave == this.manual_wave or not this.manual_wave and current_wave ==
                store.wave_group_number do
                if this.interrupt then
                    goto label_191_0
                end

                local wave_ts = store.tick_ts - wave_start_ts

                while ptr <= #spawn_queue and wave_ts >= spawn_queue[ptr][1] do
                    local ts, template, p_from, p_to, p_pi, p_spi, custom_data = unpack(spawn_queue[ptr])
                    local pis = p_pi and {p_pi} or nil
                    local nodes = P:nearest_nodes(p_to.x, p_to.y, pis, {p_spi})

                    if #nodes == 0 then
                        log.error("points_spawner (%06.2f) %s - Node not found near:%s,%s", ts, current_wave, p_to.x,
                            p_to.y)
                    else
                        local e = E:create_entity(template)

                        e.nav_path.pi = p_pi or nodes[1][1]
                        e.nav_path.spi = nodes[1][2]
                        e.nav_path.ni = nodes[1][3]
                        e.pos = V.vclone(p_from)
                        e.motion.forced_waypoint = P:node_pos(e.nav_path)
                        e.render.sprites[1].name = "raise"
                        e.custom_spawn_data = custom_data

                        queue_insert(store, e)
                        log.paranoid("%06.2f : points_spawner (%06.2f) %s - %s from:%s,%s to:%s,%s pi:%s spi:%s",
                            store.tick_ts, ts, current_wave, template, p_from.x, p_from.y, p_to.x, p_to.y, p_pi, p_spi)
                    end

                    ptr = ptr + 1
                end

                coroutine.yield()
            end
        else
            while this.manual_wave and current_wave == this.manual_wave or not store.waves_finished and current_wave ==
                store.wave_group_number do
                if this.interrupt then
                    goto label_191_0
                end

                coroutine.yield()
            end
        end

        coroutine.yield()
    end

    ::label_191_0::

    log.debug("points_spawner interrupted")
    queue_remove(store, this)
end

scripts.mod_dracula_lifesteal = {}

function scripts.mod_dracula_lifesteal.update(this, store)
    local m = this.modifier
    local source = store.entities[m.source_id]
    local target = store.entities[m.target_id]

    m.ts = store.tick_ts

    local last_ts = store.tick_ts

    SU.stun_inc(target)

    while not source.health.dead and store.tick_ts - m.ts < m.duration do
        if store.tick_ts - last_ts > this.cycle_time then
            last_ts = store.tick_ts
            source.health.hp = km.clamp(0, source.health.hp_max, source.health.hp + this.heal_hp)
        end

        coroutine.yield()
    end

    SU.stun_dec(target)

    local d = E:create_entity("damage")

    d.value = this.damage
    d.source_id = this.id
    d.target_id = target.id
    d.damage_type = target.hero and DAMAGE_TRUE or DAMAGE_INSTAKILL

    queue_damage(store, d)
    queue_remove(store, this)
end

scripts.decal_stage22_reptile = {}

function scripts.decal_stage22_reptile.update(this, store)
    while true do
        if this.ui.clicked then
            U.y_animation_play(this, "clicked", nil, store.tick_ts)
            U.animation_start(this, "climb", nil, store.tick_ts, true)
            U.set_destination(this, V.v(this.pos.x, this.pos.y + this.climb_distance))

            while not U.walk(this, store.tick_length) do
                coroutine.yield()
            end

            -- AC:got("FOUND_ME")
            queue_remove(store, this)

            return
        end

        coroutine.yield()
    end
end

scripts.eb_saurian_king = {}

function scripts.eb_saurian_king.get_info(this)
    local m = E:get_template("mod_saurian_king_tongue")
    local min, max = m.modifier.damage_min, m.modifier.damage_max

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_saurian_king.insert(this, store, script)
    this.melee.order = U.attack_order(this.melee.attacks)

    return true
end

function scripts.eb_saurian_king.update(this, store, script)
    local ha = this.timed_attacks.list[1]

    local function ready_to_hammer()
        return store.tick_ts - ha.ts > ha.cooldown
    end

    local function hammer_hit(idx)
        S:queue("SaurianKingBossQuake", {
            delay = fts(4)
        })

        local a = E:create_entity("aura_screen_shake")

        a.aura.amplitude = idx / #ha.max_damages

        queue_insert(store, a)

        local dmin, dmax = ha.min_damages[idx], ha.max_damages[idx]
        local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, ha.damage_radius, ha.vis_flags,
            ha.vis_bans)

        if targets then
            for _, target in pairs(targets) do
                local dist_factor = U.dist_factor_inside_ellipse(target.pos, this.pos, ha.damage_radius,
                    ha.max_damage_radius)
                local d = E:create_entity("damage")

                d.damage_type = ha.damage_type
                d.value = math.ceil(dmax - (dmax - dmin) * dist_factor)
                d.target_id = target.id
                d.source_id = this.id

                queue_damage(store, d)
            end
        end

        local fx = E:create_entity("decal_saurian_king_hammer")
        local o = ha.fx_offsets[km.zmod(idx, 2)]

        fx.pos = V.v(this.pos.x + o.x * (this.render.sprites[1].flip_x and -1 or 1), o.y + this.pos.y)
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end

    ha.ts = store.tick_ts

    ::label_281_0::

    while true do
        if this.health.dead then
            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)

            return true
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)

            ha.ts = store.tick_ts

            coroutine.yield()
        else
            if ready_to_hammer() then
                U.y_animation_play(this, ha.animations[1], nil, store.tick_ts)

                for i = 1, #ha.max_damages / 2 do
                    if this.health.dead then
                        goto label_281_1
                    end

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    U.animation_start(this, ha.animations[2], nil, store.tick_ts)
                    S:queue(ha.sound, {
                        delay = fts(3)
                    })
                    U.y_wait(store, ha.hit_times[1])

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    hammer_hit(2 * i - 1)
                    S:queue(ha.sound, {
                        delay = fts(10)
                    })
                    U.y_wait(store, ha.hit_times[2])

                    if this.unit.is_stunned then
                        goto label_281_1
                    end

                    hammer_hit(2 * i)
                    U.y_animation_wait(this)
                end

                ha.ts = store.tick_ts
            end

            ::label_281_1::

            local ok, blocker = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_hammer()
            end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_281_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_hammer() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_281_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.mod_saurian_king_tongue = {}

function scripts.mod_saurian_king_tongue.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        return false
    end

    local d = E:create_entity("damage")

    d.damage_type = target.hero and DAMAGE_TRUE or DAMAGE_EAT
    d.value = math.random(m.damage_min, m.damage_max)
    d.target_id = target.id
    d.source_id = this.id

    queue_damage(store, d)

    return false
end

function scripts.hero_alien.insert(this, store, script)
    this.hero.fn_level_up(this, store)

    this.melee.order = U.attack_order(this.melee.attacks)
    this.ranged.order = U.attack_order(this.ranged.attacks)

    return true
end

function scripts.hero_alien.update(this, store, script)
    local h = this.health
    local he = this.hero
    local a, skill, brk, sta

    U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_hero_new_rally(store, this) then
                    goto label_353_1
                end
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
            end

            a = this.timed_attacks.list[1]
            skill = this.hero.skills.abduction

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local trigger = U.find_random_enemy(store.enemies, this.pos, 0, a.range, a.vis_flags, a.vis_bans,
                    function(v)
                        return not table.contains(a.invalid_templates, v.template_name) and
                                   (skill.level == 3 or v.health.hp <= a.total_hp) and
                                   P:is_node_valid(v.nav_path.pi, v.nav_path.ni + 10) and
                                   P:is_node_valid(v.nav_path.pi, v.nav_path.ni - 10)
                    end)

                if not trigger then
                    SU.delay_attack(store, a, 0.13333333333333333)

                    goto label_353_0
                end

                a.ts = store.tick_ts

                SU.hero_gain_xp_from_skill(this, skill)
                S:queue(a.sound)
                U.animation_start(this, a.animation, nil, store.tick_ts)
                U.y_wait(store, a.spawn_time)

                local abduction_hp, abduction_count = trigger.health.hp, 1
                local targets = U.find_enemies_in_range(store.enemies, trigger.pos, 0, a.attack_radius, a.vis_flags,
                    a.vis_bans, function(v)
                        local ok = v ~= trigger and abduction_hp + v.health.hp <= a.total_hp and abduction_count <
                                       a.total_targets and not table.contains(a.invalid_templates, v.template_name) and
                                       P:is_node_valid(v.nav_path.pi, v.nav_path.ni + 10) and
                                       P:is_node_valid(v.nav_path.pi, v.nav_path.ni - 10)

                        if ok then
                            abduction_hp = abduction_hp + v.health.hp
                            abduction_count = abduction_count + 1
                        end

                        return ok
                    end)

                if targets then
                    table.insert(targets, trigger)
                else
                    targets = {trigger}
                end

                if targets then
                    local e = E:create_entity(a.entity)

                    e.pos = V.vclone(trigger.pos)
                    e.targets = targets

                    queue_insert(store, e)

                    e.owner = this
                end

                U.y_animation_wait(this)

                goto label_353_1
            end

            ::label_353_0::

            a = this.timed_attacks.list[2]
            skill = this.hero.skills.purificationprotocol

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local target = U.find_foremost_enemy(store.enemies, this.pos, 0, a.range, nil, a.vis_flags, a.vis_bans)

                if not target then
                    SU.delay_attack(store, a, 0.13333333333333333)
                else
                    a.ts = store.tick_ts

                    SU.hero_gain_xp_from_skill(this, skill)
                    S:queue(a.sound)
                    U.animation_start(this, a.animation, nil, store.tick_ts)
                    U.y_wait(store, a.spawn_time)

                    local e = E:create_entity(a.entity)

                    e.pos = V.vclone(target.pos)
                    e.target_id = target.id

                    queue_insert(store, e)

                    e.owner = this

                    U.y_animation_wait(this)

                    goto label_353_1
                end
            end

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                -- block empty
            else
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk or sta ~= A_NO_TARGET then
                    -- block empty
                elseif SU.soldier_go_back_step(store, this) then
                    -- block empty
                else
                    SU.soldier_idle(store, this)
                    SU.soldier_regen(store, this)
                end
            end
        end

        ::label_353_1::

        coroutine.yield()
    end
end

scripts.alien_glaive = {}

function scripts.alien_glaive.update(this, store)
    local b = this.bullet
    local mspeed = b.min_speed
    local target, ps
    local bounce_count = 0

    U.animation_start(this, "alien_glaive", nil, store.tick_ts, true)

    b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

    if b.particles_name then
        ps = E:create_entity(b.particles_name)
        ps.particle_system.track_id = this.id

        queue_insert(store, ps)
    end

    ::label_356_0::

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
        target = store.entities[b.target_id]

        if target and target.health and not target.health.dead then
            b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
        end

        mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
        mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
        b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
        this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

        coroutine.yield()
    end

    if target and not target.health.dead then
        local d = SU.create_bullet_damage(b, target.id, this.id)

        queue_damage(store, d)

        if band(target.vis.bans, F_MOD) == 0 then
            local mod = E:create_entity(b.mod)
            mod.modifier.source_id = b.source_id
            mod.modifier.target_id = target.id
            mod.modifier.ts = store.tick_ts
            queue_insert(store, mod)
        end
    end

    if b.hit_fx then
        local sfx = E:create_entity(b.hit_fx)

        sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
        sfx.render.sprites[1].ts = store.tick_ts
        sfx.render.sprites[1].runs = 0

        queue_insert(store, sfx)
    end

    if bounce_count == 0 or math.random() < this.bounce_chance then
        local target = U.find_foremost_enemy_with_flying_preference(store.enemies, this.pos, 0, this.bounce_range,nil,
            b.vis_flags, b.vis_bans,
            function(v)
                return v ~= target
            end)

        if target then
            S:queue("HeroAlienDiscoBounce")

            bounce_count = bounce_count + 1
            b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
            b.target_id = target.id

            goto label_356_0
        end
    end

    queue_remove(store, this)
end

scripts.alien_purification_drone = {}

function scripts.alien_purification_drone.update(this, store)
    local sid = 2
    local attacking = false
    local target = store.entities[this.target_id]
    local start_ts, switch_ts
    local function y_switch_target(new_target)
        this.target_id = new_target.id
        attacking = false

        S:stop(this.sound_events.loop)

        this.render.sprites[1].hidden = true
        this.render.sprites[3].hidden = true

        U.y_animation_play(this, "disappear_short", nil, store.tick_ts, 1, sid)

        this.pos = new_target.pos

        U.y_animation_play(this, "appear_short", nil, store.tick_ts, 1, sid)

        switch_ts = store.tick_ts
    end

    if target and not target.health.dead then
        this.pos = target.pos
        this.render.sprites[2].flip_x = target.render.sprites[1].flip_x
    end

    U.y_animation_play(this, "appear_long", nil, store.tick_ts, 1, sid)

    start_ts = store.tick_ts
    switch_ts = store.tick_ts

    while true do
        if store.tick_ts - start_ts > this.duration + 1e-06 then
            break
        end

        target = store.entities[this.target_id]

        if target and store.tick_ts - switch_ts > this.switch_targets_every then
            local new_target = U.find_random_enemy(store.enemies, this.pos, 0, this.jump_range, this.vis_flags,
                this.vis_bans, function(v)
                    return v.id ~= target.id
                end)

            if new_target then
                target = new_target

                y_switch_target(new_target)
            end
        end

        if not target or store.tick_ts - switch_ts > 0.3 and
            (target.health.dead or band(this.vis_flags, target.vis.bans) ~= 0 or band(this.vis_bans, target.vis.flags) ~=
                0) then
            target = U.find_random_enemy(store.enemies, this.pos, 0, this.jump_range, this.vis_flags, this.vis_bans)

            if target then
                y_switch_target(target)
            else
                break
            end
        end

        if not attacking then
            attacking = true

            S:queue(this.sound_events.loop)

            this.pos = target.pos
            this.render.sprites[1].hidden = false
            this.render.sprites[3].hidden = false

            U.animation_start(this, "idle", target.render.sprites[1].flip_x, store.tick_ts, true, sid)
        end

        this.render.sprites[2].flip_x = target.render.sprites[1].flip_x

        if store.tick_ts - this.dps.ts >= this.dps.damage_every then
            this.dps.ts = store.tick_ts

            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = target.id
            d.value = this.dps.damage_max
            d.damage_type = this.dps.damage_type

            queue_damage(store, d)
            if band(target.vis.flags, F_BOSS) == 0 and band(target.vis.bans, F_STUN) == 0 then
                local m = E:create_entity(this.mod)
                m.modifier.target_id = target.id
                m.modifier.source_id = this.id
                m.modifier.ts = store.tick_ts
                queue_insert(store, m)
            end
        end

        coroutine.yield()
    end

    S:stop(this.sound_events.loop)
    S:queue(this.sound_events.finish)

    this.render.sprites[1].hidden = true
    this.render.sprites[3].hidden = true

    U.y_animation_play(this, "disappear_long", nil, store.tick_ts, 1, sid)
    queue_remove(store, this)
end

scripts.alien_abduction_ship = {}

function scripts.alien_abduction_ship.update(this, store)
    local enemy_decals = {}

    for _, e in pairs(this.targets) do
        U.animation_start(e, "idle", nil, store.tick_ts, true)

        local es = E:create_entity("abducted_enemy_decal")

        es.pos.x, es.pos.y = e.pos.x, e.pos.y
        es.render = table.deepclone(e.render)
        es.tween.disabled = true

        queue_insert(store, es)
        table.insert(enemy_decals, es)

        local d = E:create_entity("damage")

        d.damage_type = DAMAGE_EAT
        d.source_id = this.id
        d.target_id = e.id

        queue_damage(store, d)
    end

    this.tween.ts = store.tick_ts

    U.y_wait(store, 1.5)

    this.render.sprites[3].hidden = nil
    this.render.sprites[3].ts = store.tick_ts

    U.y_wait(store, fts(10))

    for i, ed in ipairs(enemy_decals) do
        ed.tween.disabled = nil
        ed.tween.ts = store.tick_ts + (i - 1) * 0.1
    end

    U.y_animation_wait(this, 3)

    this.render.sprites[3].hidden = true
end

function scripts.hero_voodoo_witch.insert(this, store)
    this.hero.fn_level_up(this, store, true)

    this.ranged.order = U.attack_order(this.ranged.attacks)
    this.melee.order = U.attack_order(this.melee.attacks)

    local e = E:create_entity("voodoo_witch_death_aura")
    e.aura.source_id = this.id
    e.aura.ts = store.tick_ts
    queue_insert(store, e)

    local e = E:create_entity("voodoo_witch_skull_aura")
    e.aura.source_id = this.id
    e.aura.ts = store.tick_ts
    queue_insert(store, e)

    return true
end

function scripts.hero_voodoo_witch.update(this, store)
    local h = this.health
    local he = this.hero
    local a, skill, brk, sta

    U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_hero_new_rally(store, this) then
                    goto label_458_0
                end
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
            end

            a = this.timed_attacks.list[1]
            skill = this.hero.skills.voodoomagic

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local targets_in_range = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range,
                    a.vis_flags, a.vis_bans)

                if not targets_in_range then
                    SU.delay_attack(store, a, 0.267)
                else
                    local targets_per_type = {}

                    for _, t in pairs(store.enemies) do
                        if not t.health.dead then
                            if not targets_per_type[t.template_name] then
                                targets_per_type[t.template_name] = {t}
                            else
                                table.insert(targets_per_type[t.template_name], t)
                            end
                        end
                    end

                    local targets

                    for _, t in pairs(targets_in_range) do
                        local v = targets_per_type[t.template_name]

                        if v and #v >= a.min_count then
                            targets = v
                            break
                        end
                    end

                    if not targets then
                        SU.delay_attack(store, a, 0.267)
                    else
                        table.sort(targets, function(e1, e2)
                            return V.dist(e1.pos.x, e1.pos.y, this.pos.x, this.pos.y) <
                                       V.dist(e2.pos.x, e2.pos.y, this.pos.x, this.pos.y)
                        end)

                        targets = table.slice(targets, 1, a.count)

                        S:queue(a.sound)
                        U.animation_start(this, a.animation, nil, store.tick_ts)

                        local start_ts = store.tick_ts

                        while store.tick_ts - start_ts < fts(10) do
                            if SU.hero_interrupted(this) then
                                goto label_458_0
                            end

                            coroutine.yield()
                        end

                        a.ts = store.tick_ts

                        SU.hero_gain_xp_from_skill(this, skill)

                        for _, t in pairs(targets) do
                            if not t.health.dead and store.entities[t.id] then
                                local m = E:create_entity(a.mod_fx)

                                m.modifier.target_id = t.id
                                m.modifier.source_id = this.id

                                queue_insert(store, m)
                            end
                        end

                        U.y_wait(store, fts(16))

                        for _, t in pairs(targets) do
                            if not t.health.dead and store.entities[t.id] then
                                local d = E:create_entity("damage")

                                d.source_id = this.id
                                d.target_id = t.id
                                d.value = a.damage
                                d.damage_type = a.damage_type

                                queue_damage(store, d)

                                local m = E:create_entity(a.mod_slow)

                                m.modifier.target_id = t.id
                                m.modifier.source_id = this.id

                                queue_insert(store, m)
                            end
                        end

                        while not U.animation_finished(this) do
                            if SU.hero_interrupted(this) then
                                break
                            end

                            coroutine.yield()
                        end

                        goto label_458_0
                    end
                end
            end

            brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

            if brk or sta ~= A_NO_TARGET then
                -- block empty
            else
                brk, sta = SU.y_soldier_ranged_attacks(store, this)

                if brk then
                    -- block empty
                elseif SU.soldier_go_back_step(store, this) then
                    -- block empty
                else
                    SU.soldier_idle(store, this)
                    SU.soldier_regen(store, this)
                end
            end
        end

        ::label_458_0::

        coroutine.yield()
    end
end

scripts.voodoo_witch_skull_aura = {}

function scripts.voodoo_witch_skull_aura.update(this, store)
    local a = this.aura

    a.ts = store.tick_ts

    local last_ts = store.tick_ts
    local source = store.entities[a.source_id]
    local rot_phase = 0

    this.pos = source.pos

    local last_pos = V.vclone(this.pos)

    while true do
        if not source.health.dead and store.tick_ts - last_ts >= a.cycle_time then
            last_ts = store.tick_ts

            local targets = U.find_targets_in_range(store.entities, this.pos, 0, a.radius, F_NONE, a.vis_bans)

            if targets then
                for _, target in pairs(targets) do
                    if target.enemy or (target.soldier and band(target.vis.bans, a.vis_flags) == 0) then
                        local m = E:create_entity("mod_voodoo_witch_skull_spawn")

                        m.modifier.source_id = this.id
                        m.modifier.target_id = target.id

                        queue_insert(store, m)
                    end
                end
            end
        end

        if V.veq(source.pos, last_pos) then
            rot_phase = rot_phase + this.rot_speed * store.tick_length
        end

        last_pos.x, last_pos.y = this.pos.x, this.pos.y

        for i, t in ipairs(this.skulls) do
            local a = (i * 2 * math.pi / #this.skulls + rot_phase) % (2 * math.pi)

            t.rot_dest = U.point_on_ellipse(this.pos, this.rot_radius, a)
            t.rot_flip = source.render.sprites[1].flip_x
        end

        coroutine.yield()
    end
end

scripts.mod_voodoo_witch_skull_spawn = {}

function scripts.mod_voodoo_witch_skull_spawn.update(this, store)
    this.modifier.ts = store.tick_ts

    local cg = store.count_groups[this.count_group_type]

    while true do
        local target = store.entities[this.modifier.target_id]

        if not target or store.tick_ts - this.modifier.ts > this.modifier.duration then
            break
        end

        if target.health.dead and (not cg[this.count_group_name] or cg[this.count_group_name] < this.skull_count) then
            local s = E:create_entity("voodoo_witch_skull")

            s.owner_id = this.modifier.source_id
            s.spawner_id = target.id

            queue_insert(store, s)

            break
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.voodoo_witch_skull = {}

function scripts.voodoo_witch_skull.update(this, store)
    local spawner = store.entities[this.spawner_id]
    local owner = store.entities[this.owner_id]

    if not owner or not spawner then
        log.debug("no owner or spawner. removing skull")
        queue_remove(store, this)

        return
    end

    table.insert(owner.skulls, this)

    this.pos = V.vclone(spawner.pos)

    local hero = store.entities[owner.aura.source_id]
    local skill = hero.hero.skills[this.sacrifice.xp_from_skill]
    local s = this.render.sprites[1]

    s.offset.x = spawner.unit.mod_offset.x
    s.offset.y = spawner.unit.mod_offset.y

    local fm = this.force_motion
    local fl_dh = this.max_flight_height - this.min_flight_height
    local fl_h = this.min_flight_height + fl_dh / 2
    local fl_step = this.flight_speed * store.tick_length
    local fl_dest = fl_h
    local ps = E:create_entity("ps_voodoo_witch_skull")

    ps.particle_system.track_id = this.id
    ps.particle_system.emit = false
    ps.particle_system.track_offset = V.v(s.offset.x, s.offset.y)

    queue_insert(store, ps)

    local function move_step(dest, bob)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local df = (not fm.ramp_radius or dist > fm.ramp_radius) and 1 or math.max(dist / fm.ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)

        local sx, sy = V.mul(store.tick_length, fm.v.x, fm.v.y)

        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
        fm.a.x, fm.a.y = V.mul(-0.05 / store.tick_length, fm.v.x, fm.v.y)

        if bob then
            fl_dest = fl_h + 0.5 * fl_dh * math.sin(2 * math.pi * store.tick_ts / this.flight_period)
        end

        if math.abs(fl_dest - s.offset.y) < fl_step then
            s.offset.y = fl_dest
        else
            s.offset.y = s.offset.y + (fl_dest > s.offset.y and 1 or -1) * fl_step
        end

        ps.particle_system.track_offset.x = s.offset.x
        ps.particle_system.track_offset.y = s.offset.y

        return dist < fm.max_v * store.tick_length
    end

    while true do
        if hero.health.dead then
            break
        end

        if this.max_shots <= 0 then
            local sa = this.sacrifice

            if sa.disabled then
                break
            end

            local target = U.find_nearest_enemy(store.enemies, this.pos, sa.min_range, sa.max_range, sa.vis_flags,
                sa.vis_bans)

            if not target then
                -- block empty
            else
                S:queue(sa.sound)

                fm.max_v = sa.max_v
                fm.max_a = sa.max_a
                fm.ramp_radius = nil
                fm.a_step = sa.a_step
                fl_dest = target.unit.hit_offset.y
                ps.particle_system.emit = true

                while not move_step(target.pos, false) do
                    s.flip_x = this.pos.x > target.pos.x

                    coroutine.yield()
                end

                S:queue(sa.sound_hit)

                local d = E:create_entity("damage")

                d.value = sa.damage
                d.source_id = this.id
                d.target_id = target.id
                d.damage_type = sa.damage_type

                queue_damage(store, d)

                if hero and skill then
                    SU.hero_gain_xp_from_skill(hero, skill)
                end

                break
            end
        end

        local a = this.ranged.attacks[1]

        if store.tick_ts - a.ts > a.cooldown then
            local target = U.find_nearest_enemy(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                a.vis_bans)

            if not target then
                -- block empty
            else
                a.ts = store.tick_ts

                local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

                U.animation_start(this, an, af, store.tick_ts, false)
                S:queue(a.sound)

                while store.tick_ts - a.ts < a.shoot_time do
                    move_step(this.rot_dest, true)
                    coroutine.yield()
                end

                local b = E:create_entity(a.bullet)

                b.pos.x, b.pos.y = this.pos.x, this.pos.y + this.render.sprites[1].offset.y
                b.bullet.from = V.vclone(b.pos)
                b.bullet.to = V.vclone(target.pos)
                b.bullet.to.x = b.bullet.to.x + target.unit.hit_offset.x
                b.bullet.to.y = b.bullet.to.y + target.unit.hit_offset.y
                b.bullet.target_id = target.id
                b.bullet.source_id = this.id
                b.render.sprites[1].scale.x = 0.75
                b.render.sprites[1].scale.y = 0.75
                b.bullet.xp_dest_id = hero.id

                queue_insert(store, b)

                this.max_shots = this.max_shots - 1

                while not U.animation_finished(this) do
                    move_step(this.rot_dest, true)
                    coroutine.yield()
                end
            end
        end

        U.animation_start(this, "idle", this.rot_flip, store.tick_ts, true)
        move_step(this.rot_dest, true)
        coroutine.yield()
    end

    table.removeobject(owner.skulls, this)

    s.hidden = true

    local fx = E:create_entity("fx_voodoo_witch_skull_explosion")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y + this.render.sprites[1].offset.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)

    if ps.particle_system.emit then
        ps.particle_system.emit = false

        U.y_wait(store, ps.particle_system.particle_lifetime[2])
    end

    queue_remove(store, this)
end

scripts.voodoo_witch_death_aura = {}

function scripts.voodoo_witch_death_aura.update(this, store)
    local a = this.aura

    a.ts = store.tick_ts

    local last_ts = store.tick_ts
    local source = store.entities[a.source_id]
    local inflicted_damage = 0

    this.pos = source.pos

    while true do
        if not source.health.dead and store.tick_ts - last_ts >= a.cycle_time then
            last_ts = store.tick_ts

            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

            if targets then
                for _, target in pairs(targets) do
                    local d = E:create_entity("damage")

                    d.damage_type = a.damage_type
                    d.value = a.damage
                    d.target_id = target.id
                    d.source_id = this.id

                    queue_damage(store, d)

                    inflicted_damage = inflicted_damage + a.damage

                    local m = E:create_entity(this.mod_slow)

                    m.modifier.source_id = this.id
                    m.modifier.target_id = target.id
                    m.render.sprites[1].name = m.render.sprites[1].size_names[target.unit.size]
                    m.render.sprites[1].flip_x = target.render.sprites[1].flip_x
                    m.tween.ts = store.tick_ts

                    queue_insert(store, m)
                end
            end
        end

        if inflicted_damage * a.xp_gain_factor > 1 then
            SU.hero_gain_xp(source, inflicted_damage * a.xp_gain_factor, this.template_name)

            inflicted_damage = 0
        end

        this.render.sprites[1].hidden = source.health.dead
        this.render.sprites[2].hidden = source.health.dead

        coroutine.yield()
    end
end

scripts.mod_voodoo_witch_magic = {}

function scripts.mod_voodoo_witch_magic.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead then
        return false
    end

    this.render.sprites[1].ts = store.tick_ts
    this.render.sprites[1].flip_x = not target.render.sprites[1].flip_x

    return true
end

function scripts.hero_crab.on_damage(this, store, damage)
    log.paranoid("  CRAB DAMAGE: %s", damage.value)

    local h = this.health
    local i = this.invuln

    if (i.active or i.pending) and band(damage.damage_type, i.exclude_damage_types) == 0 then
        scripts.heal(this, damage.value * 0.5)
        return false
    end

    if i.disabled or this.unit.is_stunned or store.tick_ts - i.ts < i.cooldown or math.random() > i.chance then
        return true
    end

    local predicted_damage = U.predict_damage(this, damage)

    if h.hp - predicted_damage < i.trigger_factor * h.hp_max then
        i.pending = true
        return false
    end

    return true
end

function scripts.hero_crab.insert(this, store, script)
    this.hero.fn_level_up(this, store)
    this.melee.order = U.attack_order(this.melee.attacks)
    return true
end

function scripts.hero_crab.update(this, store, script)
    local h = this.health
    local he = this.hero
    local a, skill, brk, sta

    U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                local b = this.burrow
                local r = this.nav_rally

                if not b.disabled and V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > b.min_distance then
                    r.new = false

                    U.unblock_target(store, this)

                    local vis_bans = this.vis.bans

                    this.vis.bans = F_ALL
                    this.health.immune_to = F_ALL

                    local original_speed = this.motion.max_speed
                    U.speed_inc_self(this, b.init_accel)
                    this.unit.marker_hidden = true

                    S:queue(this.sound_events.change_rally_point)
                    S:queue(this.sound_events.burrow_in)
                    U.y_animation_play(this, "burrow_in", r.pos.x < this.pos.x, store.tick_ts)

                    this.health_bar._orig_offset = this.health_bar.offset
                    this.health_bar.offset = b.health_bar_offset
                    this.unit._orig_hit_offset = this.unit.hit_offset
                    this.unit.hit_offset = b.hit_offset
                    this.unit._orig_mod_offset = this.unit.mod_offset
                    this.unit.mod_offset = b.mod_offset

                    local water_trail = E:create_entity("ps_water_trail")

                    water_trail.particle_system.track_id = this.id
                    water_trail.particle_system.emit = false
                    water_trail.particle_system.z = Z_OBJECTS - 1

                    queue_insert(store, water_trail)

                    ::label_400_0::

                    local last_t = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)
                    local dest = r.pos
                    local n = this.nav_grid
                    while not V.veq(this.pos, dest) do
                        local w = table.remove(n.waypoints, 1) or dest

                        U.set_destination(this, w)

                        local ani = last_t == TERRAIN_WATER and "burrow_water" or "burrow_land"
                        local an, af = U.animation_name_facing_point(this, ani, this.motion.dest)

                        U.animation_start(this, an, af, store.tick_ts, true)

                        while not this.motion.arrived do
                            if r.new then
                                r.new = false

                                goto label_400_0
                            end

                            U.walk(this, store.tick_length, b.extra_speed)
                            coroutine.yield()

                            this.motion.speed.x, this.motion.speed.y = 0, 0

                            local t = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)

                            if t ~= last_t then
                                if last_t and bor(last_t, t) == bor(TERRAIN_WATER, TERRAIN_LAND) then
                                    local fx = E:create_entity("fx_enemy_splash")

                                    fx.render.sprites[1].name = "big"
                                    fx.render.sprites[1].ts = store.tick_ts
                                    fx.render.sprites[1].sort_y_offset = 0
                                    fx.pos = V.vclone(this.pos)

                                    queue_insert(store, fx)

                                    if this.sound_events and this.sound_events.water_splash then
                                        S:queue(this.sound_events.water_splash)
                                    end
                                end

                                local in_water = t == TERRAIN_WATER
                                local ani = in_water and "burrow_water" or "burrow_land"
                                local an, af = U.animation_name_facing_point(this, ani, this.motion.dest)

                                U.animation_start(this, an, af, store.tick_ts, true)

                                water_trail.particle_system.emit = in_water
                                last_t = t
                            end
                        end
                    end
                    if this.motion.real_speed >= b.stun_speed and store.tick_ts - b.ts >= b.cooldown then
                        local enemies = U.find_enemies_in_range(store.enemies, this.pos, 0, b.radius, F_STUN, bor(F_BOSS, F_FLYING))
                        if enemies then
                            local rate = (this.motion.real_speed - 60) / (b.stun_speed - 60)
                            for _, e in pairs(enemies) do
                                if not e.health.dead then
                                    local mod = E:create_entity("mod_stun_burrow")
                                    mod.modifier.target_id = e.id
                                    mod.modifier.source_id = this.id
                                    queue_insert(store, mod)
                                    local d = E:create_entity("damage")
                                    d.source_id = this.id
                                    d.target_id = e.id
                                    d.value = (b.damage + this.damage_buff) * this.unit.damage_factor * rate
                                    d.damage_type = DAMAGE_EXPLOSION
                                    queue_damage(store, d)
                                end
                            end
                            SU.hero_gain_xp_from_skill(this, this.hero.skills.burrow)
                            b.ts = store.tick_ts
                        end
                        for i, pos in pairs({V.v(10, -16), V.v(-12, -14), V.v(22, -1), V.v(-24, -1)}) do
                            local fx = E:create_entity("fx")

                            fx.render.sprites[1].name = "fx_hero_crab_quake"
                            fx.render.sprites[1].ts = store.tick_ts + (i - 1) * 0.1
                            fx.render.sprites[1].scale = V.v(0.8, 0.8)
                            fx.render.sprites[1].alpha = 166
                            fx.render.sprites[1].anchor.y = 0.24
                            fx.pos.x, fx.pos.y = this.pos.x + pos.x, this.pos.y + pos.y

                            queue_insert(store, fx)
                        end
                    end
                    this.health_bar.offset = this.health_bar._orig_offset
                    this.unit.hit_offset = this.unit._orig_hit_offset
                    this.unit.mod_offset = this.unit._orig_mod_offset

                    S:queue(this.sound_events.burrow_out)
                    U.y_animation_play(this, "burrow_out", r.pos.x < this.pos.x, store.tick_ts)
                    U.update_max_speed(this, original_speed)
                    this.vis.bans = vis_bans
                    this.health.immune_to = 0
                    this.unit.marker_hidden = nil
                elseif SU.y_hero_new_rally(store, this) then
                    goto label_400_2
                end
            end

            if this.invuln and this.invuln.pending then
                local e = E:create_entity(this.invuln.aura_name)

                e.aura.ts = store.tick_ts
                e.aura.source_id = this.id

                queue_insert(store, e)

                local skill = this.hero.skills.battlehardened

                SU.hero_gain_xp_from_skill(this, skill)
                S:queue(this.invuln.sound)
                U.y_animation_play(this, this.invuln.animation, nil, store.tick_ts)

                this.invuln.ts = store.tick_ts
                this.invuln.pending = nil
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
            end

            a = this.timed_attacks.list[1]
            skill = this.hero.skills.pincerattack

            if not a.disabled and store.tick_ts - a.ts > a.cooldown then
                local left_targets, right_targets = {}, {}
                local targets = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                    a.vis_bans, function(v)
                        local px, py = this.pos.x, this.pos.y
                        local vx, vy = v.pos.x, v.pos.y
                        local rx, ry = a.damage_size.x, a.damage_size.y

                        if vy >= py - ry / 2 and vy < py + ry / 2 then
                            if px < vx and vx < px + rx then
                                table.insert(right_targets, v)

                                return true
                            elseif vx < px and vx > px - rx then
                                table.insert(left_targets, v)

                                return true
                            end
                        end

                        return false
                    end)

                if not targets or #left_targets < a.min_count and #right_targets < a.min_count then
                    SU.delay_attack(store, a, 0.13333333333333333)

                    goto label_400_1
                end

                if #left_targets > #right_targets then
                    targets = left_targets
                else
                    targets = right_targets
                end

                local start_ts = store.tick_ts

                S:queue(a.sound)

                local an, af = U.animation_name_facing_point(this, a.animation, targets[1].pos)

                U.animation_start(this, an, af, store.tick_ts, false)

                local flip_x = this.render.sprites[1].flip_x

                while store.tick_ts - start_ts < a.hit_time do
                    if SU.hero_interrupted(this) then
                        goto label_400_2
                    end

                    coroutine.yield()
                end

                a.ts = start_ts

                SU.hero_gain_xp_from_skill(this, skill)

                targets = U.find_enemies_in_range(store.enemies, this.pos, a.min_range, a.max_range, a.vis_flags,
                    a.vis_bans, function(v)
                        local px, py = this.pos.x, this.pos.y
                        local vx, vy = v.pos.x, v.pos.y
                        local rx, ry = a.damage_size.x, a.damage_size.y

                        if vy >= py - ry / 2 and vy < py + ry / 2 then
                            if not flip_x and px < vx and vx < px + rx then
                                return true
                            elseif flip_x and vx < px and vx > px - rx then
                                return true
                            end
                        end

                        return false
                    end)

                if targets then
                    for _, t in pairs(targets) do
                        local d = E:create_entity("damage")

                        d.source_id = this.id
                        d.target_id = t.id
                        d.value = math.random(a.damage_min, a.damage_max)
                        d.damage_type = a.damage_type

                        queue_damage(store, d)
                    end
                end

                while not U.animation_finished(this) do
                    if SU.hero_interrupted(this) then
                        goto label_400_2
                    end

                    coroutine.yield()
                end

                goto label_400_2

                this.render.sprites[1].flip_x = flip_x
            end

            ::label_400_1::

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                -- block empty
            else
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk or sta ~= A_NO_TARGET then
                    -- block empty
                elseif SU.soldier_go_back_step(store, this) then
                    -- block empty
                else
                    SU.soldier_idle(store, this)
                    SU.soldier_regen(store, this)
                end
            end
        end

        ::label_400_2::

        coroutine.yield()
    end
end

scripts.aura_crab_invuln = {}

function scripts.aura_crab_invuln.update(this, store)
    local hero = store.entities[this.aura.source_id]

    this.pos = hero.pos

    local invuln = hero.invuln
    local vis_bans = 0
    local a = this.aura

    vis_bans = hero.vis.bans
    hero.vis.bans = bor(hero.vis.bans, F_STUN)
    hero.invuln.active = true
    -- hero.health.immune_to = F_ALL
    this.tween.ts = store.tick_ts

    U.y_wait(store, fts(20))

    this.tween.props[3].disabled = true
    this.tween.props[4].disabled = nil

    while not this.interrupt and not hero.health.dead and not hero.nav_rally.new and store.tick_ts - a.ts < a.duration do
        coroutine.yield()
    end

    hero.vis.bans = vis_bans
    -- hero.health.immune_to = 0
    hero.invuln.active = false
    this.tween.ts = store.tick_ts - a.duration
    this.tween.props[4].disabled = true

    U.y_wait(store, fts(15))
    queue_remove(store, this)

end

scripts.decal_bravebark_rootspike = {}

function scripts.decal_bravebark_rootspike.update(this, store)
    this.render.sprites[1].hidden = true
    this.render.sprites[1].flip_x = math.random() < 0.5

    U.y_wait(store, this.delay)

    local e = E:create_entity(this.hole_decal)

    e.pos.x, e.pos.y = this.pos.x, this.pos.y
    e.render.sprites[1].scale = V.vv(this.scale)

    queue_insert(store, e)

    this.render.sprites[1].hidden = false
    this.render.sprites[1].scale = V.vv(this.scale)

    U.y_animation_play(this, "in", nil, store.tick_ts)
    U.y_wait(store, this.hold_duration)

    e.tween.disabled = nil
    e.tween.ts = store.tick_ts

    U.y_animation_play(this, "out", nil, store.tick_ts)
    queue_remove(store, this)
end

scripts.decal_arachnomancer_mini_spider = {}

function scripts.decal_arachnomancer_mini_spider.update(this, store)
    local delta_y, dest_y = 0, 0
    local delta_speed = this.motion.real_speed * U.frandom(0.8, 1.2) * km.rand_sign()
    local state, last_state
    local ow = this.owner
    local oo = this.spider_offsets[this.spider_idx]
    local os = ow.render.sprites[1]

    while true do
        if ow.health.dead then
            U.y_animation_play(this, "death", nil, store.tick_ts)
            queue_remove(store, this)

            return
        end

        state = os.name

        if state ~= last_state then
            if string.starts(state, "walking") then
                U.animation_start(this, state, os.flip_x, store.tick_ts, true)
            else
                U.animation_start(this, "idle", os.flip_x, store.tick_ts, true)
            end

            last_state = state
        end

        this.render.sprites[1].hidden = os.hidden

        if string.starts(state, "walking") then
            if math.abs(delta_y) >= math.abs(dest_y) then
                delta_speed = -1 * delta_speed
                dest_y = math.random(0, this.max_delta_y)
            end

            delta_y = delta_y + delta_speed * store.tick_length
        end

        this.pos.x = ow.pos.x + oo.x
        this.pos.y = ow.pos.y + oo.y + delta_y

        coroutine.yield()
    end
end

scripts.decal_twilight_heretic_consume_ball = {}

function scripts.decal_twilight_heretic_consume_ball.update(this, store)
    local sp = this.render.sprites[1]
    local fm = this.force_motion
    local initial_pos = this.from
    local initial_h = this.from_h
    local dest_h = this.to_h
    local last_pos = V.v(0, 0)

    this.dest = this.to
    last_pos.x, last_pos.y = this.pos.x, this.pos.y + sp.offset.y
    sp.offset.y = initial_h

    local function move_step(dest)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local max_dist = V.len(dest.x - initial_pos.x, dest.y - initial_pos.y)
        local df = (not fm.ramp_radius or dist > fm.ramp_radius) and 1 or math.max(dist / fm.ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)

        local sx, sy = V.mul(store.tick_length, fm.v.x, fm.v.y)

        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
        fm.a.x, fm.a.y = V.mul(-0.05 / store.tick_length, fm.v.x, fm.v.y)
        sp.offset.y = SU.parabola_y(1 - dist / max_dist, initial_h, dest_h, fm.max_flight_height)
        sp.r = V.angleTo(this.pos.x - last_pos.x, this.pos.y + sp.offset.y - last_pos.y)
        last_pos.x, last_pos.y = this.pos.x, this.pos.y + sp.offset.y

        return dist < 2 * fm.max_v * store.tick_length
    end

    local ps = E:create_entity(this.particles_name)

    ps.particle_system.track_id = this.id
    ps.particle_system.track_offset = sp.offset

    queue_insert(store, ps)

    while not move_step(this.dest) do
        coroutine.yield()
    end

    this.arrived = true

    queue_remove(store, this)
end

scripts.decal_veznan_soulburn_ball = {}

function scripts.decal_veznan_soulburn_ball.update(this, store)
    local af = this.to.x > this.from.x

    this.pos.y = this.from.y + this.offset.y
    this.pos.x = this.from.x + (af and -1 or 1) * this.offset.x

    local dist = V.dist(this.pos.x, this.pos.y, this.to.x, this.to.y)
    local r = V.angleTo(this.to.x - this.pos.x, this.to.y - this.pos.y)
    local duration = dist / this.speed
    local fx = E:create_entity(this.spawn_fx)

    fx.pos.x, fx.pos.y = this.from.x, this.from.y
    fx.render.sprites[1].name = fx.render.sprites[1].size_names[this.target.unit.size]
    fx.render.sprites[1].ts = store.tick_ts
    fx.render.sprites[1].flip_x = af

    queue_insert(store, fx)
    U.y_animation_wait(fx)

    local ps = E:create_entity(this.particles_name)

    ps.particle_system.track_id = this.id

    queue_insert(store, ps)

    this.render.sprites[1].hidden = nil
    this.render.sprites[1].r = r

    U.animation_start(this, "fly", nil, store.tick_ts, true)
    U.y_ease_keys(store, {this.pos, this.pos}, {"x", "y"}, {this.pos.x, this.pos.y}, {this.to.x, this.to.y}, duration,
        {"quad-out", "quad-out"})
    U.animation_start(this, "hit", nil, store.tick_ts, false)

    this.arrived = true

    U.y_animation_wait(this)
    queue_remove(store, this)
end

scripts.decal_eerie_root = {}

function scripts.decal_eerie_root.update(this, store)
    if this.delay then
        U.y_wait(store, this.delay)
    end

    local start_ts = store.tick_ts

    this.render.sprites[1].hidden = nil

    U.y_animation_play(this, "start", nil, store.tick_ts)

    while store.tick_ts - start_ts < this.duration do
        if U.find_first_target(store.entities, this.pos, 0, 25, this.vis_flags, this.vis_bans) then
            U.y_animation_play(this, "loop", nil, store.tick_ts, 1)
        end

        coroutine.yield()
    end

    U.y_animation_play(this, "end", nil, store.tick_ts)
    queue_remove(store, this)
end

scripts.high_elven_sentinel = {}

function scripts.high_elven_sentinel.update(this, store)
    local sb_sid, ss_sid = 1, 2
    local sb = this.render.sprites[sb_sid]
    local ss = this.render.sprites[ss_sid]
    local ra = this.ranged.attacks[1]
    local fm = this.force_motion

    local function move_step(dest)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local ramp_radius = fm.ramp_radius
        local df = (not ramp_radius or ramp_radius < dist) and 1 or math.max(dist / ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)
        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
        fm.a.x, fm.a.y = V.mul(-1 * fm.fr / store.tick_length, fm.v.x, fm.v.y)
    end

    local function find_target(range)
        if this.owner.tower.blocked then
            return nil
        end

        local target, targets = U.find_foremost_enemy(store.enemies, this.pos, 0, range, false, ra.vis_flags,
            ra.vis_bans)

        if target and #this.owner.sentinels > 1 then
            local other_target_id = this.owner.sentinels[this.owner_idx == 1 and 2 or 1].chasing_target_id

            if target.id == other_target_id and #targets > 1 then
                target = targets[2]
            end
        end

        return target
    end

    local charge_ts, wait_ts, shoot_ts, search_ts, shots = 0, 0, 0, 0, 0
    local target, targets, dist
    local dest = V.v(0, 0)
    local ps = E:create_entity(this.particles_name)

    ps.particle_system.track_id = this.id
    ps.particle_system.track_offset = V.v(0, this.flight_height)

    queue_insert(store, ps)

    while true do
        U.animation_start(this, "small", nil, store.tick_ts, true, sb_sid)

        ss.hidden = true
        sb.z = Z_OBJECTS
        sb.sort_y = this.owner.pos.y
        ps.particle_system.emit = true
        ps.particle_system.sort_y = this.owner.pos.y
        this.tween.reverse = false
        this.tween.ts = store.tick_ts
        shots = 0
        charge_ts = store.tick_ts

        while true do
            local p = V.v(this.tower_rotation_radius, 0)

            p.x, p.y = V.rotate(store.tick_ts * this.tower_rotation_speed + (this.owner_idx - 1) * math.pi, p.x, p.y)
            p.y = 0.5 * p.y
            this.pos.x = this.owner.pos.x + this.tower_rotation_offset.x + p.x
            this.pos.y = this.owner.pos.y + this.tower_rotation_offset.y + p.y

            if store.tick_ts - charge_ts > this.charge_time then
                if sb.name == "small" then
                    U.animation_start(this, "big", nil, store.tick_ts, true, sb_sid)
                end

                target = find_target(ra.launch_range)

                if target then
                    S:queue("TowerHighMageSentinelActivate")

                    break
                end
            end

            coroutine.yield()
        end

        ::label_29_0::

        sb.z = Z_BULLETS
        sb.sort_y_offset = 0
        ss.hidden = false
        ps.particle_system.emit = false
        this.chasing_target_id = target.id
        dest.x, dest.y = target.pos.x, target.pos.y

        repeat
            dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

            move_step(dest)
            coroutine.yield()
        until dist < ra.shoot_range or target.health.dead or band(ra.vis_flags, target.vis.bans) ~= 0

        if shots < ra.max_shots and store.entities[target.id] and not target.health.dead and
            band(ra.vis_flags, target.vis.bans) == 0 then
            if store.tick_ts - shoot_ts > ra.cooldown then
                shoot_ts = store.tick_ts
                shots = shots + 1

                U.animation_start(this, "shoot", nil, store.tick_ts, false, sb_sid)
                U.y_wait(store, ra.shoot_time)

                local b = E:create_entity(ra.bullet)

                b.pos.x, b.pos.y = this.pos.x + sb.offset.x, this.pos.y + sb.offset.y
                b.bullet.from = V.vclone(b.pos)
                b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
                b.bullet.target_id = target.id
                b.bullet.source_id = this.id

                queue_insert(store, b)
                U.y_animation_wait(this, sb_sid)
                U.animation_start(this, "big", nil, store.tick_ts, true, sb_sid)
            end

            goto label_29_0
        end

        wait_ts = store.tick_ts
        this.chasing_target_id = nil

        U.animation_start(this, "big", nil, store.tick_ts, true, sb_sid)

        local wait_time = shots < ra.max_shots and this.wait_time or this.wait_spent_time

        ::label_29_1::

        search_ts = store.tick_ts

        if shots < ra.max_shots then
            target = find_target(ra.max_range)

            if target then
                goto label_29_0
            end
        end

        while store.tick_ts - search_ts < ra.search_cooldown do
            move_step(dest)
            coroutine.yield()
        end

        if wait_time > store.tick_ts - wait_ts then
            goto label_29_1
        end

        this.tween.ts = store.tick_ts
        this.tween.reverse = true

        U.y_wait(store, this.tween.props[1].keys[2][1])
    end
end

scripts.tower_rock_thrower = {}

function scripts.tower_rock_thrower.update(this, store)
    local a = this.attacks
    local ba = this.attacks.list[1]
    local last_target_pos = V.v(0, 0)
    local shooter_sid = 4
    local rocks_loading_sid = 3
    local rocks_loading_s = this.render.sprites[rocks_loading_sid]
    local start_offset = ba.bullet_start_offset
    local an, af, enemy, _, pred_pos
    local loaded = false

    rocks_loading_s.hidden = true
    ba.ts = store.tick_ts

    local function filter_faerie(e)
        local ppos = P:predict_enemy_pos(e, ba.node_prediction)

        return not GR:cell_is(ppos.x, ppos.y, TERRAIN_FAERIE)
    end

    while true do
        if this.tower.blocked then
            -- block empty
        else
            if not loaded then
                loaded = true
                an, af = U.animation_name_facing_point(this, "load", last_target_pos, shooter_sid, start_offset)

                U.animation_start_group(this, an, af, store.tick_ts, false, "shooters")
                U.y_wait(store, fts(8))

                if an == "loadDown" and not af or an == "loadUp" and af then
                    rocks_loading_s.offset.x, rocks_loading_s.offset.y = rocks_loading_s.offsets[2].x,
                        rocks_loading_s.offsets[2].y
                else
                    rocks_loading_s.offset.x, rocks_loading_s.offset.y = rocks_loading_s.offsets[1].x,
                        rocks_loading_s.offsets[1].y
                end

                rocks_loading_s.hidden = nil

                U.animation_start(this, "play", nil, store.tick_ts, false, rocks_loading_sid)
                S:queue("TowerStoneDruidBoulderSummon")
                U.y_animation_wait(this, shooter_sid)
            end

            if store.tick_ts - ba.ts < ba.cooldown then
                coroutine.yield()
            else
                enemy, _, pred_pos = U.find_foremost_enemy(store.enemies, tpos(this), 0, a.range, ba.node_prediction,
                    ba.vis_flags, ba.vis_bans, filter_faerie)

                if enemy then
                    loaded = false
                    ba.ts = store.tick_ts
                    last_target_pos.x, last_target_pos.y = pred_pos.x, pred_pos.y

                    local an, af = U.animation_name_facing_point(this, "shoot", pred_pos, shooter_sid, start_offset)

                    U.animation_start_group(this, an, af, store.tick_ts, false, "shooters")
                    U.y_wait(store, ba.shoot_time)

                    local trigger_pos = pred_pos

                    enemy, _, pred_pos = U.find_foremost_enemy(store.enemies, tpos(this), 0, a.range,
                        ba.node_prediction, ba.vis_flags, ba.vis_bans, filter_faerie)

                    local b = E:create_entity(ba.bullet)

                    b.bullet.damage_factor = this.tower.damage_factor
                    b.pos.x, b.pos.y = this.pos.x + ba.bullet_start_offset.x, this.pos.y + ba.bullet_start_offset.y
                    b.bullet.from = V.vclone(b.pos)
                    b.bullet.to = enemy and pred_pos or trigger_pos
                    b.bullet.source_id = this.id

                    queue_insert(store, b)
                    U.y_animation_wait(this, shooter_sid)
                end
            end
        end

        coroutine.yield()
    end
end



scripts.druid_shooter_sylvan = {}

function scripts.druid_shooter_sylvan.update(this, store)
    local a = this.attacks.list[1]

    a.ts = store.tick_ts

    while true do
        if this.owner.tower.blocked or not this.owner.tower.can_do_magic then
            -- block empty
        elseif store.tick_ts - a.ts > a.cooldown then
            SU.delay_attack(store, a, 1)
            local target
            local _, enemies = U.find_foremost_enemy(store.enemies, this.owner.pos, 0, a.range, nil, a.vis_flags, a.vis_bans, function (v)
                return not table.contains(a.excluded_templates, v.template_name) and not SU.has_modifiers(store, v, "mod_druid_sylvan")
            end)

            if enemies then
                local foremost_enemy = enemies[1]
                local max_hp_enemy_idx = 1
                local max_hp = foremost_enemy.health.hp
                for i = 2, #enemies do
                    local e = enemies[i]

                    if V.dist(e.__ffe_pos.x, e.__ffe_pos.y, foremost_enemy.__ffe_pos.x, foremost_enemy.__ffe_pos.y) <= 50 then
                        if e.health.hp > max_hp then
                            max_hp = e.health.hp
                            max_hp_enemy_idx = i
                        end
                    else
                        break
                    end
                end
                target = enemies[max_hp_enemy_idx]
            end

            if target and #enemies > 1 then
                S:queue(a.sound)
                U.animation_start(this, a.animation, nil, store.tick_ts)
                U.y_wait(store, a.cast_time)

                a.ts = store.tick_ts

                local mod = E:create_entity(a.spell)

                mod.modifier.target_id = target.id
                mod.modifier.level = this.owner.powers.sylvan.level

                queue_insert(store, mod)
            end
        end

        coroutine.yield()
    end
end

scripts.druid_shooter_nature = {}

function scripts.druid_shooter_nature.update(this, store)
    local b = this.owner.barrack
    local a = this.attacks.list[1]
    local formation_offset = U.frandom(math.pi / 4, 2 * math.pi / 5)
    local soldier_added = false

    a.ts = store.tick_ts

    while true do
        if this.owner.tower.blocked or not this.owner.tower.can_do_magic then
            -- block empty
        else
            soldier_added = false

            for i = 1, b.max_soldiers do
                local s = b.soldiers[i]

                if not s or s.health.dead and not store.entities[s.id] then
                    U.animation_start(this, a.animation, nil, store.tick_ts)
                    U.y_wait(store, a.spawn_time)

                    s = E:create_entity(b.soldier_type)
                    s.soldier.tower_id = this.owner.id
                    s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers,
                        formation_offset)
                    s.pos = V.vclone(s.nav_rally.pos)
                    s.nav_rally.new = true

                    queue_insert(store, s)

                    b.soldiers[i] = s

                    signal.emit("tower-spawn", this, s)

                    soldier_added = true
                end
            end

            if soldier_added then
                soldier_added = false

                for _, s in pairs(b.soldiers) do
                    s.nav_rally.new = true
                end
            end

            if b.rally_new then
                formation_offset = U.frandom(math.pi / 4, 2 * math.pi / 5)
                b.rally_new = false

                signal.emit("rally-point-changed", this)

                local all_dead = true

                for i, s in pairs(b.soldiers) do
                    local s = b.soldiers[i]

                    s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers,
                        formation_offset)
                    s.nav_rally.new = true
                    all_dead = all_dead and s.health.dead
                end

                if not all_dead then
                    S:queue(this.owner.sound_events.change_rally_point)
                end
            end
        end

        coroutine.yield()
    end
end



scripts.tower_bastion_holder = {}

function scripts.tower_bastion_holder.insert(this, store)
    if this.tower.flip_x then
        for _, s in pairs(this.render.sprites) do
            s.flip_x = true
        end
    end

    return true
end

scripts.tower_bastion = {}

function scripts.tower_bastion.get_info(this, store)
    local level = this.powers and this.powers.razor_edge.level or 0
    local au = E:get_template("aura_razor_edge")
    local a = au.aura
    local cycles = a.duration / a.cycle_time
    local min, max = a.damage_min + a.damage_inc * level, a.damage_max + a.damage_inc * level

    min, max = min * cycles, max * cycles

    local t = E:get_template("tower_bastion")

    return {
        type = STATS_TYPE_TOWER_NO_RANGE,
        damage_min = min,
        damage_max = max,
        cooldown = t.attacks.list[1].cooldown
    }
end

function scripts.tower_bastion.insert(this, store)
    if this.tower.flip_x then
        for _, s in pairs(this.render.sprites) do
            s.flip_x = true
        end
    end

    return true
end

function scripts.tower_bastion.update(this, store)
    local pow = this.powers.razor_edge
    local a = this.attacks
    local ra = a.list[1]

    ra.ts = store.tick_ts

    local target
    local trigger_pos = this.tower.default_rally_pos
    local flipped = this.tower.flip_x

    U.y_animation_play_group(this, "reload", nil, store.tick_ts, 1, "animated")

    while true do
        if this.tower.blocked then
            -- block empty
        else
            for k, pow in pairs(this.powers) do
                if pow.changed then
                    pow.changed = nil
                end
            end

            if store.tick_ts - ra.ts < ra.cooldown then
                -- block empty
            else
                target =
                    U.find_foremost_enemy(store.enemies, trigger_pos, 0, a.range, false, ra.vis_flags, ra.vis_bans)

                if not target then
                    -- block empty
                else
                    U.animation_start_group(this, "shoot", nil, store.tick_ts, false, "animated")
                    U.y_wait(store, ra.shoot_time)
                    S:queue(ra.sound_shoot)

                    for i = 2, 3 do
                        local dest = P:node_pos(target.nav_path.pi, i, target.nav_path.ni + 4)
                        local b = E:create_entity(ra.bullet)

                        b.pos.x = this.pos.x + (flipped and -1 or 1) * ra.bullet_start_offset[1].x
                        b.pos.y = this.pos.y + ra.bullet_start_offset[1].y
                        b.bullet.from = V.vclone(b.pos)
                        b.bullet.to = dest
                        b.bullet.level = pow.level
                        b.render.sprites[1].flip_x = flipped

                        local aura = E:create_entity(ra.payload_name)

                        aura.aura.level = pow.level
                        aura.render.sprites[1].flip_x = flipped
                        b.bullet.payload = aura

                        queue_insert(store, b)
                    end

                    U.y_animation_wait_group(this, "animated")

                    ra.ts = store.tick_ts

                    U.y_animation_play_group(this, "reload", nil, store.tick_ts, 1, "animated")
                end
            end
        end

        coroutine.yield()
    end
end

scripts.aura_razor_edge = {}

function scripts.aura_razor_edge.insert(this, store)
    this.tween.ts = store.tick_ts

    return true
end

scripts.soldier_blade = {}

function scripts.soldier_blade.on_damage(this, store, damage)
    log.debug(" SOLDIER_BLADE DAMAGE:%s type:%x", damage.value, damage.damage_type)

    local bda = this.timed_attacks.list[1]

    if not this.dodge or this.dodge.chance <= 0 or this.unit.is_stunned or this.health.dead or bda.in_progress or
        band(damage.damage_type, DAMAGE_ALL_TYPES, bnot(bor(DAMAGE_PHYSICAL, DAMAGE_MAGICAL))) ~= 0 or
        band(damage.damage_type, DAMAGE_NO_DODGE) ~= 0 or this.powers[this.dodge.power_name].level < 1 or
        this.dodge.chance < math.random() then
        return true
    end

    log.debug("(%s)soldier_blade dodged damage %s of type %s", this.id, damage.value, damage.damage_type)

    this.dodge.active = true

    return false
end

function scripts.soldier_blade.insert(this, store)
    if scripts.soldier_barrack.insert(this, store) then
        if this.powers.blade_dance.level > 0 then
            local p = this.powers.blade_dance
            local bda = this.timed_attacks.list[1]

            bda.disabled = nil
            bda.ts = store.tick_ts
            bda.damage_min = p.damage_min[p.level]
            bda.damage_max = p.damage_max[p.level]
            bda.hits = p.hits[p.level]
        end

        return true
    end

    return false
end

function scripts.soldier_blade.update(this, store)
    local brk, sta
    local bda = this.timed_attacks.list[1]

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    while true do
        if this.powers then
            for pn, p in pairs(this.powers) do
                if p.changed then
                    p.changed = nil

                    SU.soldier_power_upgrade(this, pn)

                    if pn == "blade_dance" then
                        if p.level >= 1 then
                            bda.disabled = nil
                            bda.ts = store.tick_ts
                        end

                        bda.damage_min = p.damage_min[p.level]
                        bda.damage_max = p.damage_max[p.level]
                        bda.hits = p.hits[p.level]
                    end

                    if pn == "swirling" and p.level >= 1 then
                        bda.cooldown = bda.cooldown - 1.8
                    end
                end
            end
        end

        if not this.health.dead or SU.y_soldier_revive(store, this) then
            -- block empty
        else
            SU.y_soldier_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            if this.dodge and this.dodge.active and this.dodge.chance > 0 then
                local ca = this.dodge.counter_attack

                this.dodge.active = false

                if this.powers[this.dodge.power_name].level > 0 then
                    local start_ts = store.tick_ts

                    ca.ts = 0
                    this.health.ignore_damage = true
                    this.vis.bans = bor(this.vis.bans, F_NET)

                    S:queue(ca.sound)
                    U.animation_start(this, ca.animation, nil, store.tick_ts, true)
                    U.y_wait(store, ca.hit_time)

                    while store.tick_ts - start_ts < ca.duration do
                        if store.tick_ts - ca.ts > ca.damage_every then
                            ca.ts = store.tick_ts

                            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, ca.damage_radius,
                                ca.damage_flags, ca.damage_bans)

                            if targets then
                                for _, target in pairs(targets) do
                                    local d = E:create_entity("damage")

                                    d.source_id = this.id
                                    d.target_id = target.id
                                    d.value = ca.damage_max
                                    d.damage_type = ca.damage_type

                                    queue_damage(store, d)
                                    -- AC:inc_check("PERFECT_PARRY", d.value)
                                end
                            end
                        end

                        coroutine.yield()
                    end

                    this.vis.bans = band(this.vis.bans, bnot(F_NET))
                    this.health.ignore_damage = false

                    SU.soldier_idle(store, this)
                    signal.emit("soldier-dodge", this)
                end
            end

            while this.nav_rally.new do
                if SU.y_soldier_new_rally(store, this) then
                    goto label_53_2
                end
            end

            if not bda.disabled and store.tick_ts - bda.ts > bda.cooldown then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, bda.max_range, bda.vis_flags,
                    bda.vis_bans)

                if not targets or #targets < bda.min_count then
                    SU.delay_attack(store, bda, fts(6))

                    goto label_53_1
                end

                bda.ts = store.tick_ts
                bda.in_progress = true
                this.health.ignore_damage = true
                this.vis._bans = this.vis.bans
                this.vis.bans = F_ALL

                local initial_pos = V.vclone(this.pos)
                local visited = {}

                U.y_animation_play(this, "dance_out", nil, store.tick_ts)

                for i = 1, bda.hits do
                    ::label_53_0::

                    targets = U.find_enemies_in_range(store.enemies, this.pos, 0, bda.max_range, bda.vis_flags,
                        bda.vis_bans, function(v)
                            return not table.contains(visited, v)
                        end)

                    if not targets then
                        if #visited > 0 then
                            visited = {}

                            goto label_53_0
                        else
                            break
                        end
                    end

                    local target = targets[km.zmod(i, #targets)]

                    table.insert(visited, target)
                    SU.stun_inc(target)

                    local spos, sflip = U.melee_slot_position(this, target, 1)

                    this.pos.x, this.pos.y = spos.x, spos.y

                    S:queue(bda.sound)

                    local an = table.random({"dance_hit1", "dance_hit2", "dance_hit3"})

                    U.animation_start(this, an, sflip, store.tick_ts)
                    U.y_wait(store, bda.hit_time)

                    local d = E:create_entity("damage")

                    d.source_id = this.id
                    d.target_id = target.id
                    d.value = math.ceil(U.frandom(bda.damage_min, bda.damage_max))
                    d.damage_type = bda.damage_type

                    queue_damage(store, d)
                    U.y_animation_wait(this)
                    SU.stun_dec(target)
                end

                this.pos.x, this.pos.y = initial_pos.x, initial_pos.y

                U.y_animation_play(this, "dance_in", nil, store.tick_ts)

                this.health.ignore_damage = false
                this.vis.bans = this.vis._bans
                this.vis._bans = nil

                -- AC:inc_check("BLADE_DANCE")

                bda.in_progress = nil

                goto label_53_2
            end

            ::label_53_1::

            if this.melee then
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk or sta ~= A_NO_TARGET then
                    goto label_53_2
                end
            end

            if SU.soldier_go_back_step(store, this) then
                -- block empty
            else
                SU.soldier_idle(store, this)
                SU.soldier_regen(store, this)
            end
        end

        ::label_53_2::

        coroutine.yield()
    end
end

scripts.soldier_forest = {}

function scripts.soldier_forest.insert(this, store)
    if scripts.soldier_barrack.insert(this, store) then
        if this.powers.oak.level > 0 then
            this.ranged.attacks[1].disabled = true
            this.ranged.attacks[2].disabled = nil
            this.ranged.attacks[2].level = this.powers.oak.level
        end

        return true
    end

    return false
end

function scripts.soldier_forest.update(this, store)
    local brk, sta
    local tower = store.entities[this.soldier.tower_id]
    local ca = this.timed_attacks.list[1]
    local ea = this.timed_attacks.list[2]
    local pow_c = this.powers.circle
    local pow_e = this.powers.eerie

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    while true do
        if this.powers then
            for pn, p in pairs(this.powers) do
                if p.changed then
                    p.changed = nil

                    SU.soldier_power_upgrade(this, pn)

                    if pn == "oak" then
                        if p.level >= 1 then
                            this.ranged.attacks[1].disabled = true
                            this.ranged.attacks[2].disabled = nil
                        end

                        this.ranged.attacks[2].level = p.level
                    end

                    if pn == "circle" then
                        this.timed_attacks.list[1].ts = store.tick_ts
                    end

                    if pn == "eerie" then
                        this.timed_attacks.list[2].ts = store.tick_ts
                    end
                end
            end
        end

        if not this.health.dead or SU.y_soldier_revive(store, this) then
            -- block empty
        else
            SU.y_soldier_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_soldier_new_rally(store, this) then
                    goto label_56_3
                end
            end

            if pow_e.level > 0 and store.tick_ts - ea.ts > ea.cooldown then
                for _, s in pairs(tower.barrack.soldiers) do
                    if s and not s.health.dead and s._casting_eerie then
                        SU.delay_attack(store, ea, fts(6))

                        goto label_56_0
                    end
                end

                local max_range = ea.max_range + pow_e.level * ea.max_range_inc
                local target = U.find_random_enemy(store.enemies, this.pos, 0, max_range, ea.vis_flags, ea.vis_bans,
                    function(e)
                        return U.get_blocker(store, e) == nil and not e.unit.is_stunned
                    end)

                if not target then
                    SU.delay_attack(store, ea, fts(6))
                else
                    this._casting_eerie = true
                    ea.ts = store.tick_ts

                    for _, s in pairs(tower.barrack.soldiers) do
                        if s and not s.health.dead then
                            s.timed_attacks.list[2].ts = store.tick_ts
                        end
                    end

                    U.animation_start(this, ea.animation, nil, store.tick_ts)
                    U.y_wait(store, ea.cast_time)

                    local a = E:create_entity(ea.bullet)

                    a.aura.source_id = this.id
                    a.aura.level = pow_e.level

                    local ni = target.nav_path.ni + P:predict_enemy_node_advance(target, fts(10))

                    a.pos = P:node_pos(target.nav_path.pi, 1, ni)
                    a.pos_pi = target.nav_path.pi
                    a.pos_ni = ni

                    queue_insert(store, a)
                    U.y_animation_wait(this)

                    this._casting_eerie = nil

                    -- AC:inc_check("EERIE_GARDENER")
                end
            end

            ::label_56_0::

            if pow_c.level > 0 and store.tick_ts - ca.ts > ca.cooldown then
                if not soldiers_around_need_heal(this, store, ca.trigger_hp_factor, ca.max_range) then
                    SU.delay_attack(store, ca, fts(6))
                else
                    for _, s in pairs(tower.barrack.soldiers) do
                        if s and not s.health.dead and s._casting_circle then
                            SU.delay_attack(store, ca, fts(6))

                            goto label_56_1
                        end
                    end

                    this._casting_circle = true
                    ca.ts = store.tick_ts

                    for _, s in pairs(tower.barrack.soldiers) do
                        if s and not s.health.dead then
                            s.timed_attacks.list[1].ts = store.tick_ts
                        end
                    end

                    S:queue(ca.sound)
                    U.animation_start(this, ca.animation, nil, store.tick_ts)
                    U.y_wait(store, ca.cast_time)

                    local fx = E:create_entity("fx_forest_circle")

                    fx.pos.x, fx.pos.y = this.pos.x + this.unit.mod_offset.x, this.pos.y + this.unit.mod_offset.y
                    fx.tween.ts = store.tick_ts

                    queue_insert(store, fx)

                    local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, ca.max_range, ca.vis_flags,
                        ca.vis_bans)

                    if not targets then
                        log.debug("Circle of Life has no targets for soldier id:%s", this.id)
                    else
                        for _, target in pairs(targets) do
                            local mod = E:create_entity(ca.mod)

                            mod.modifier.level = pow_c.level
                            mod.modifier.source_id = this.id
                            mod.modifier.target_id = target.id

                            queue_insert(store, mod)
                        end

                        U.y_animation_wait(this)

                        this._casting_circle = nil
                    end
                end
            end

            ::label_56_1::

            if this.melee then
                brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

                if brk then
                    goto label_56_3
                end
            end

            if this.ranged then
                brk, sta = SU.y_soldier_ranged_attacks(store, this)

                if brk or sta == A_DONE then
                    goto label_56_3
                elseif sta == A_IN_COOLDOWN then
                    goto label_56_2
                end
            end

            if SU.soldier_go_back_step(store, this) then
                goto label_56_3
            end

            ::label_56_2::

            SU.soldier_idle(store, this)
            SU.soldier_regen(store, this)
        end

        ::label_56_3::

        coroutine.yield()
    end
end

scripts.soldier_druid_bear = {}

function scripts.soldier_druid_bear.update(this, store)
    local brk, sta
    local effects = {"effect", "rune", "decal"}
    local standing = false

    local function do_effects(is_spawn)
        local prefix = is_spawn and "fx_druid_bear_spawn_" or "fx_druid_bear_death_"

        for _, n in pairs(effects) do
            local fx = E:create_entity(prefix .. n)

            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].flip_x = this.render.sprites[1].flip_x
            fx.pos = V.vclone(this.pos)

            local ox = 0

            if is_spawn then
                ox = n == "decal" and -3 or -6
            else
                ox = n == "decal" and 3 or -6
            end

            fx.pos.x = fx.pos.x + ox * (fx.render.sprites[1].flip_x and -1 or 1)

            queue_insert(store, fx)
        end
    end

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    this.health_bar.hidden = true

    do_effects(true)
    U.y_animation_play(this, "spawn", nil, store.tick_ts)

    this.health_bar.hidden = nil

    while true do
        if this.health.dead then
            do_effects(false)
            SU.y_soldier_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_soldier_new_rally(store, this) then
                    goto label_58_0
                end
            end

            if this.melee then
                local target = SU.soldier_pick_melee_target(store, this)

                if not target then
                    -- block empty
                else
                    if standing then
                        local slot_pos = U.melee_slot_position(this, target)

                        if slot_pos and not V.veq(slot_pos, this.pos) then
                            U.y_animation_play(this, "stance2idle", nil, store.tick_ts)

                            this.health_bar.offset = this.health_bar.offsets.idle
                            standing = false
                        end
                    end

                    if SU.soldier_move_to_slot_step(store, this, target) then
                        goto label_58_0
                    end

                    local attack = SU.soldier_pick_melee_attack(store, this, target)

                    if not attack then
                        goto label_58_0
                    end

                    if not standing then
                        U.y_animation_play(this, "idle2stance", nil, store.tick_ts)

                        this.health_bar.offset = this.health_bar.offsets.standing
                        standing = true
                    end

                    local attack_done = SU.y_soldier_do_single_melee_attack(store, this, target, attack)

                    if attack_done then
                        goto label_58_0
                    end
                end
            end

            if standing then
                U.y_animation_play(this, "stance2idle", nil, store.tick_ts)

                this.health_bar.offset = this.health_bar.offsets.idle
                standing = false
            end

            if SU.soldier_go_back_step(store, this) then
                -- block empty
            else
                SU.soldier_idle(store, this)
                SU.soldier_regen(store, this)
            end
        end

        ::label_58_0::

        coroutine.yield()
    end
end

scripts.soldier_drow = {}

function scripts.soldier_drow.insert(this, store)
    if scripts.soldier_barrack.insert(this, store) then
        for pn, p in pairs(this.powers) do
            if pn == "double_dagger" and p.level > 0 then
                this.ranged.attacks[1].loops = 2
            end

            if pn == "blade_mail" and p.level > 0 then
                this.render.sprites[2].hidden = nil
                for level = 1, p.level do
                    this.health.spiked_armor = this.health.spiked_armor + p.spiked_armor_inc
                end
            end
        end

        return true
    end

    return false
end

function scripts.soldier_drow.update(this, store)
    local brk, sta
    local tower = store.entities[this.soldier.tower_id]
    local aura = this.render.sprites[2]

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    while true do
        for pn, p in pairs(this.powers) do
            if p.changed then
                p.changed = nil

                SU.soldier_power_upgrade(this, pn)

                if pn == "life_drain" and p.level == 1 then
                    this.melee.attacks[2].ts = store.tick_ts
                end

                if pn == "double_dagger" then
                    this.ranged.attacks[1].loops = 2
                end

                if pn == "blade_mail" then
                    this.health.spiked_armor = p.spiked_armor_inc + this.health.spiked_armor
                    aura.hidden = nil
                end
            end
        end

        if not this.health.dead or SU.y_soldier_revive(store, this) then
            if this.powers["blade_mail"].level > 0 then
                aura.hidden = nil
            end
        else
            aura.hidden = true

            SU.y_soldier_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_soldier_new_rally(store, this) then
                    goto label_61_1
                end
            end

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                goto label_61_1
            end

            brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

            if brk or sta ~= A_NO_TARGET then
                -- block empty
            else
                brk, sta = SU.y_soldier_ranged_attacks(store, this)

                if brk or sta == A_DONE then
                    goto label_61_1
                end

                if SU.soldier_go_back_step(store, this) then
                    goto label_61_1
                end

                ::label_61_0::

                SU.soldier_idle(store, this)
                SU.soldier_regen(store, this)
            end
        end

        ::label_61_1::

        coroutine.yield()
    end
end

scripts.soldier_xin_shadow = {}

function scripts.soldier_xin_shadow.insert(this, store, script)
    this.melee.order = U.attack_order(this.melee.attacks)

    return true
end

function scripts.soldier_xin_shadow.update(this, store)
    local target_id = this.soldier.target_id or this.unblocked_target_id
    local target = store.entities[target_id]
    local attack_count = 0

    this.render.sprites[1].ts = store.tick_ts

    U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

    if not target then
        U.y_wait(store, U.frandom(this.min_wait, this.max_wait))
    else
        while target and not target.health.dead and not this.health.dead and
            (not this.max_attack_count or attack_count < this.max_attack_count) do
            local attack = SU.soldier_pick_melee_attack(store, this, target)

            if attack then
                local start_ts = store.tick_ts
                local an, af = U.animation_name_facing_point(this, attack.animation, target.pos)

                U.animation_start(this, an, af, store.tick_ts, 1)
                S:queue(attack.sound)
                U.y_wait(store, attack.hit_time)
                S:queue(attack.sound_hit)

                attack.ts = start_ts

                for _, aa in pairs(this.melee.attacks) do
                    if aa ~= attack and aa.shared_cooldown then
                        aa.ts = attack.ts
                    end
                end

                if attack.damage_type ~= DAMAGE_NONE then
                    local d = E:create_entity("damage")

                    d.damage_type = attack.damage_type
                    d.value = math.ceil(U.frandom(attack.damage_min, attack.damage_max)) * this.unit.damage_factor
                    d.source_id = this.id
                    d.target_id = target.id

                    queue_damage(store, d)
                end

                U.y_animation_wait(this)

                attack_count = attack_count + 1
            end

            SU.soldier_idle(store, this)
            coroutine.yield()

            target = store.entities[target_id]
        end
    end

    S:queue(this.sound_events.death)
    U.y_animation_play(this, "death", nil, store.tick_ts)
    queue_remove(store, this)
end



scripts.decal_minidragon_faustus = {}

function scripts.decal_minidragon_faustus.update(this, store)
    local a = this.attacks.list[1]
    local af = this.pos.x > this.attack_pos.x
    local emit_angle = math.pi / 8
    local loop_duration = fts(18)
    local vx = this.motion.real_speed
    local attack_w = loop_duration * vx
    local emit_x = this.attack_pos.x + (af and 1 or -1) * (attack_w / 2 + this.emit_ox)
    local cast_x = this.attack_pos.x + (af and 1 or -1) * (attack_w / 2 + this.cast_ox)
    local emit_ts, cast_ts, emitting, casting
    local dest = V.v(0, this.pos.y)

    if af then
        this.pos.x = emit_x + math.ceil((store.visible_coords.right - emit_x + this.image_w) / attack_w) * attack_w
        dest.x = store.visible_coords.left - this.image_w
    else
        this.pos.x = emit_x - math.ceil((emit_x - store.visible_coords.left + this.image_w) / attack_w) * attack_w
        dest.x = store.visible_coords.right + this.image_w
    end

    local ps = E:create_entity("ps_minidragon_faustus_fire")

    ps.particle_system.track_id = this.id
    ps.particle_system.emit_direction = af and math.pi + emit_angle or -emit_angle
    ps.particle_system.emit_offset = V.v(a.bullet_start_offset.x * (af and -1 or 1), a.bullet_start_offset.y)
    ps.particle_system.emit = false

    queue_insert(store, ps)
    U.set_destination(this, dest)
    U.animation_start(this, "idle", af, store.tick_ts, true, nil, true)

    while not this.motion.arrived do
        if not emit_ts and (af and emit_x >= this.pos.x or not af and emit_x <= this.pos.x) then
            S:queue(a.sound)
            U.animation_start(this, "fire", nil, store.tick_ts, false, 2)

            ps.particle_system.emit = true
            emit_ts = store.tick_ts
            emitting = true
        end

        if not cast_ts and (af and cast_x >= this.pos.x or not af and cast_x <= this.pos.x) then
            a.disabled = nil
            a.ts = store.tick_ts - a.cooldown
            cast_ts = store.tick_ts
            casting = true
        end

        if emitting and loop_duration < store.tick_ts - emit_ts then
            U.animation_start(this, "idle", nil, store.tick_ts, false, 2)

            ps.particle_system.emit = false
            emitting = false
        end

        if casting and loop_duration < store.tick_ts - cast_ts then
            a.disabled = true
            casting = false
        end

        if casting and store.tick_ts - a.ts > a.cooldown then
            local o_x = (af and -1 or 1) * this.cast_ox
            local o_y = table.random({-10, -5, 5, 10})
            local e = E:create_entity(a.bullet)

            e.pos.x, e.pos.y = this.pos.x + o_x, this.pos.y + o_y
            e.aura.ts = store.tick_ts

            queue_insert(store, e)

            a.ts = store.tick_ts
        end

        U.walk(this, store.tick_length)
        coroutine.yield()
    end

    queue_remove(store, ps)
    queue_remove(store, this)
end

-- scripts.hero_alleria = {}

-- function scripts.hero_alleria.fixed_ranged_filter_fn(e, origin)
--     return U.is_inside_ellipse(e.pos, V.v(838, 491), 125, 1.368) or U.is_inside_ellipse(e.pos, V.v(540, 357), 75, 1)
-- end

-- function scripts.hero_alleria.insert(this, store)
--     this.melee.order = U.attack_order(this.melee.attacks)
--     this.ranged.order = U.attack_order(this.ranged.attacks)

--     return true
-- end

-- function scripts.hero_alleria.update(this, store)
--     local h = this.health
--     local he = this.hero
--     local brk, sta, a, skill

--     local function find_cat_pos(pos)
--         local nodes = P:nearest_nodes(pos.x, pos.y, nil, nil, true, NF_RALLY)

--         if #nodes < 1 then
--             log.error("cannot insert alleria cat. no valid nodes near %s,%s", pos.x, pos.y)

--             return nil
--         end

--         local n = nodes[1]

--         if not P:is_node_valid(n[1], n[3] - 5) then
--             return nil
--         end

--         local npos = P:node_pos(n[1], n[2], n[3] - 5)

--         if band(GR:cell_type(npos.x, npos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) ~= 0 then
--             return nil
--         end

--         return npos
--     end

--     U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)

--     this.health_bar.hidden = false

--     local cat = E:create_entity("alleria_cat")

--     cat.owner = this

--     if this.fixed_mode then
--         cat.pos = this.cat_pos
--         cat.fixed_mode = true
--     else
--         cat.pos = find_cat_pos(this.pos)
--     end

--     cat.nav_rally.center = pos
--     cat.nav_rally.pos = pos
--     cat.render.sprites[1].z = this.render.sprites[1].z

--     queue_insert(store, cat)

--     while true do
--         if this.fixed_mode then
--             brk, sta = SU.y_soldier_ranged_attacks(store, this)

--             if brk then
--                 -- block empty
--             else
--                 SU.soldier_idle(store, this)
--             end
--         else
--             if h.dead then
--                 SU.y_hero_death_and_respawn(store, this)
--             end

--             if this.unit.is_stunned then
--                 SU.soldier_idle(store, this)
--             else
--                 while this.nav_rally.new do
--                     local cat_pos = find_cat_pos(this.nav_rally.pos)

--                     if cat_pos then
--                         cat.nav_rally.center = cat_pos
--                         cat.nav_rally.pos = cat_pos
--                         cat.nav_rally.new = true
--                     end

--                     if SU.y_hero_new_rally(store, this) then
--                         goto label_212_0
--                     end
--                 end

--                 if this.melee then
--                     brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

--                     if brk or sta ~= A_NO_TARGET then
--                         goto label_212_0
--                     end
--                 end

--                 brk, sta = SU.y_soldier_ranged_attacks(store, this)

--                 if brk then
--                     -- block empty
--                 elseif SU.soldier_go_back_step(store, this) then
--                     -- block empty
--                 else
--                     SU.soldier_idle(store, this)
--                     SU.soldier_regen(store, this)
--                 end
--             end
--         end

--         ::label_212_0::

--         coroutine.yield()
--     end
-- end

-- scripts.arrow_multishot_hero_alleria = {}

-- function scripts.arrow_multishot_hero_alleria.insert(this, store)
--     if this.extra_arrows > 0 then
--         local targets = U.find_enemies_in_range(store.enemies, this.bullet.to, 0, this.extra_arrows_range, F_RANGED,
--             F_NONE, function(e)
--                 return e.id ~= this.bullet.target_id
--             end)

--         for i = 1, this.extra_arrows do
--             local b = E:clone_entity(this)

--             b.extra_arrows = 0

--             if targets and targets[i] then
--                 local t = targets[i]

--                 b.bullet.target_id = t.id
--                 b.bullet.to = V.vclone(t.pos)
--             end

--             queue_insert(store, b)
--         end
--     end

--     return scripts.arrow.insert(this, store)
-- end

-- scripts.alleria_cat = {}

-- function scripts.alleria_cat.update(this, store)
--     local h = this.owner
--     local ht
--     local ba = this.behaviour_attack
--     local bs = this.behaviour_scared

--     ba.ts = store.tick_ts
--     bs.ts = store.tick_ts

--     U.y_animation_play(this, "toStand", nil, store.tick_ts)

--     while true do
--         while this.nav_rally.new do
--             this.nav_grid.waypoints = GR:find_waypoints(this.pos, nil, this.nav_rally.pos, this.nav_grid.valid_terrains)

--             if SU.y_hero_new_rally(store, this) then
--                 goto label_216_0
--             end
--         end

--         if h and h.health.dead then
--             U.y_animation_play(this, "toSad", nil, store.tick_ts)

--             while h.health.dead do
--                 U.y_animation_play(this, "sadSigh", nil, store.tick_ts)
--                 U.y_wait(store, U.frandom(1.5, 3))
--             end

--             U.y_animation_play(this, "toStand", nil, store.tick_ts)
--         else
--             ht = h and h.soldier.target_id and store.entities[h.soldier.target_id]

--             if h and not h.health.dead and ht then
--                 if store.tick_ts - ba.ts > ba.cooldown then
--                     local ht_dist = V.dist(ht.pos.x, ht.pos.y, this.pos.x, this.pos.y)

--                     if ht_dist > ba.min_distance and ht_dist < ba.max_distance then
--                         U.set_destination(this, V.v(ht.pos.x, ht.pos.y + ba.y_offset))
--                         U.animation_start(this, "walk", ht.pos.x < this.pos.x, store.tick_ts, true)

--                         while not U.walk(this, store.tick_length) do
--                             coroutine.yield()
--                         end
--                     end

--                     U.animation_start(this, ba.animation, nil, store.tick_ts)
--                     U.y_wait(store, ba.hit_time)
--                     S:queue(ba.sound)
--                     U.y_animation_wait(this)

--                     ba.cooldown = U.frandom(ba.min_cooldown, ba.max_cooldown)
--                     ba.ts = store.tick_ts

--                     goto label_216_0
--                 elseif store.tick_ts - bs.ts > bs.cooldown then
--                     U.y_animation_play(this, bs.animation, nil, store.tick_ts, 2)

--                     bs.cooldown = U.frandom(bs.min_cooldown, bs.max_cooldown)
--                     bs.ts = store.tick_ts

--                     goto label_216_0
--                 end
--             end

--             SU.soldier_idle(store, this)
--         end

--         ::label_216_0::

--         coroutine.yield()
--     end
-- end

scripts.hero_baby_malik = {}

function scripts.hero_baby_malik.level_up(this, store, initial)
    local hl = this.hero.level
    local ls = this.hero.level_stats

    this.health.hp_max = ls.hp_max[hl]
    this.regen.health = ls.regen_health[hl]
    this.health.armor = ls.armor[hl]
    this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
    this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]
    this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
    this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]

    local s

    s = this.hero.skills.smash

    for si, sl in ipairs(s.skill_upgrade_levels) do
        if sl <= hl then
            s.level = si
        end
    end

    if s.level > 0 then
        local a = this.melee.attacks[3]

        a.disabled = nil
        a.damage_min = s.damage_min[s.level]
        a.damage_max = s.damage_max[s.level]
    end

    s = this.hero.skills.fissure

    for si, sl in ipairs(s.skill_upgrade_levels) do
        if sl <= hl then
            s.level = si
        end
    end

    if s.level > 0 then
        local a = this.melee.attacks[4]

        a.disabled = nil
        a.damage_radius = s.damage_radius[s.level]
        a.damage_max = s.damage_max[s.level]
        a.damage_min = s.damage_min[s.level]

        local au = E:get_template(a.hit_aura)

        au.aura.damage_radius = s.damage_radius[s.level]
        au.aura.damage_min = s.damage_min[s.level]
        au.aura.damage_max = s.damage_max[s.level]
        au.aura.level = s.level
    end

    this.health.hp = this.health.hp_max
end

function scripts.hero_baby_malik.update(this, store)
    local h = this.health
    local he = this.hero
    local brk, sta, a, skill

    U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)

    this.health_bar.hidden = false

    while true do
        if h.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            while this.nav_rally.new do
                if SU.y_hero_new_rally(store, this) then
                    goto label_218_0
                end
            end

            if SU.hero_level_up(store, this) then
                U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
            end

            brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

            if brk or sta ~= A_NO_TARGET then
                -- block empty
            elseif SU.soldier_go_back_step(store, this) then
                -- block empty
            else
                SU.soldier_idle(store, this)
                SU.soldier_regen(store, this)
            end
        end

        ::label_218_0::

        coroutine.yield()
    end
end

scripts.aura_baby_malik_fissure = {}

function scripts.aura_baby_malik_fissure.update(this, store)
    local a = this.aura

    local function do_attack(pos)
        local fx = E:create_entity(a.fx)

        fx.pos.x, fx.pos.y = pos.x, pos.y
        fx.render.sprites[2].ts = store.tick_ts
        fx.tween.ts = store.tick_ts

        queue_insert(store, fx)

        local targets = U.find_enemies_in_range(store.enemies, pos, 0, a.damage_radius, a.vis_flags, a.vis_bans)

        if targets then
            for _, t in pairs(targets) do
                local d = E:create_entity("damage")

                d.value = math.random(a.damage_min, a.damage_max)
                d.damage_type = a.damage_type
                d.source_id = this.id
                d.target_id = t.id

                queue_damage(store, d)

                if U.flags_pass(t.vis, this.stun) then
                    local m = E:create_entity(this.stun.mod)

                    m.modifier.source_id = this.id
                    m.modifier.target_id = t.id

                    queue_insert(store, m)
                end
            end

            log.paranoid(">>>> aura_baby_malik_fissure POS:%s,%s  damaged:%s", pos.x, pos.y,
                table.concat(table.map(targets, function(k, v)
                    return v.id
                end), ","))
        end
    end

    do_attack(this.pos)

    local pi, spi, ni

    if a.target_id and store.entities[a.target_id] then
        local np = store.entities[a.target_id].nav_path

        pi, spi, ni = np.pi, np.spi, np.ni
    else
        local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

        if #nodes < 1 then
            log.error("aura_baby_malik_fissure could not find valid nodes near %s,%s", this.pos.x, this.pos.y)

            goto label_219_0
        end

        pi, spi, ni = unpack(nodes[1])
    end

    for i = 1, a.level do
        spi = (spi == 2 or spi == 3) and 1 or math.random() < 0.5 and 2 or 3

        U.y_wait(store, a.spread_delay)

        local nni = ni + i * a.spread_nodes
        local spos = P:node_pos(pi, spi, nni)

        do_attack(spos)

        nni = ni - i * a.spread_nodes
        spos = P:node_pos(pi, spi, nni)

        do_attack(spos)
    end

    ::label_219_0::

    queue_remove(store, this)
end

scripts.enemy_gnoll_blighter = {}

function scripts.enemy_gnoll_blighter.update(this, store, script)
    local ta = this.timed_attacks.list[1]

    local function ready_to_wither()
        if store.tick_ts - ta.ts < ta.cooldown then
            return false
        end

        if not this.enemy.can_do_magic then
            return false
        end

        local plants = table.filter(store.entities, function(_, e)
            return e.plant and not e.plant.blocked and U.is_inside_ellipse(e.pos, this.pos, ta.range)
        end)

        return #plants > 0, plants
    end

    ::label_224_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local ready, plants = ready_to_wither()

            if ready then
                ta.ts = store.tick_ts

                U.animation_start(this, ta.animation, nil, store.tick_ts, false)

                if SU.y_enemy_wait(store, this, ta.cast_time) then
                    goto label_224_0
                end

                local target = plants[1]
                local m = E:create_entity(ta.mod)

                m.modifier.target_id = target.id
                m.modifier.source_id = this.id

                queue_insert(store, m)
                U.y_animation_wait(this)

                goto label_224_0
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_wither()
            end)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_224_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_224_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
                        if not SU.y_enemy_range_attacks(store, this, ranged) then
                            goto label_224_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_hyena = {}

function scripts.enemy_hyena.update(this, store)
    local coward = false
    local coward_ts = 0

    ::label_228_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if not coward then
                local blocker = #this.enemy.blockers > 0 and store.entities[this.enemy.blockers[1]] or nil

                if blocker then
                    U.unblock_all(store, this)

                    coward_ts = store.tick_ts
                    coward = true
                    this.vis.bans = F_BLOCK
                    U.speed_mul(this, this.coward_speed_factor)

                    -- AC:inc("SHEZI_BANZAI_ED")

                    goto label_228_0
                end
            elseif store.tick_ts - coward_ts > this.coward_duration then
                coward = false
                this.vis.bans = 0
                U.speed_div(this, this.coward_speed_factor)

                goto label_228_0
            end

            SU.y_enemy_walk_step(store, this, coward and "run" or "walk")
        end
    end
end

scripts.enemy_ettin = {}

function scripts.enemy_ettin.update(this, store)
    this.insane.cooldown = math.random(this.insane.cooldown_min, this.insane.cooldown_max)
    this.insane.ts = store.tick_ts

    local function ready_to_insane()
        return store.tick_ts - this.insane.ts > this.insane.cooldown and not this.__mod_ogre_magi_shield_mod
    end

    ::label_229_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_insane() then
                this.insane.ts = store.tick_ts

                U.animation_start(this, "insaneStart", nil, store.tick_ts, false)

                if SU.y_enemy_wait(store, this, this.insane.hit_time) then
                    goto label_229_0
                end

                local damage_value = math.random(this.insane.damage_min, this.insane.damage_max)

                damage_value = km.clamp(0, this.health.hp - 1, damage_value)

                local d = E:create_entity("damage")

                d.damage_type = this.insane.damage_type
                d.value = damage_value
                d.target_id = this.id
                d.source_id = this.id

                queue_damage(store, d)
                U.y_animation_wait(this)
                U.animation_start(this, "insaneLoop", nil, store.tick_ts, true)

                if SU.y_enemy_wait(store, this, this.insane.stun_duration) then
                    goto label_229_0
                end

                U.animation_start(this, "idle", nil, store.tick_ts, true)
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_insane()
            end)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_229_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_229_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_perython_carrier = {}

function scripts.enemy_perython_carrier.update(this, store)
    local carrying = true
    local drop_delay = this.drop_delay and U.frandom(this.drop_delay[1], this.drop_delay[2]) or 0
    local drop_delay_ts = store.tick_ts

    local function ready_to_drop(check_delay)
        if not carrying then
            return false
        end

        if check_delay and store.tick_ts - drop_delay_ts < drop_delay then
            return false
        end

        drop_delay_ts = store.tick_ts

        local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, this.spawn_trigger_range, 0, F_FLYING)

        return targets ~= nil
    end

    local function drop_payload()
        SU.do_death_spawns(store, this)

        carrying = false
        this.death_spawns.quantity = 0

        coroutine.yield()

        this.render.sprites[3].hidden = true
    end

    while true do
        if this.health.dead then
            if this.death_spawns.concurrent_with_death then
                this.render.sprites[3].hidden = true
            end

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            if carrying and not U.has_modifier_types(store, this, MOD_TYPE_TELEPORT, MOD_TYPE_TIMELAPSE) then
                drop_payload()
            end

            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_drop() then
                drop_payload()
            end

            SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_drop(true)
            end)
        end
    end
end

scripts.enemy_twilight_elf_harasser = {}

function scripts.enemy_twilight_elf_harasser.update(this, store)
    ::label_236_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if this.dodge.active and this.vis.bans ~= F_ALL then
                this.dodge.active = false
                this.dodge.ts = store.tick_ts

                local dn = math.random(this.dodge.min_nodes, this.dodge.max_nodes)
                local nni = km.clamp(this.dodge.nodeslimit, P:get_end_node(this.nav_path.pi) - this.dodge.nodeslimit,
                    this.nav_path.ni + dn)

                if not P:is_node_valid(this.nav_path.pi, nni) then
                    goto label_236_0
                end

                local cpos = P:node_pos(this.nav_path.pi, 1, nni)

                if GR:cell_is(cpos.x, cpos.y, TERRAIN_FAERIE) then
                    goto label_236_0
                end

                U.unblock_all(store, this)

                local bans = this.vis.bans

                this.vis.bans = F_ALL

                SU.hide_modifiers(store, this, true)
                SU.hide_auras(store, this, true)
                U.y_animation_play(this, "jumpOut", nil, store.tick_ts)

                this.nav_path.ni = nni

                local npos = P:node_pos(this.nav_path)

                this.pos.x, this.pos.y = npos.x, npos.y

                U.y_animation_play(this, "jumpIn", nil, store.tick_ts)

                this.vis.bans = bans
                this.vis._bans = nil

                SU.show_modifiers(store, this, true)
                SU.show_auras(store, this, true)

                local sa = this.shadow_shot
                local target = U.find_nearest_soldier(store.soldiers, this.pos, sa.min_range, sa.max_range,
                    sa.vis_flags, sa.vis_bans)

                if target then
                    local shot_ts = store.tick_ts
                    local an, af, ai = U.animation_name_facing_point(this, sa.animation, target.pos)

                    U.animation_start(this, an, af, store.tick_ts, false)

                    while store.tick_ts - shot_ts < sa.shoot_time do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_236_0
                        end

                        coroutine.yield()
                    end

                    local bo = sa.bullet_start_offset[ai]
                    local b = E:create_entity(sa.bullet)

                    b.pos = V.vclone(this.pos)
                    b.pos.x, b.pos.y = b.pos.x + (af and -1 or 1) * bo.x, b.pos.y + bo.y
                    b.bullet.from = V.vclone(b.pos)
                    b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
                    b.bullet.target_id = target.id

                    queue_insert(store, b)

                    while not U.animation_finished(this) do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_236_0
                        end

                        coroutine.yield()
                    end

                    U.animation_start(this, "idle", nil, store.tick_ts, true)
                end

                goto label_236_0
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(store, this)
                return this.dodge.active
            end)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_236_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not this.dodge.active do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_236_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    local a = this.ranged.attacks[1]

                    if this.unit.is_stunned or this.dodge.active or #this.enemy.blockers ~= 0 then
                        goto label_236_0
                    end

                    local m = E:create_entity("mod_twilight_elf_harasser")

                    m.modifier.source_id = this.id
                    m.modifier.target_id = ranged.id

                    queue_insert(store, m)

                    a.ts = store.tick_ts

                    SU.y_enemy_do_loopable_ranged_attack(store, this, ranged, a)
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_catapult = {}

function scripts.enemy_catapult.update(this, store)
    local phase = 1
    local start_ts
    local a = this.ranged.attacks[1]

    ::label_238_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if phase == 2 then
            if not start_ts then
                start_ts = store.tick_ts
                a.ts = store.tick_ts
            end

            if store.tick_ts - start_ts > this.duration then
                phase = phase + 1

                goto label_238_0
            end

            if store.tick_ts - a.ts > a.cooldown then
                local targets = table.filter(store.entities, function(k, v)
                    return not v.pending_removal and v.health and not v.health.dead and v.vis and
                               band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and v.pos.x <
                               a.max_x and v.pos.y > a.min_x
                end)

                if #targets > 0 then
                    SU.y_enemy_range_attacks(store, this, table.random(targets))
                end
            end
        end

        if phase == 1 or phase == 3 then
            U.unblock_all(store, this)

            local bans = this.vis.bans

            this.health_bar.hidden = true
            this.vis.bans = F_ALL
            this.nav_path.dir = phase == 1 and 1 or -1

            local stop_ni = phase == 1 and this.stop_ni or nil

            while SU.y_enemy_walk_step(store, this) do
                if this.health.dead then
                    goto label_238_0
                end

                if stop_ni and this.nav_path.ni == stop_ni then
                    break
                end

                coroutine.yield()
            end

            U.animation_start(this, "idle", this.render.sprites[1].flip_x, store.tick_ts, true)

            if phase == 3 then
                queue_remove(store, this)

                return
            end

            this.health_bar.hidden = false
            this.vis.bans = bans
            phase = phase + 1
        end

        coroutine.yield()
    end
end

scripts.enemy_bandersnatch = {}

function scripts.enemy_bandersnatch.fn_filter_melee(this, store, attack, target)
    local flip_x = this.render.sprites[1].flip_x

    return
        table.contains(this.enemy.blockers, target.id) and target.pos.x >= this.pos.x and not flip_x or target.pos.x <
            this.pos.x and flip_x
end

function scripts.enemy_bandersnatch.update(this, store)
    local rolling = true
    local ta = this.timed_attacks.list[1]

    ta.ts = store.tick_ts
    this.vis.bans = this.vis.bans_rolling

    local function ready_to_spines()
        return enemy_ready_to_magic_attack(this, store, ta)
    end

    local function do_spines()
        ta.ts = store.tick_ts

        U.animation_start(this, ta.animation, nil, store.tick_ts)

        while store.tick_ts - ta.ts < ta.shoot_time do
            if this.health.dead or this.unit.is_stunned then
                return true
            end

            coroutine.yield()
        end

        local a = E:create_entity(ta.bullet)

        a.pos.x, a.pos.y = this.pos.x + (this.render.sprites[1].flip_x and -5 or 7), this.pos.y + 18
        a.source_id = this.id
        a.ts = store.tick_ts

        queue_insert(store, a)

        while not U.animation_finished(this) do
            coroutine.yield()
        end

        ta.ts = store.tick_ts
    end

    ::label_241_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            U.cleanup_blockers(store, this)

            if not rolling and not U.get_blocker(store, this) then
                this.vis.bans = this.vis.bans_rolling

                SU.remove_modifiers(store, this)
                U.y_animation_play(this, "idle2ball", nil, store.tick_ts)

                rolling = true
                U.update_max_speed(this, this.motion.min_speed)
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not cont then
                -- block empty
            else
                if blocker then
                    if rolling then
                        local an, af = U.animation_name_facing_point(this, "ball2idle", blocker.pos)

                        U.y_animation_play(this, an, af, store.tick_ts)

                        this.vis.bans = this.vis.bans_standing
                        rolling = false
                    end

                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_241_0
                    end

                    ta.ts = store.tick_ts

                    while SU.can_melee_blocker(store, this, blocker) do
                        if ready_to_spines() and not do_spines() then
                            goto label_241_0
                        end

                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_241_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_boomshrooms = {}

function scripts.enemy_boomshrooms.update(this, store)
    if this.render.sprites[1].name == "raise" then
        local next_pos = this.motion.forced_waypoint or P:next_entity_node(this, store.tick_length)
        local an, af = U.animation_name_facing_point(this, "raise", next_pos)

        U.y_animation_play(this, an, af, store.tick_ts, 1)
    end

    ::label_244_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            local cont, blocker = SU.y_enemy_walk_until_blocked(store, this)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_244_0
                    end

                    if SU.can_melee_blocker(store, this, blocker) then
                        this.health.hp = 0

                        coroutine.yield()

                        goto label_244_0
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_shroom_breeder = {}

function scripts.enemy_shroom_breeder.update(this, store)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local function ready_to_transform()
        return this.enemy.can_do_magic and store.tick_ts - a.ts > a.cooldown
    end

    ::label_245_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_transform() then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                    a.vis_bans, function(e)
                        return table.contains(a.allowed_templates, e.template_name)
                    end)

                if not targets then
                    SU.delay_attack(store, a, 0.5)
                else
                    a.ts = store.tick_ts

                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    while store.tick_ts - a.ts < a.cast_time do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_245_0
                        end

                        coroutine.yield()
                    end

                    for i, target in ipairs(targets) do
                        if i > a.max_count then
                            break
                        end

                        if not U.flags_pass(target.vis, a) then
                            -- block empty
                        else
                            local d = E:create_entity("damage")

                            d.damage_type = DAMAGE_EAT
                            d.source_id = this.id
                            d.target_id = target.id

                            queue_damage(store, d)

                            local e = E:create_entity(a.spawn_name)

                            e.pos.x, e.pos.y = target.pos.x, target.pos.y

                            if not target.nav_path then
                                log.error("Could not find nav_path to transform creature: %s (%s,%s)", target.id,
                                    e.pos.x, e.pos.y)
                            else
                                e.nav_path = table.deepclone(target.nav_path)
                                e.render.sprites[1].flip_x = target.render.sprites[1].flip_x

                                queue_insert(store, e)
                            end
                        end
                    end

                    SU.y_enemy_animation_wait(this)

                    goto label_245_0
                end
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_transform()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_gloomy = {}

function scripts.enemy_gloomy.update(this, store)
    local a = this.timed_attacks.list[1]
    local cg = store.count_groups[this.count_group.type]

    this._clones_count = 0
    a.ts = store.tick_ts

    local function ready_to_clone()
        return store.tick_ts - a.ts > a.cooldown and this._clones_count < a.max_clones and
                   (not cg[this.template_name] or cg[this.template_name] < a.count_group_max) and
                   P:nodes_to_defend_point(this.nav_path) > a.nodes_limit
    end

    if this.render.sprites[1].name == "spawnClone" then
        local next_pos = this.motion.forced_waypoint or P:next_entity_node(this, store.tick_length)
        local an, af = U.animation_name_facing_point(this, "spawnClone", next_pos)

        U.y_animation_play(this, an, af, store.tick_ts, 1)
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_clone() then
                local initial_hp = this.health.hp

                U.animation_start(this, a.animation, nil, store.tick_ts, false)
                U.y_wait(store, a.cast_time)

                local e = E:create_entity(a.spawn_name)

                e.render.sprites[1].name = "spawnClone"
                e.timed_attacks.list[1].max_clones = a.max_clones - 1
                e.enemy.gold = 0
                e.health.hp = initial_hp
                e.nav_path.pi = this.nav_path.pi
                e.nav_path.spi = math.random(1, 3)
                e.nav_path.ni = this.nav_path.ni + math.random(5, 10)

                if not P:is_node_valid(e.nav_path.pi, e.nav_path.ni) then
                    e.nav_path.ni = this.nav_path.ni
                end

                queue_insert(store, e)
                U.y_animation_wait(this)

                this._clones_count = this._clones_count + 1
                a.ts = store.tick_ts
                a.cooldown = a.cooldown_after
            end

            SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_clone()
            end)
        end
    end
end

scripts.enemy_satyr_hoplite = {}

function scripts.enemy_satyr_hoplite.update(this, store, script)
    local a = this.timed_attacks.list[1]
    local cg = store.count_groups[COUNT_GROUP_CONCURRENT]
    local spread_seed = math.random(1, 10)

    a.ts = store.tick_ts

    local function ready_to_summon(spread)
        return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic and
                   (not cg[a.count_group_name] or cg[a.count_group_name] < a.count_group_max) and
                   P:nodes_to_defend_point(this.nav_path) > a.nodes_limit and
                   (not spread or math.floor(store.tick_ts * 10) % spread_seed == 0)
    end

    ::label_252_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_summon(false) then
                U.animation_start(this, a.animation, nil, store.tick_ts, false)

                if SU.y_enemy_wait(store, this, a.spawn_time) then
                    goto label_252_0
                end

                a.ts = store.tick_ts

                S:queue(a.sound)

                local e = E:create_entity(a.entity)

                e.spawner.pi = this.nav_path.pi
                e.spawner.spi = this.nav_path.spi
                e.spawner.ni = this.nav_path.ni
                e.spawner.count_group_name = a.count_group_name
                e.spawner.count_group_type = a.count_group_type
                e.spawner.count_group_max = a.count_group_max

                queue_insert(store, e)

                if SU.y_enemy_animation_wait(this) then
                    e.spawner.interrupt = true
                else
                    a.ts = store.tick_ts
                end

                goto label_252_0
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_summon(true)
            end, function(store, this)
                return ready_to_summon(true)
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_twilight_avenger = {}

function scripts.enemy_twilight_avenger.update(this, store, script)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local shield = false

    local function ready_to_cast()
        return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic
    end

    local function enable_shield()
        if not shield then
            shield = true

            SU.armor_inc(this, this.shield_extra_armor)
        end
    end

    local function disable_shield()
        if shield then
            shield = false

            SU.armor_dec(this, this.shield_extra_armor)
        end
    end

    ::label_256_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            disable_shield()
            SU.y_enemy_stun(store, this)
        else
            enable_shield()

            if ready_to_cast() then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                    a.vis_bans)

                if targets then
                    local target = targets[1]

                    target.vis.flags = bor(target.vis.flags, F_DARK_ELF)
                    a.ts = store.tick_ts

                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    if SU.y_enemy_wait(store, this, a.cast_time) then
                        goto label_256_0
                    end

                    S:queue(a.sound)

                    local m = E:create_entity(a.mod)

                    m.modifier.source_id = this.id
                    m.modifier.target_id = target.id

                    queue_insert(store, m)
                    U.y_animation_wait(this)

                    a.ts = store.tick_ts

                    goto label_256_0
                end

                SU.delay_attack(store, a, fts(10))
            end

            local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_cast()
            end)

            if not cont then
                -- block empty
            else
                if blocker then
                    disable_shield()

                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_256_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_256_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_twilight_scourger = {}

function scripts.enemy_twilight_scourger.update(this, store, script)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local a_count = 0

    local function ready_to_lash()
        return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic and not U.get_blocker(store, this)
    end

    ::label_261_0::

    while true do
        if this.health.dead then
            if not this.enemy.can_do_magic then
                this.death_spawns = nil
            end

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_lash() then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_cast_range, a.vis_flags,
                    a.vis_bans, function(e)
                        return not table.contains(a.excluded_templates, e.template_name)
                    end)

                if not targets or #targets < a.min_count then
                    SU.delay_attack(store, a, fts(10))
                else
                    for i = 1, a.loops do
                        U.animation_start(this, a.animation, nil, store.tick_ts, false)

                        local start_ts = store.tick_ts

                        for i, event_ts in ipairs(a.event_times) do
                            if SU.y_enemy_wait(store, this, event_ts - (store.tick_ts - start_ts)) then
                                goto label_261_0
                            end

                            if i == 2 then
                                local decal = E:create_entity(a.cast_decal)

                                decal.tween.ts = store.tick_ts
                                decal.pos.x, decal.pos.y = this.pos.x, this.pos.y

                                queue_insert(store, decal)

                                local fx = E:create_entity(a.cast_fx)

                                fx.render.sprites[1].ts = store.tick_ts
                                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y

                                queue_insert(store, fx)
                            else
                                targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                                    a.vis_bans, function(e)
                                        return not table.contains(a.excluded_templates, e.template_name)
                                    end)

                                if targets then
                                    for _, target in pairs(targets) do
                                        local d = E:create_entity("damage")

                                        d.damage_type = a.damage_type
                                        if band(target.vis.flags, F_DARK_ELF) ~= 0 then
                                            d.value = 0
                                        else
                                            d.value = math.ceil(U.frandom(a.damage_min, a.damage_max))
                                        end
                                        d.target_id = target.id
                                        d.source_id = this.id

                                        local pd = U.predict_damage(target, d)

                                        d.value = math.min(pd, target.health.hp - 1)

                                        queue_damage(store, d)

                                        local m = E:create_entity(a.mod)

                                        m.modifier.target_id = target.id
                                        m.modifier.source_id = this.id

                                        queue_insert(store, m)
                                    end
                                end
                            end
                        end

                        if SU.y_enemy_animation_wait(this) then
                            goto label_261_0
                        end
                    end

                    a.ts = store.tick_ts

                    goto label_261_0
                end
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_lash()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_twilight_scourger_banshee = {}

function scripts.enemy_twilight_scourger_banshee.update(this, store, script)
    local kamikaze_target, fading
    local a = this.mod_attack

    a.ts = store.tick_ts

    local ps = E:create_entity(this.particles_name)

    ps.particle_system.track_id = this.id

    queue_insert(store, ps)

    while true do
        if not fading and not kamikaze_target and store.tick_ts - a.ts > a.cooldown then
            local towers = table.filter(store.towers, function(_, e)
                return e.tower and not e.tower_holder and not e.tower.blocked and e.tower.can_be_mod and
                           not e._is_banshee_target and U.is_inside_ellipse(e.pos, this.pos, a.max_range) and
                           not table.contains(a.excluded_templates, e.template_name)
            end)

            if #towers > 0 then
                local target = towers[1]

                target._is_banshee_target = true
                kamikaze_target = target
                U.update_max_speed(this, a.max_speed)
                this.motion.forced_waypoint = V.vclone(target.pos)
            end
        end

        if not fading and not kamikaze_target and P:nodes_to_defend_point(this.nav_path) <
            this.fade_nodes_to_defend_point then
            this.tween.disabled = nil
            this.tween.ts = store.tick_ts
            fading = true
        end

        if fading then
            ps.particle_system.alphas[1] = this.render.sprites[1].alpha
        end

        if not SU.y_enemy_walk_step(store, this) and kamikaze_target then
            if kamikaze_target.tower and kamikaze_target.tower.upgrade_to then
                for _, e in pairs(store.towers) do
                    if e.tower.holder_id == kamikaze_target.tower.holder_id and
                        V.veq(e.pos, kamikaze_target.pos) then
                        log.debug("banshee target %s changed for %s", kamikaze_target.id, e.id)

                        kamikaze_target = e

                        break
                    end
                end
            end

            local m = E:create_entity(a.mod)

            m.modifier.target_id = kamikaze_target.id
            m.modifier.source_id = this.id
            m.pos.x, m.pos.y = kamikaze_target.pos.x, kamikaze_target.pos.y
            m.render.sprites[4].hidden = kamikaze_target.tower.size ~= TOWER_SIZE_LARGE
            m.render.sprites[5].hidden = kamikaze_target.tower.size ~= TOWER_SIZE_LARGE

            queue_insert(store, m)

            this.health.hp = 0

            SU.y_enemy_death(store, this)
            queue_remove(store, this)

            return
        end

        coroutine.yield()
    end
end

scripts.enemy_webspitting_spider = {}

function scripts.enemy_webspitting_spider.update(this, store, script)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local function ready_to_cast()
        if store.tick_ts - a.ts <= a.cooldown or (not this.enemy.can_do_magic) then
            return false
        end

        for _, id in pairs(this.enemy.blockers) do
            local target = store.entities[id]

            if target and U.flags_pass(target.vis, a) and not target.unit.is_stunned then
                return true
            end
        end

        return false
    end

    ::label_268_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_268_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_268_0
                        end

                        if ready_to_cast() then
                            a.ts = store.tick_ts

                            U.animation_start(this, a.animation, nil, store.tick_ts, false)

                            if SU.y_enemy_wait(store, this, a.cast_time) then
                                goto label_268_0
                            end

                            local targets_hit = {}

                            for _, id in pairs(this.enemy.blockers) do
                                local target = store.entities[id]

                                if target and U.flags_pass(target.vis, a) and not target.unit.is_stunned and
                                    (not target.dodge or not SU.unit_dodges(store, target, false, a, this)) then
                                    local m = E:create_entity(a.mod)

                                    m.modifier.source_id = this.id
                                    m.modifier.target_id = target.id

                                    queue_insert(store, m)
                                    table.insert(targets_hit, target)
                                end
                            end

                            U.y_animation_wait(this)

                            a.ts = store.tick_ts

                            for _, e in pairs(targets_hit) do
                                U.unblock_target(store, e)
                            end

                            goto label_268_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.enemy_zealot = {}

function scripts.enemy_zealot.update(this, store)
    local function ready_to_summon()
        return this.pos.x <= this.rune.pos.x
    end

    while true do
        if this.health.dead then
            this.tween.disabled = nil
            this.tween.ts = store.tick_ts

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        elseif ready_to_summon() then
            this.is_summoning = true
            this.vis.bans = bor(this.vis.bans, F_STUN, F_FREEZE, F_TELEPORT)
            this.rune.tween.disabled = nil
            this.rune.tween.reverse = false
            this.rune.tween.ts = store.tick_ts

            S:queue("ElvesMaliciaCastSummon")
            U.y_animation_play(this, "cast_start", nil, store.tick_ts)

            this.portal.pack = this.portal_pack
            this.portal.pack_finished = nil

            while not this.health.dead and not this.portal.pack_finished do
                U.y_animation_play(this, "cast_loop", nil, store.tick_ts, 1)
            end

            this.portal.pack = nil
            this.rune.tween.reverse = true
            this.rune.tween.ts = store.tick_ts

            U.y_animation_play(this, "cast_end", nil, store.tick_ts, 1)
            U.animation_start(this, "idle", nil, store.tick_ts, true)

            this.health.hp = 0

            coroutine.yield()
        elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
            return ready_to_summon()
        end) then
            -- block empty
        else
            coroutine.yield()
        end
    end
end

scripts.enemy_twilight_evoker = {}

function scripts.enemy_twilight_evoker.update(this, store, script)
    local a
    local as = this.timed_attacks.list[1]
    local ah = this.timed_attacks.list[2]

    local function ready_to_spellwrack()
        return store.tick_ts - as.ts > as.cooldown and this.enemy.can_do_magic
    end

    local function ready_to_heal()
        return store.tick_ts - ah.ts > ah.cooldown and this.enemy.can_do_magic
    end

    local function break_fn()
        return ready_to_heal() or ready_to_spellwrack()
    end

    ::label_273_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_heal() then
                a = ah

                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.range, a.vis_flags, a.vis_bans,
                    function(e)
                        return e.health.hp < e.health.hp_max * a.hp_trigger_factor
                    end)

                if not targets then
                    SU.delay_attack(store, a, 1)
                else
                    table.sort(targets, function(e1, e2)
                        return e1.health.hp < e2.health.hp
                    end)
                    S:queue(a.sound)

                    a.ts = store.tick_ts

                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    if SU.y_enemy_wait(store, this, a.cast_time) then
                        goto label_273_0
                    end

                    for i = 1, math.min(a.max_count, #targets) do
                        local target = targets[i]
                        local m = E:create_entity(a.mod)

                        m.modifier.target_id = target.id
                        if band(target.vis.flags, F_DARK_ELF) ~= 0 then
                            m.modifier.duration = m.modifier.duration * 2
                        end
                        queue_insert(store, m)
                    end

                    U.y_animation_wait(this)

                    a.ts = store.tick_ts
                end
            end

            if ready_to_spellwrack() then
                a = as

                local towers = table.filter(store.towers, function(_, e)
                    return e.tower and e.tower.can_be_mod and e.tower.can_do_magic and
                               table.contains(a.included_templates, e.template_name) and
                               U.is_inside_ellipse(e.pos, this.pos, a.range)
                end)
                local tower = table.random(towers)

                if not tower then
                    SU.delay_attack(store, a, 1)
                else
                    local an, af, ai = U.animation_name_facing_point(this, a.animation, tower.pos)

                    U.animation_start(this, an, af, store.tick_ts, false)
                    S:queue(a.sound)

                    a.ts = store.tick_ts

                    if SU.y_enemy_wait(store, this, a.cast_time) then
                        goto label_273_0
                    end

                    local m = E:create_entity(a.mod)

                    m.modifier.target_id = tower.id
                    m.pos.x, m.pos.y = tower.pos.x, tower.pos.y

                    queue_insert(store, m)
                    U.y_animation_wait(this)

                    a.ts = store.tick_ts
                end
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_twilight_golem = {}

function scripts.enemy_twilight_golem.on_damage(this, store, damage)
    local m = this.motion

    if not m.max_speed_initial then
        m.max_speed_initial = m.max_speed
        m.max_speed_factor = 1
    end

    local unaffected_speed = m.max_speed / m.max_speed_factor
    local sub_factor = (this.health.hp_max - this.health.hp) / 100 * 0.05

    m.max_speed_factor = 1 - math.min(sub_factor, m.min_speed_sub_factor)
    m.max_speed = unaffected_speed * m.max_speed_factor

    return true
end

scripts.enemy_twilight_heretic = {}

function scripts.enemy_twilight_heretic.update(this, store)
    local a
    local ac = this.timed_attacks.list[1]
    local as = this.timed_attacks.list[2]

    local function ready_to_servant()
        return store.tick_ts - as.ts > as.cooldown and this.enemy.can_do_magic
    end

    local function ready_to_consume()
        return store.tick_ts - ac.ts > ac.cooldown and this.enemy.can_do_magic and P:nodes_to_goal(this.nav_path) >
                   ac.nodes_limit
    end

    ::label_281_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_consume() then
                a = ac

                local target = U.find_random_target(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans)

                if not target then
                    SU.delay_attack(store, a, fts(10))
                else
                    a.ts = store.tick_ts

                    S:queue(a.sound)
                    U.animation_start(this, a.animations[1], nil, store.tick_ts, false)

                    if SU.y_enemy_wait(store, this, a.cast_time) then
                        goto label_281_0
                    end

                    if target.health.dead then
                        target = U.find_random_target(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans)
                    end

                    if not target then
                        a.ts = store.tick_ts
                    else
                        local d = E:create_entity("damage")

                        d.damage_type = DAMAGE_INSTAKILL
                        d.target_id = target.id
                        d.source_id = this.id

                        queue_damage(store, d)
                        coroutine.yield()

                        if not target.health.dead then
                            a.ts = store.tick_ts

                            U.animation_start(this, a.animations[3], nil, store.tick_ts, false)
                            U.y_animation_wait(this)
                        else
                            local fx = E:create_entity(a.hit_fx)

                            fx.pos.x, fx.pos.y = target.pos.x + target.unit.mod_offset.x,
                                target.pos.y + target.unit.mod_offset.y
                            fx.render.sprites[1].ts = store.tick_ts

                            queue_insert(store, fx)
                            U.y_wait(store, fts(3))

                            local balls = {}
                            local o = V.v(a.balls_dest_offset.x * (this.render.sprites[1].flip_x and -1 or 1),
                                a.balls_dest_offset.y)

                            for i = 1, a.balls_count do
                                local b = E:create_entity(a.ball)

                                b.from = V.v(target.pos.x + target.unit.mod_offset.x, fx.pos.y)
                                b.to = V.v(this.pos.x + o.x, this.pos.y)
                                b.pos = V.vclone(b.from)
                                b.from_h = target.unit.mod_offset.y
                                b.to_h = a.balls_dest_offset.y
                                b.force_motion.max_flight_height = b.to_h + i * 10
                                b.force_motion.max_v = (2 + i) * 30

                                queue_insert(store, b)
                                table.insert(balls, b)
                            end

                            U.y_animation_wait(this)
                            U.animation_start(this, a.animations[2], nil, store.tick_ts, true)

                            while true do
                                coroutine.yield()

                                if this.health.dead or this.unit.is_stunned then
                                    goto label_281_0
                                end

                                local arrived = true

                                for _, ball in pairs(balls) do
                                    arrived = arrived and ball.arrived
                                end

                                if arrived then
                                    break
                                end
                            end

                            U.animation_start(this, a.animations[3], nil, store.tick_ts, false)
                            U.y_animation_wait(this)

                            local m = E:create_entity(a.mod)

                            m.modifier.target_id = this.id
                            m.modifier.ts = store.tick_ts
                            m.pos.x, m.pos.y = this.pos.x, this.pos.y

                            queue_insert(store, m)

                            a.ts = store.tick_ts
                        end
                    end
                end
            end

            if ready_to_servant() then
                a = as

                local target = U.find_random_target(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans)

                if not target then
                    SU.delay_attack(store, a, fts(10))

                    goto label_281_1
                end

                a.ts = store.tick_ts

                S:queue(a.sound)
                U.animation_start(this, a.animation, nil, store.tick_ts, false)

                if SU.y_enemy_wait(store, this, a.cast_time) then
                    goto label_281_0
                end

                if target.health.dead then
                    target = U.find_random_target(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans)
                end

                if not target then
                    a.ts = store.tick_ts

                    goto label_281_1
                end

                local targets = {target}
                local extra_targets = U.find_soldiers_in_range(store.soldiers, target.pos, 0, a.radius, a.vis_flags,
                    a.vis_bans, function(e)
                        return e ~= target
                    end)

                if extra_targets then
                    table.insert(targets, extra_targets[1])
                end

                for _, t in pairs(targets) do
                    local m = E:create_entity(a.mod)

                    m.modifier.target_id = t.id
                    m.pos = t.pos

                    queue_insert(store, m)
                    U.y_wait(store, 0.1)
                end

                U.y_animation_wait(this)

                a.ts = store.tick_ts
            end

            ::label_281_1::

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_servant() or ready_to_consume()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_mantaray = {}

function scripts.enemy_mantaray.update(this, store)
    this._hugging = nil

    local dead_when_hugging = false

    if this.render.sprites[1].name == "raise" then
        this.render.sprites[2].hidden = true
        this.health_bar.hidden = true

        local af = this.motion.forced_waypoint and this.motion.forced_waypoint.x < this.pos.x

        U.animation_start(this, "raise", af, store.tick_ts, true)

        this.tween.props[1].keys = {{0, V.v(0, -40)}, {0.3, V.v(0, 0)}}
        this.tween.ts = store.tick_ts
        this.tween.disabled = nil

        U.y_wait(store, 0.3)

        this.tween.disabled = true

        U.y_animation_play(this, "spawnToWalking", af, store.tick_ts)

        this.render.sprites[2].hidden = false
        this.health_bar.hidden = false
    end

    ::label_286_0::

    while true do
        if this.health.dead then
            if dead_when_hugging then
                this.unit.death_animation = "explode"
            end

            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_286_0
                    end

                    this.unit.ignore_stun = true
                    this.vis.bans = U.flag_set(this.vis.bans, bor(F_BLOCK, F_TELEPORT))
                    this.vis.flags = U.flag_clear(this.vis.flags, F_FLYING)

                    SU.stun_inc(blocker)

                    this.health_bar.hidden = true
                    this._hugging = blocker

                    local fh_offset = this.facehug_offsets[blocker.template_name]

                    fh_offset = fh_offset or blocker.hero and this.facehug_offsets.hero_default or
                                    this.facehug_offsets.soldier_default

                    local x_offset = (fh_offset.x + 0) * (this.pos.x < blocker.pos.x and -1 or 1)
                    local y_offset = fh_offset.y + 1
                    local dest = V.v(blocker.pos.x, blocker.pos.y - 1)
                    local dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
                    local eta = dist / this.motion.real_speed

                    this.tween.props[1].keys = {{0, V.v(0, 0)}, {eta, V.v(x_offset, y_offset)}}
                    this.tween.disabled = false
                    this.tween.ts = store.tick_ts

                    U.set_destination(this, dest)
                    U.animation_start(this, "jump", nil, store.tick_ts)

                    while not this.motion.arrived do
                        if this.health.dead then
                            SU.stun_dec(blocker)

                            this._hugging = nil

                            goto label_286_0
                        end

                        U.walk(this, store.tick_length)
                        coroutine.yield()
                    end

                    this.tween.disabled = true
                    this.unit.mod_offset = this.unit.mod_offset_facehug
                    this.unit.hit_offset = this.unit.hit_offset_facehug

                    U.animation_start(this, "bite", nil, store.tick_ts, true)

                    while not blocker.health.dead do
                        if this.health.dead then
                            SU.stun_dec(blocker)

                            this._hugging = nil
                            dead_when_hugging = true

                            goto label_286_0
                        end

                        local damage_value

                        if blocker.hero then
                            damage_value = math.random(this.facehug_damage_hero_min, this.facehug_damage_hero_max)
                        else
                            damage_value = math.random(this.facehug_damage_soldier_min, this.facehug_damage_soldier_max)
                        end

                        local d = E:create_entity("damage")

                        d.value = damage_value
                        d.source_id = this.id
                        d.target_id = blocker.id
                        d.damage_type = bor(DAMAGE_HOST, DAMAGE_TRUE)
                        d.track_kills = this.track_kills ~= nil

                        queue_damage(store, d)

                        local ts = store.tick_ts

                        while store.tick_ts - ts < this.facehug_damage_cooldown and not blocker.health.dead and
                            not this.health.dead do
                            coroutine.yield()
                        end
                    end

                    SU.stun_dec(blocker)

                    this._hugging = nil

                    if #this.track_kills.killed > 0 and this.track_kills.killed[1] == blocker.id then
                        if not table.contains(this.facehug_spawn_bans, blocker.template_name) then
                            U.animation_start(this, "explode", nil, store.tick_ts, false)

                            local fx = E:create_entity("fx")

                            fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                            fx.render.sprites[1].name = "fx_mantaray_spawn"
                            fx.render.sprites[1].ts = store.tick_ts

                            queue_insert(store, fx)
                            U.y_wait(store, fts(4))

                            for i = 1, 2 do
                                local e = E:create_entity("enemy_mantaray")

                                e.pos.x = this.pos.x
                                e.nav_path.pi = this.nav_path.pi
                                e.nav_path.ni = km.clamp(1, P:get_end_node(this.nav_path.pi) - 1, this.nav_path.ni + 5)
                                e.render.sprites[1].flip_x = this.render.sprites[1].flip_x

                                if i == 1 then
                                    e.enemy.gold = this.enemy.gold
                                    e.enemy.gems = this.enemy.gems
                                    e.pos.y = this.pos.y
                                    e.nav_path.spi = this.nav_path.spi
                                else
                                    e.enemy.gold = 0
                                    e.enemy.gems = 0
                                    e.pos.y = this.pos.y
                                    e.nav_path.spi = km.zmod(this.nav_path.spi + math.random(1, 2), 3)
                                end

                                queue_insert(store, e)
                            end
                        end

                        U.y_animation_wait(this)
                        queue_remove(store, this)

                        return
                    end

                    this.unit.ignore_stun = nil
                    this.vis.bans = U.flag_clear(this.vis.bans, bor(F_BLOCK, F_TELEPORT))
                    this.vis.flags = U.flag_set(this.vis.flags, F_FLYING)
                    this.health_bar.hidden = false
                    this.unit.mod_offset = this.unit.mod_offset_fly
                    this.unit.hit_offset = this.unit.hit_offset_fly
                end

                coroutine.yield()
            end
        end
    end
end

function scripts.enemy_mantaray.remove(this, store)
    if this._hugging then
        SU.stun_dec(this._hugging)

        this._hugging = nil
        this.vis.bans = U.flag_clear(this.vis.bans, bor(F_STUN, F_BLOCK, F_TELEPORT))
        this.vis.flags = U.flag_set(this.vis.flags, F_FLYING)
        this.health_bar.hidden = false
        this.unit.mod_offset = this.unit.mod_offset_fly
        this.unit.hit_offset = this.unit.hit_offset_fly
    end

    return true
end

scripts.enemy_razorboar = {}

function scripts.enemy_razorboar.update(this, store)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts
    a.hit_targets = {}

    local ps = E:create_entity(a.particles_name)

    ps.particle_system.track_id = this.id
    ps.particle_system.emit = false

    queue_insert(store, ps)

    local function ready_to_rampage()
        return store.tick_ts - a.ts > a.cooldown and not U.get_blocker(store, this) and this.enemy.can_do_magic and
                   P:nodes_to_defend_point(this.nav_path) > a.nodes_limit
    end

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_rampage() then
                local ni = this.nav_path.ni + 10

                if not P:is_node_valid(this.nav_path.pi, ni) then
                    log.debug("razorboar path node invalid: %s,%s", this.nav_path.pi, ni)
                    SU.delay_attack(store, a, 2)
                else
                    local npos = P:node_pos(this.nav_path.pi, this.nav_path.spi, ni)
                    local enemies = U.find_enemies_in_range(store.enemies, npos, 0, a.trigger_range,
                        a.vis_flags_enemies, F_BOSS, function(e)
                            return band(e.vis.flags, F_FLYING) ~= 0
                        end)
                    local soldiers = U.find_soldiers_in_range(store.soldiers, npos, 0, a.trigger_range,
                        a.vis_flags_soldiers, a.vis_bans_soldiers)

                    if not enemies and not soldiers then
                        SU.delay_attack(store, a, 1)
                    else
                        a.ts = store.tick_ts

                        local ms = E:create_entity(a.mod_self)

                        ms.modifier.target_id = this.id
                        ms.modifier.source_id = this.id
                        ms.modifier.ts = store.tick_ts

                        queue_insert(store, ms)

                        this.vis.bans = U.flag_set(this.vis.bans, F_BLOCK)

                        S:queue(a.sound)

                        while store.tick_ts - a.ts < a.duration and not this.health.dead and this.enemy.can_do_magic do
                            ps.particle_system.emit = true

                            local enemies = U.find_enemies_in_range(store.enemies, this.pos, 0, a.range,
                                a.vis_flags_enemies, a.vis_bans_enemies, function(e)
                                    return e.id ~= this.id and not table.contains(a.hit_targets, e.id)
                                end)

                            if enemies then
                                for _, e in pairs(enemies) do
                                    table.insert(a.hit_targets, e.id)

                                    local m = E:create_entity(a.mod_enemy)

                                    m.modifier.target_id = e.id
                                    m.modifier.source_id = this.id
                                    m.modifier.ts = store.tick_ts

                                    queue_insert(store, m)
                                end
                            end

                            local soldiers = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.range,
                                a.vis_flags_soldiers, a.vis_bans_soldiers, function(e)
                                    return not table.contains(a.hit_targets, e.id)
                                end)

                            if soldiers then
                                for _, e in pairs(soldiers) do
                                    table.insert(a.hit_targets, e.id)

                                    local m = E:create_entity(a.mod_soldier)

                                    m.modifier.target_id = e.id
                                    m.modifier.source_id = this.id
                                    m.modifier.ts = store.tick_ts

                                    queue_insert(store, m)
                                end
                            end

                            SU.y_enemy_walk_step(store, this, "run")

                            while this.unit.is_stunned do
                                ps.particle_system.emit = false

                                SU.y_enemy_stun(store, this)

                                a.ts = a.ts - a.duration
                            end
                        end

                        ps.particle_system.emit = false
                        this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
                    end
                end
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_rampage()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_arachnomancer = {}

function scripts.enemy_arachnomancer.update(this, store, script)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local function ready_to_summon()
        return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic and not U.get_blocker(store, this) and
                   P:nodes_to_defend_point(this.nav_path) > a.nodes_limit
    end

    for i = 1, 3 do
        local e = E:create_entity("decal_arachnomancer_mini_spider")

        e.owner = this
        e.spider_idx = i

        queue_insert(store, e)
    end

    ::label_294_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_summon() then
                a.ts = store.tick_ts

                U.animation_start(this, a.animation, nil, store.tick_ts, false)

                if SU.y_enemy_wait(store, this, a.spawn_time) then
                    goto label_294_0
                end

                local set = table.random(a.spawn_sets)
                local e = E:create_entity(a.entity)

                e.spawner.pi = this.nav_path.pi
                e.spawner.spi = this.nav_path.spi
                e.spawner.ni = this.nav_path.ni
                e.spawner.count = set[1]
                e.spawner.entity = set[2]

                queue_insert(store, e)
                U.y_animation_wait(this)

                a.ts = store.tick_ts

                goto label_294_0
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_summon()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.spider_arachnomancer_egg_spawner = {}

function scripts.spider_arachnomancer_egg_spawner.update(this, store)
    local sp = this.spawner
    local s = this.render.sprites[1]
    local idle_ts = math.random(this.idle_range[1], this.idle_range[2])

    if this.spawn_once then
        U.y_animation_play(this, "spawn", nil, store.tick_ts)
    end

    while true do
        if sp.interrupt then
            -- block empty
        else
            if sp.spawn_data then
                local data = sp.spawn_data

                sp.spawn_data = nil
                sp.count = data.cantSpiders or sp.count

                S:queue(this.sound_events.open)
                U.animation_start(this, "open", nil, store.tick_ts, false)
                U.y_wait(store, this.spawn_time)

                if SU.y_spawner_spawn(store, this) then
                    goto label_297_0
                end

                U.y_animation_wait(this)

                if this.spawn_once then
                    this.tween.disabled = nil
                    this.tween.ts = store.tick_ts

                    U.y_wait(store, this.tween.props[1].keys[2][1])

                    break
                else
                    U.y_animation_play(this, "spawn", nil, store.tick_ts)
                end
            end

            if idle_ts < store.tick_ts then
                U.y_animation_play(this, "idle", nil, store.tick_ts)

                idle_ts = store.tick_ts + math.random(this.idle_range[1], this.idle_range[2])
            end
        end

        ::label_297_0::

        sp.interrupt = nil
        sp.spawn_data = nil

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.spider_son_of_mactans_drop_spawner = {}

function scripts.spider_son_of_mactans_drop_spawner.update(this, store)
    local dest = V.vclone(this.pos)

    this.pos.x, this.pos.y = dest.x, REF_H
    this.render.sprites[1].name = "netDescend"
    this.render.sprites[1].ts = store.tick_ts

    local shadow = E:create_entity("decal_shadow_spider_son_of_mactans")

    shadow.pos.x, shadow.pos.y = dest.x, dest.y
    shadow.tween.ts = store.tick_ts

    queue_insert(store, shadow)
    U.y_ease_key(store, this.pos, "y", REF_H, dest.y, 2, "quad-in")

    local e = E:create_entity(this.spawn)

    e.pos.x, e.pos.y = this.pos.x, this.pos.y
    e.nav_path = table.deepclone(this.nav_path)
    e.nav_path.ni = e.nav_path.ni + 2
    e.render.sprites[1].name = "raise"

    queue_insert(store, e)
    coroutine.yield()

    if this.spawner.interrupt then
        e.health.hp = 0
    end

    this.render.sprites[1].hidden = true

    for i = 2, #this.render.sprites do
        local s = this.render.sprites[i]

        s.name = "dissolve"
        s.ts = store.tick_ts

        U.y_wait(store, 2 * store.tick_length)
    end

    U.y_wait(store, fts(10))
    queue_remove(store, this)
end

scripts.enemy_mactans = {}

function scripts.enemy_mactans.update(this, store)
    local idle_pos = V.vclone(this.idle_pos)

    this.pos = V.vclone(idle_pos)

    local thread = E:create_entity("decal_mactans_thread")

    queue_insert(store, thread)

    thread.pos = this.pos

    U.sprites_hide(thread)

    local shadow = E:create_entity("decal_mactans_shadow")

    queue_insert(store, shadow)

    shadow.tween.reverse = true
    shadow.tween.ts = 4

    local webbing = E:create_entity("decal_mactans_webbing")

    queue_insert(store, webbing)
    U.sprites_hide(webbing)

    while true do
        if this.phase_signal == "tower_block" or this.phase_signal == "path_web" then
            local pp = this.phase_params
            local is_tb = this.phase_signal == "tower_block"
            local tower, aura, dest, dest_node
            local touch_duration = pp.touch_duration

            if is_tb then
                local towers = table.filter(store.towers, function(_, e)
                    return e.tower and not e.tower_holder and table.contains(pp.holder_ids, e.tower.holder_id)
                end)

                if #towers < 1 then
                    goto label_299_0
                end

                tower = table.random(towers)
                dest = V.vclone(tower.pos)
            else
                local pis = P:get_connected_paths(pp.path_id)
                local nodes = P:nearest_nodes(pp.near_pos.x, pp.near_pos.y, pis, nil, true)

                log.debug(">>>>>>>>>>>>>>. pp:%s\npis:%s\nnodes:%s", getfulldump(pp), getdump(pis), getfulldump(nodes))

                if #nodes < 1 then
                    log.error("cannot do mactans path_web. no valid nodes near %s,%s", pp.near_pos.x, pp.near_pos.y)

                    goto label_299_0
                end

                dest_node = {
                    pi = nodes[1][1],
                    nodes[1][2],
                    ni = nodes[1][3]
                }
                dest = P:node_pos(dest_node.pi, 1, dest_node.ni)
            end

            this.pos.x = dest.x
            this.pos.y = REF_H

            if this.mactans_deco then
                this.mactans_deco.phase_signal = "jump_out"

                U.y_wait(store, fts(38))
            end

            U.sprites_show(thread)

            shadow.pos.x, shadow.pos.y = dest.x, dest.y + 16
            shadow.tween.reverse = false
            shadow.tween.ts = store.tick_ts

            U.animation_start(this, "falling", nil, store.tick_ts, true)
            S:queue("ElvesFinalBossSpiderIn", {
                Delay = this.drop_duration - fts(25)
            })
            U.y_ease_key(store, this.pos, "y", this.pos.y, dest.y, this.drop_duration, "quad-in")

            this.ui.clicked = nil

            S:queue("ElvesFinalBossWebspin")
            U.y_animation_play(this, "startingWeb", nil, store.tick_ts)
            U.animation_start(this, "web", nil, store.tick_ts, true)

            webbing.pos = V.v(this.pos.x, this.pos.y + 40)

            for i, sprite in ipairs(webbing.render.sprites) do
                sprite.ts = store.tick_ts + (i - 1) * fts(5)
            end

            U.sprites_show(webbing)

            if not is_tb then
                S:queue("ElvesFinalBossWebground")

                aura = E:create_entity("aura_mactans_path_web")
                aura.pos.x, aura.pos.y = dest.x, dest.y
                aura.aura.ts = store.tick_ts
                aura.aura.duration = pp.web_duration
                aura.eggs = store.level.mactans_eggs
                aura.qty_per_egg = pp.qty_per_egg
                aura.pi = dest_node.pi
                aura.ni = dest_node.ni

                queue_insert(store, aura)

                touch_duration = aura.step_nodes * aura.step_delay
            end

            if U.y_wait(store, touch_duration, function(store, time)
                return this.ui.clicked or is_tb and not store.entities[tower.id]
            end) then
                queue_remove(store, webbing)

                if is_tb and not store.entities[tower.id] then
                    -- block empty
                else
                    if not is_tb then
                        aura.interrupt = true

                        S:stop("ElvesFinalBossWebground")
                    end

                    if is_tb then
                        -- AC:inc_check("ITS_A_TRAP")
                    end

                    S:stop("ElvesFinalBossWebspin")
                    S:queue("ElvesFinalBossMactansTouch")

                    local pop = SU.create_pop(store, V.v(this.pos.x, this.pos.y + 110), {"pop_mactans"})

                    queue_insert(store, pop)
                    U.animation_start(this, "bounce", nil, store.tick_ts, true)

                    this.tween.disabled = nil
                    this.tween.ts = store.tick_ts

                    local k = this.tween.props[1].keys

                    U.y_wait(store, k[#k][1])

                    this.tween.disabled = true

                    U.y_animation_play(this, "startRetreat2", nil, store.tick_ts)
                end
            else
                if is_tb then
                    local m = E:create_entity("mod_mactans_tower_block")

                    m.pos = V.vclone(tower.pos)
                    m.modifier.target_id = tower.id
                    m.modifier.source_id = this.id
                    m.modifier.duration = pp.block_duration

                    queue_insert(store, m)
                    U.y_wait(store, this.netting_duration)
                end

                queue_remove(store, webbing)
                U.y_animation_play(this, "startRetreat", nil, store.tick_ts)
            end

            U.animation_start(this, "retreat", nil, store.tick_ts, true)
            S:queue("ElvesFinalBossSpiderOut")

            shadow.tween.reverse = true
            shadow.tween.ts = store.tick_ts

            U.y_ease_key(store, this.pos, "y", this.pos.y, REF_H, this.retreat_duration, "quad-out")
            U.sprites_hide(thread)

            if this.mactans_deco then
                this.mactans_deco.phase_signal = "jump_in"
            end
        end

        ::label_299_0::

        this.phase_signal = nil

        coroutine.yield()
    end
end

scripts.enemy_bloodsydian_warlock = {}

function scripts.enemy_bloodsydian_warlock.update(this, store)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local function ready_to_cast()
        return this.enemy.can_do_magic and store.tick_ts - a.ts > a.cooldown and this.nav_path.ni > a.nodes_min and
                   P:nodes_to_defend_point(this.nav_path) > a.nodes_limit
    end

    ::label_302_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            if ready_to_cast() then
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                    a.vis_bans, function(e)
                        return table.contains(a.allowed_templates, e.template_name)
                    end)

                if not targets or #targets < a.min_count then
                    SU.delay_attack(store, a, 0.5)
                else
                    a.ts = store.tick_ts

                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    while store.tick_ts - a.ts < a.cast_time do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_302_0
                        end

                        coroutine.yield()
                    end

                    local decal = E:create_entity(a.hit_decal)

                    decal.pos.x, decal.pos.y = this.pos.x, this.pos.y
                    decal.tween.ts = store.tick_ts

                    queue_insert(store, decal)

                    for i, target in ipairs(targets) do
                        if i > a.max_count then
                            break
                        end

                        local e = E:create_entity(a.mod)

                        e.modifier.target_id = target.id

                        queue_insert(store, e)
                    end

                    SU.y_enemy_animation_wait(this)

                    goto label_302_0
                end
            end

            if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
                return ready_to_cast()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_ogre_magi = {}

function scripts.enemy_ogre_magi.update(this, store)
    local a = this.ranged.attacks[1]
    local cont, blocker, ranged

    ::label_306_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            SU.y_enemy_stun(store, this)
        else
            cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, SU.enemy_interrupted(this))

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_306_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not SU.enemy_interrupted(this) do
                        if not SU.y_enemy_range_attacks(store, this, blocker) then
                            goto label_306_0
                        end

                        coroutine.yield()
                    end
                elseif ranged then
                    SU.y_enemy_range_attacks(store, this, ranged)
                end

                coroutine.yield()
            end
        end
    end
end

scripts.mod_ogre_magi_shield = {}

function scripts.mod_ogre_magi_shield.on_damage(this, store, damage)
    local defl_target = this.__mod_ogre_magi_shield_deflect_target
    local defl_aura = this.__mod_ogre_magi_shield_deflect_aura
    local mod = this.__mod_ogre_magi_shield_mod

    if not defl_target or defl_target.health.dead then
        return true
    end

    local v = damage.value or 0

    damage.value = km.round(v * (1 - mod.modifier.deflect_factor))

    local filtered_damage_type = band(damage.damage_type, DAMAGE_BASE_TYPES)

    if filtered_damage_type ~= 0 then
        local d = E:create_entity("damage")

        d.value = math.floor(v * mod.modifier.deflect_factor)
        d.damage_type = filtered_damage_type
        d.target_id = defl_target.id
        d.source_id = damage.source_id

        queue_damage(store, d)
    end

    if store.tick_ts - mod.last_fx_ts > mod.fx_cooldown then
        mod.render.sprites[1].ts = store.tick_ts
        mod.last_fx_ts = store.tick_ts
    end

    if store.tick_ts - defl_aura.last_fx_ts > defl_aura.fx_cooldown then
        defl_aura.render.sprites[1].ts = store.tick_ts
        defl_aura.last_fx_ts = store.tick_ts
    end

    if this.__mod_ogre_magi_shield_on_damage then
        return this.__mod_ogre_magi_shield_on_damage(this, store, damage)
    else
        return true
    end
end

function scripts.mod_ogre_magi_shield.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or target.health.dead then
        log.debug("cannot insert mod_ogre_magi_shield: missing or dead target %s", m.target_id)

        return false
    end

    local source_aura = store.entities[m.source_id]

    if not source_aura then
        log.debug("cannot insert mod_ogre_magi_shield: missing source_aura %s", m.source_id)

        return false
    end

    local source_ogre = store.entities[source_aura.aura.source_id]

    if not source_ogre then
        log.debug("cannot insert mod_ogre_magi_shield: missing source_ogre %s", source_aura.aura.source_id)

        return false
    end

    target.__mod_ogre_magi_shield_deflect_aura = source_aura
    target.__mod_ogre_magi_shield_deflect_target = source_ogre
    target.__mod_ogre_magi_shield_mod = this
    target.__mod_ogre_magi_shield_on_damage = target.health.on_damage
    target.health.on_damage = scripts.mod_ogre_magi_shield.on_damage

    local s = this.render.sprites[1]

    s.scale = s.size_scales[target.unit.size]

    return true
end

function scripts.mod_ogre_magi_shield.remove(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        target.health.on_damage = target.__mod_ogre_magi_shield_on_damage
        target.__mod_ogre_magi_shield_deflect_aura = nil
        target.__mod_ogre_magi_shield_deflect_target = nil
        target.__mod_ogre_magi_shield_mod = nil
    end

    return true
end

function scripts.mod_ogre_magi_shield.update(this, store)
    local m = this.modifier

    this.modifier.ts = store.tick_ts

    local target = store.entities[m.target_id]

    if not target or not target.pos then
        queue_remove(store, this)

        return
    end

    this.pos = target.pos

    while true do
        target = store.entities[m.target_id]

        if not target or target.health.dead then
            break
        end

        local source_ogre = target.__mod_ogre_magi_shield_deflect_target
        local source_aura = store.entities[m.source_id]

        if not source_aura or not source_ogre or source_ogre.health.dead or not source_ogre.enemy.can_do_magic or
            band(source_ogre.vis.bans, this.source_vis_flags) ~= 0 or m.duration >= 0 and store.tick_ts - m.ts >
            m.duration then
            break
        end

        if this.render and m.use_mod_offset and target.unit and target.unit.mod_offset then
            this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.mod_offset.x,
                target.unit.mod_offset.y
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.enemy_screecher_bat = {}

function scripts.enemy_screecher_bat.update(this, store, script)
    local a = this.timed_attacks.list[1]

    a.ts = store.tick_ts

    local function ready_to_attack()
        return store.tick_ts - a.ts > a.cooldown
    end

    ::label_311_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
            coroutine.yield()
        else
            if ready_to_attack() then
                local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.max_range, a.vis_flags,
                    a.vis_bans, function(e)
                        return not e.unit.is_stunned
                    end)

                if not targets then
                    SU.delay_attack(store, a, 0.25)
                else
                    a.ts = store.tick_ts

                    S:queue(a.sound)
                    U.animation_start(this, a.animation, targets[1].pos.x < this.pos.x, store.tick_ts)

                    while store.tick_ts - a.ts < a.attack_time do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_311_0
                        end

                        coroutine.yield()
                    end

                    targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.max_range, a.vis_flags,
                        a.vis_bans, function(e)
                            return not e.unit.is_stunned
                        end)

                    if targets then
                        for _, t in pairs(targets) do
                            local m = E:create_entity(a.mod)

                            m.modifier.source_id = this.id
                            m.modifier.target_id = t.id

                            queue_insert(store, m)
                        end
                    end

                    U.y_animation_wait(this)

                    a.ts = store.tick_ts
                end
            end

            if not SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_attack()
            end) then
                -- block empty
            else
                coroutine.yield()
            end
        end
    end
end

scripts.enemy_grim_devourers = {}

function scripts.enemy_grim_devourers.update(this, store, script)
    ::label_316_0::

    while true do
        if this.health.dead then
            SU.y_enemy_death(store, this)

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_316_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_316_0
                        end

                        coroutine.yield()
                    end
                end

                if blocker and blocker.health.dead then
                    coroutine.yield()

                    if not blocker.health.dead then
                        goto label_316_0
                    end

                    local target = blocker

                    if band(target.vis.bans, F_CANNIBALIZE) ~= 0 then
                        coroutine.yield()

                        goto label_316_0
                    end

                    U.unblock_all(store, this)
                    U.animation_start(this, "cannibal", nil, store.tick_ts, false)
                    S:queue(this.sound_events.cannibalize)

                    for i = 1, this.cannibalize.cycles do
                        if this.health.dead or not store.entities[target.id] then
                            goto label_316_1
                        end

                        this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.cannibalize.hp_per_cycle)

                        U.y_wait(store, 0.03333333333333333)
                    end

                    U.y_animation_wait(this)
                end

                ::label_316_1::

                coroutine.yield()
            end
        end
    end
end

scripts.aura_shadow_champion_death = {}

function scripts.aura_shadow_champion_death.update(this, store)
    local a = this.aura
    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans, function(e)
        return table.contains(a.include_enemies, e.template_name)
    end)

    if targets then
        for _, t in pairs(targets) do
            local m = E:create_entity(a.enemy_mod)

            m.modifier.source_id = this.id
            m.modifier.target_id = t.id

            queue_insert(store, m)
        end
    end

    targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for _, t in pairs(targets) do
            local m = E:create_entity(a.soldier_mod)

            m.modifier.source_id = this.id
            m.modifier.target_id = t.id

            queue_insert(store, m)
        end
    end

    queue_remove(store, this)
end

scripts.mod_shadow_champion = {}

function scripts.mod_shadow_champion.insert(this, store, script)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead or not target.unit then
        return false
    end

    target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp + target.health.hp_max * this.heal_factor)
    target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor

    return true
end

function scripts.mod_shadow_champion.remove(this, store, script)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        target.unit.damage_factor = math.ceil(target.unit.damage_factor / this.inflicted_damage_factor)
    end

    return true
end

scripts.eb_gnoll = {}

function scripts.eb_gnoll.update(this, store, script)
    local fa = this.timed_attacks.list[1]
    local ha = this.timed_attacks.list[2]

    fa.ts = store.tick_ts

    local function ready_to_howl()
        if (not ha._last_ni or this.nav_path.ni > ha._last_ni) and table.contains(ha.nis, this.nav_path.ni) then
            return true
        end
    end

    local function ready_to_flail()
        return store.tick_ts - fa.ts > fa.cooldown and not this.health.dead and P:nodes_to_defend_point(this.nav_path) >
                   0
    end

    local function y_do_howl()
        S:queue(ha.sound)
        U.animation_start(this, ha.animation, nil, store.tick_ts)
        U.y_wait(store, ha.hit_time)

        ha.wave_idx = km.zmod((ha.wave_idx or 0) + 1, #ha.wave_names)
        this.mega_spawner.manual_wave = ha.wave_names[ha.wave_idx]

        U.y_animation_wait(this)
    end

    this.phase = "intro"
    this.health_bar.hidden = true

    y_do_howl()

    this.phase = "loop"
    this.health_bar.hidden = nil

    ::label_321_0::

    while true do
        if this.health.dead then
            this.phase = "dead"
            this.mega_spawner.interrupt = true

            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)
            LU.kill_all_enemies(store, true)

            this.phase = "death-complete"

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_howl() then
                log.debug("+++++++++++ howling")
                y_do_howl()

                ha._last_ni = this.nav_path.ni
            end

            if ready_to_flail() then
                U.animation_start(this, fa.animation, nil, store.tick_ts)
                U.y_wait(store, fa.hit_time)
                S:queue(fa.sound)

                local targets = U.find_soldiers_in_range(store.soldiers, this.pos, fa.min_range, fa.max_range,
                    fa.vis_flags, fa.vis_bans)

                if targets then
                    for _, target in pairs(targets) do
                        local d = E:create_entity("damage")

                        d.damage_type = fa.damage_type

                        if bit.band(target.vis.flags, F_HERO) ~= 0 then
                            d.value = math.random(fa.damage_min_hero, fa.damage_max_hero)
                        else
                            d.value = math.random(fa.damage_min, fa.damage_max)
                        end

                        d.target_id = target.id
                        d.source_id = this.id

                        queue_damage(store, d)
                    end
                end

                local a = E:create_entity("aura_screen_shake")

                queue_insert(store, a)
                U.y_animation_wait(this)

                fa.ts = store.tick_ts

                goto label_321_0
            end

            local ok, blocker = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_flail() or ready_to_howl()
            end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_321_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_flail() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_321_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.mod_gnoll_boss = {}

function scripts.mod_gnoll_boss.insert(this, store, script)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead or not target.unit then
        return false
    end

    this._hp_bonus = math.floor(target.health.hp_max * this.extra_health_factor)
    target.health.hp_max = target.health.hp_max + this._hp_bonus
    target.health.hp = target.health.hp + this._hp_bonus
    target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor

    return true
end

function scripts.mod_gnoll_boss.remove(this, store, script)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        target.health.hp_max = target.health.hp_max - this._hp_bonus
        target.health.hp = target.health.hp - this._hp_bonus
        target.unit.damage_factor = math.ceil(target.unit.damage_factor / this.inflicted_damage_factor)
    end

    return true
end

scripts.eb_drow_queen = {}

function scripts.eb_drow_queen.on_damage(this, store, damage)
    if this.phase == "fighting" then
        if this.enemy.can_do_magic then
            this.shield.shield_dps = 0
            this.shield.health.hp = 1
            damage.value = damage.value * 0.6
        else
            this.shield.health.hp = 0
        end
        return true
    elseif this.phase == "casting" then
        log.debug("eb_drow_queen shield takes damage: %s", damage.value)

        this.shield.health.hp = this.shield.health.hp - damage.value

        return false
    end

    return false
end

function scripts.eb_drow_queen.update(this, store)
    local sid_body, sid_fly = 1, 4
    local s_body = this.render.sprites[sid_body]
    local d_shield = E:create_entity("decal_drow_queen_shield")

    d_shield.pos = this.pos

    queue_insert(store, d_shield)

    this.shield = d_shield

    local d_flying = E:create_entity("decal_drow_queen_flying")
    local s_flying = d_flying.render.sprites[1]

    queue_insert(store, d_flying)

    local ps = E:create_entity("ps_drow_queen_trail")

    queue_insert(store, ps)

    ps.particle_system.track_id = d_flying.id

    local function block_tower_ids(holder_ids, duration)
        for _, e in pairs(store.towers) do
            if e.tower.can_be_mod and table.contains(holder_ids, e.tower.holder_id) then
                local m = E:create_entity("mod_drow_queen_tower_block")

                m.modifier.source_id = this.id
                m.modifier.target_id = e.id
                m.pos.x, m.pos.y = e.pos.x, e.pos.y

                if duration then
                    m.modifier.duration = duration
                end

                queue_insert(store, m)
            end
        end
    end

    local function block_random_tower()
        local towers = table.filter(store.towers, function(_, e)
            return e.tower.can_be_mod and not e.tower.blocked
        end)
        local tower, tower_id = table.random(towers)

        if tower then
            block_tower_ids({tower.tower.holder_id})
        end

        if #towers > 5 then
            local tower_2 , tower_id_2 = table.random(towers)
            if tower_2 and tower_2_id ~= tower_id then
                block_tower_ids({tower_2.tower.holder_id})
            end
        end
    end

    local function block_all_towers()
        local towers = table.filter(store.towers, function(_, e)
            return e.tower and e.tower.can_be_mod and not e.tower.blocked
        end)
        local holder_ids = table.map(towers, function(k, v)
            return v.tower.holder_id
        end)

        block_tower_ids(holder_ids, 1000000000)
    end

    local function y_fly(from, to, speed, dest_pi)
        SU.remove_modifiers(store, this)

        local af = to.x < from.x

        s_flying.r = V.angleTo(to.x - from.x, to.y - from.y)
        s_flying.flip_y = math.abs(s_flying.r) > math.pi / 2

        S:queue("ElvesMaliciaTransformIn")
        U.y_animation_play(this, "teleportStart", af, store.tick_ts, 1, sid_body)

        s_body.hidden = true
        s_flying.hidden = false

        local fly_dist = V.dist(to.x, to.y, from.x, from.y)
        local fly_time = this.fly_loop_time * math.ceil(fly_dist / speed / this.fly_loop_time)
        local particles_dist = 10
        local emission_rate = fly_dist / particles_dist / fly_time

        ps.particle_system.emission_rate = emission_rate
        ps.particle_system.emit = true

        local start_ts = store.tick_ts
        local phase

        repeat
            phase = (store.tick_ts - start_ts) / fly_time
            d_flying.pos.x = U.ease_value(from.x, to.x, phase, "sine-outin")
            d_flying.pos.y = U.ease_value(from.y, to.y, phase, "sine-outin") + this.fly_offset_y

            coroutine.yield()
        until phase >= 1

        ps.particle_system.emit = false
        this.pos.x, this.pos.y = to.x, to.y
        s_flying.hidden = true
        s_body.hidden = false

        S:queue("ElvesMaliciaTransformOut")
        U.y_animation_play(this, "teleportEnd", af, store.tick_ts, 1, sid_body)

        this.nav_path.pi = dest_pi
        this.nav_path.ni = P:nearest_nodes(this.pos.x, this.pos.y, {dest_pi})[1][3]
    end

    local function y_power(shield_hp, shield_duration, pow_cooldown_min, pow_chances)
        this.vis.bans = U.flag_clear(this.vis.bans, bor(F_RANGED, F_MOD))
        this.health_bar.hidden = false
        this.shield.health.hp = shield_hp
        this.shield.health.hp_max = shield_hp
        this.shield.shield_dps = shield_hp / shield_duration

        local pow_cooldown = pow_cooldown_min
        local cast_ts = store.tick_ts
        local fx

        SU.y_show_taunt_set(store, this.taunts, this.phase)

        ::label_337_0::

        U.y_animation_play(this, "shoutStart", true, store.tick_ts, 1, sid_body)
        U.animation_start(this, "shoutLoop", true, store.tick_ts, true, sid_body)

        while pow_cooldown > store.tick_ts - cast_ts and this.shield.health.hp > 0 do
            coroutine.yield()
        end

        U.y_animation_play(this, "shoutEnd", true, store.tick_ts, 1, sid_body)

        if this.shield.health.hp <= 0 then
            -- block empty
        else
            if not this.enemy.can_do_magic then
                pow_cooldown = pow_cooldown_min
                cast_ts = store.tick_ts
                if this.shield.health.hp > 0 then
                    goto label_337_0
                end
            end
            S:queue("ElvesMaliciaSpellCast")
            U.animation_start(this, "cast", true, store.tick_ts, false, sid_body)

            fx = E:create_entity("fx_drow_queen_cast")
            fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].flip_x = s_body.flip_x

            queue_insert(store, fx)
            U.y_wait(store, fts(13))

            -- if U.random_table_idx(pow_chances) == 2 then
            --     block_random_tower()
            -- else
            --     signal.emit("block-random-power", this.power_block_duration, "drow_queen")
            -- end

            block_random_tower()

            U.y_animation_wait(this)

            pow_cooldown = pow_cooldown_min
            cast_ts = store.tick_ts

            if this.shield.health.hp > 0 then
                goto label_337_0
            end
        end

        U.y_wait(store, fts(12))

        this.health_bar.hidden = true
        this.vis.bans = U.flag_set(this.vis.bans, bor(F_RANGED, F_MOD))
    end

    local function y_fight()
        this.health_bar.hidden = false
        this.vis.bans = U.flag_clear(this.vis.bans, bor(F_BLOCK, F_RANGED, F_MOD, F_TELEPORT))
        this.tween.disabled = false
        this.tween.reverse = true
        this.tween.ts = store.tick_ts

        while true do
            if this.health.hp <= this.hp_threshold then
                break
            end

            if this.unit.is_stunned then
                U.animation_start(this, "idle", nil, store.tick_ts, -1)
                coroutine.yield()
            else
                local function break_fn(store, this)
                    return this.health.hp <= this.hp_threshold
                end

                if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn) then
                    -- block empty
                else
                    coroutine.yield()
                end
            end
        end

        U.unblock_all(store, this)
        SU.remove_modifiers(store, this)

        this.tween.reverse = false
        this.tween.ts = store.tick_ts
        this.health_bar.hidden = true
        this.vis.bans = U.flag_set(this.vis.bans, bor(F_BLOCK, F_RANGED, F_MOD, F_TELEPORT))
    end

    local function y_death()
        this.ui.can_select = false

        S:queue(this.sound_events.death)
        U.y_animation_play(this, "death", true, store.tick_ts)
        U.y_wait(store, 0.5)
        U.y_animation_play(this, "deathEnd", true, store.tick_ts)

        local spider = E:create_entity("decal_s11_mactans")

        spider.pos_drop = V.v(this.pos.x + 8, this.pos.y - 15)
        spider.pos_start = V.v(spider.pos_drop.x, 1100)
        spider.pos.x, spider.pos.y = spider.pos_start.x, spider.pos_start.y

        queue_insert(store, spider)

        local shadow = E:create_entity("decal_mactans_shadow")

        shadow.pos.x, shadow.pos.y = spider.pos_drop.x, spider.pos_drop.y + 16

        queue_insert(store, shadow)

        shadow.tween.ts = store.tick_ts

        local thread = E:create_entity("decal_mactans_thread")

        thread.pos = spider.pos

        queue_insert(store, thread)
        U.animation_start(spider, "falling", nil, store.tick_ts, true)
        S:queue("ElvesFinalBossSpiderIn", {
            delay = spider.drop_duration - fts(25)
        })
        U.y_ease_key(store, spider.pos, "y", spider.pos_start.y, spider.pos_drop.y, spider.drop_duration, "quad-in")
        S:queue("ElvesFinalBossWebspin")
        U.y_animation_play(spider, "startingWeb", nil, store.tick_ts)
        U.animation_start(spider, "web", nil, store.tick_ts, true)

        local webbing = E:create_entity("decal_mactans_webbing")

        webbing.pos = V.v(spider.pos.x, spider.pos.y + 40)

        for i, sprite in ipairs(webbing.render.sprites) do
            sprite.ts = store.tick_ts + (i - 1) * fts(5)
        end

        queue_insert(store, webbing)
        U.y_wait(store, fts(13))

        local cocoon = E:create_entity("decal_s11_drow_queen_cocoon")

        cocoon.pos = spider.pos
        cocoon.render.sprites[1].ts = store.tick_ts

        queue_insert(store, cocoon)
        U.y_wait(store, fts(25))

        this.tween.ts = store.tick_ts
        this.tween.disabled = nil
        this.tween.props[1].disabled = nil
        this.tween.props[2].disabled = true
        this.tween.props[3].disabled = true

        U.y_wait(store, fts(41))
        queue_remove(store, webbing)
        U.animation_start(spider, "malicia_grab", nil, store.tick_ts, false)
        U.y_wait(store, fts(13))
        U.y_ease_key(store, cocoon.render.sprites[1].offset, "y", 15, 8, fts(5), "quad-in")
        U.y_animation_wait(spider)
        U.animation_start(cocoon, "netAnim", nil, store.tick_ts, true)

        cocoon.render.sprites[1].offset.y = -4
        shadow.tween.ts = store.tick_ts
        shadow.tween.reverse = true

        S:queue("ElvesFinalBossSpiderOut")
        U.animation_start(spider, "malicia_climbUp", nil, store.tick_ts, true)
        U.y_ease_key(store, spider.pos, "y", spider.pos_drop.y, spider.pos_start.y, spider.drop_duration)
    end

    this.health.hp_max = this.health.hp_max_rounds[store.level_difficulty][1]
    this.health.hp = this.health.hp_max
    this.pos.x, this.pos.y = this.pos_sitting.x, this.pos_sitting.y
    this.nav_path.pi = this.cast_pi
    this.nav_path.ni = P:nearest_nodes(this.pos.x, this.pos.y, {this.cast_pi})[1][3]
    this.ui.click_rect = this.ui.click_rect_sitting
    this.ui.can_select = false

    U.animation_start(this, "sittingIdle", false, store.tick_ts, true)

    this.phase_signal = nil

    while not this.phase_signal do
        coroutine.yield()
    end

    this.phase = "welcome"

    U.y_wait(store, 1.5)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 1, nil, 3, true)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 2, nil, 3, true)

    this.phase = "prebattle"
    this.phase_signal = nil

    while not this.phase_signal do
        local delay = math.random(this.taunts.delay_min, this.taunts.delay_max)

        if U.y_wait(store, delay, function()
            return this.phase_signal ~= nil
        end) then
            break
        end

        SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)
    end

    this.phase_signal = nil
    this.phase = "sitting"

    while true do
        if this.phase_signal == "summoner" then
            this.phase_signal = nil

            U.y_animation_play(this, "throneCast", false, store.tick_ts, 1, sid_body)
        elseif this.phase_signal == "taunt" then
            this.phase_signal = nil

            SU.y_show_taunt_set(store, this.taunts, this.phase)
        elseif this.phase_signal == "powers" then
            this.phase_signal = nil

            U.y_animation_play(this, "standUp", false, store.tick_ts, 1, sid_body)

            this.ui.click_rect = this.ui.click_rect_default
            this.phase = "flying"

            y_fly(this.pos, this.pos_casting, this.fly_speed_normal, this.cast_pi)

            this.phase = "casting"
            this.ui.can_select = true

            local __, __, shield_hp, pow_cooldown_min, pow_cooldown_max, pow_chances, shield_duration = unpack(
                this.phase_params, 1, 7)

            y_power(shield_hp, shield_duration, pow_cooldown_min, pow_chances)

            this.phase = "flying"
            this.ui.can_select = false

            y_fly(this.pos, this.pos_sitting, this.fly_speed_return, this.cast_pi)
            U.y_animation_play(this, "sitDown", false, store.tick_ts)

            this.phase = "sitting"
            this.ui.click_rect = this.ui.click_rect_sitting
        elseif this.phase_signal == "fight" then
            this.ui.click_rect = this.ui.click_rect_default
            this.phase = "flying"

            y_fly(this.pos, this.pos_casting, this.fly_speed_normal, this.cast_pi)

            this.phase = "casting"
            this.ui.can_select = true

            for i, fight_round in ipairs(this.fight_rounds) do
                local shield_hp, pow_cooldown_min, pow_cooldown_max, pow_chances, shield_duration, packs, pack_pis,
                    fight_pi, tower_set = unpack(fight_round, 1, 9)

                y_power(shield_hp, shield_duration, pow_cooldown_min, pow_chances)

                this.hp = this.health.hp_max_rounds[store.level_difficulty][i]
                this.hp_threshold = this.health.hp_max_rounds[store.level_difficulty][i + 1] or 0

                block_tower_ids(this.tower_block_sets[tower_set])

                this.megaspawner.manual_wave = "BOSSFIGHT0"

                for i, pack_id in ipairs(packs) do
                    this.portals[i].pack = {
                        pi = pack_pis[i],
                        waves = this.portal_packs[pack_id]
                    }
                    this.portals[i].pack_finished = nil
                end

                this.phase = "flying"
                this.ui.can_select = false

                y_fly(this.pos, this.pos_fighting, this.fly_speed_fight, fight_pi)

                this.ui.can_select = true
                this.phase = "fighting"
                this.health_bar.hidden = nil

                y_fight()

                this.health.hp = this.hp_threshold
                this.health_bar.hidden = true

                if this.health.hp > 0 then
                    this.megaspawner.manual_wave = "BOSSRETURN0"
                    this.health.dead = false
                else
                    this.enemy.can_do_magic = false
                    this.shield.health.hp = 0
                    block_all_towers()

                    this.megaspawner.interrupt = true

                    for _, portal in pairs(this.portals) do
                        portal.pack = nil
                    end

                    store.wave_spawn_thread = nil
                    store.waves_finished = true
                    store.waves_active = {}

                    LU.kill_all_enemies(store, true)
                end

                this.phase = "flying"
                this.ui.can_select = false

                y_fly(this.pos, this.pos_casting, this.hp == 0 and this.fly_speed_return_die or this.fly_speed_return,
                    this.cast_pi)

                this.phase = "casting"
                this.ui.can_select = true
            end

            this.phase = "mactans"

            S:stop_all()
            y_death()

            this.phase = "dead"

            signal.emit("boss-killed", this)

            return
        end

        coroutine.yield()
    end
end

scripts.decal_drow_queen_shield = {}

function scripts.decal_drow_queen_shield.update(this, store)
    while true do
        while this.health.hp <= 0 do
            coroutine.yield()
        end

        this.tween.reverse = false
        this.tween.ts = store.tick_ts
        this.tween.disabled = nil
        this.health_bar.hidden = false

        while this.health.hp > 0 do
            coroutine.yield()

            this.health.hp = this.health.hp - this.shield_dps * store.tick_length
        end

        this.health_bar.hidden = true
        this.tween.reverse = true
        this.tween.ts = store.tick_ts

        local fx = E:create_entity("fx_drow_queen_shield_break")

        fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end
end

scripts.eb_spider = {}

function scripts.eb_spider.get_info(this)
    local b = E:get_template(this.ranged.attacks[1].bullet)

    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = b.bullet.damage_min,
        damage_max = b.bullet.damage_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_spider.update(this, store, script)
    local boss_rounds = store.level.boss_rounds
    local round_idx = 1
    local hp_max_rounds = this.health.hp_max_rounds[store.level_difficulty]

    this.health.hp_max = hp_max_rounds[round_idx]
    this.health.hp = this.health.hp_max

    local shadow = E:create_entity("decal_shadow_eb_spider")

    queue_insert(store, shadow)

    local function y_jump_out()
        U.unblock_all(store, this)
        SU.remove_modifiers(store, this)

        this.vis.bans = U.flag_set(this.vis.bans, bor(F_BLOCK, F_RANGED, F_MOD, F_TELEPORT))
        this.health_bar.hidden = true
        shadow.pos = V.v(this.pos.x, this.pos.y)

        U.animation_start(this, "jump", nil, store.tick_ts, false)
        U.y_wait(store, fts(10))

        shadow.tween.reverse = true
        shadow.tween.ts = store.tick_ts

        U.y_animation_wait(this)
        S:queue("ElvesFinalBossJump")

        local smoke = E:create_entity("fx_eb_spider_jump_smoke")

        smoke.pos.x, smoke.pos.y = this.pos.x, this.pos.y
        smoke.render.sprites[1].ts = store.tick_ts

        queue_insert(store, smoke)
        U.animation_start(this, "flyingUp", nil, store.tick_ts, false)

        for _, s in pairs(this.render.sprites) do
            s.sort_y = this.pos.y
        end

        U.y_ease_key(store, this.pos, "y", this.pos.y, this.pos.y + REF_H, 1, "quad-in")
    end

    local function y_jump_in(round_idx)
        this.megaspawner.manual_wave = string.format("BOSS%i", round_idx - 1)
        this.hp_threshold = hp_max_rounds[round_idx + 1] or 0

        local round = boss_rounds[round_idx]
        local pis = P:get_connected_paths(round.pi)
        local nodes = P:nearest_nodes(round.pos.x, round.pos.y, pis, nil, true)
        local dest, dest_node

        if #nodes < 0 then
            log.error("eb_spider: could not find node near %s,%s in paths:%s", round.pos.x, round.pos.y, getdump(pis))

            return
        else
            dest_node = {
                spi = 1,
                dir = 1,
                pi = nodes[1][1],
                ni = nodes[1][3]
            }
        end

        local dest = P:node_pos(dest_node)

        this.nav_path.pi = dest_node.pi
        this.nav_path.ni = dest_node.ni + 1
        this.pos.x, this.pos.y = dest.x, REF_H + 20

        for _, s in pairs(this.render.sprites) do
            s.sort_y = dest.y
        end

        shadow.tween.reverse = nil
        shadow.tween.ts = store.tick_ts
        shadow.pos.x, shadow.pos.y = dest.x, dest.y

        U.animation_start(this, "flyingDown", nil, store.tick_ts, false)

        local landing = false

        U.y_ease_key(store, this.pos, "y", this.pos.y, dest.y, 0.6, "quad-out", function(dt, ph)
            if dt >= 0.5 and not landing then
                landing = true

                S:queue("ElvesFinalBossSpiderGoddessFall")
                U.animation_start(this, "land", nil, store.tick_ts, false)
            end
        end)

        for _, s in pairs(this.render.sprites) do
            s.sort_y = nil
        end

        U.y_animation_wait(this)

        shadow.pos = this.pos
        this.health_bar.hidden = nil
        this.vis.bans = U.flag_clear(this.vis.bans, bor(F_BLOCK, F_RANGED, F_MOD, F_TELEPORT))

        local aura = E:create_entity("aura_eb_spider_path_web")

        aura.pos.x, aura.pos.y = dest.x, dest.y
        aura.aura.ts = store.tick_ts
        aura.eggs = store.level.mactans_eggs
        aura.qty_per_egg = round.qty_per_egg
        aura.pi = dest_node.pi
        aura.ni = dest_node.ni

        queue_insert(store, aura)
    end

    local function y_death()
        this.health_bar.hidden = true

        S:queue(this.sound_events.death)
        U.y_animation_play(this, "death_first_start", nil, store.tick_ts)
        SU.y_show_taunt_set(store, this.taunts, "death", 1, this.pos, 2, false)
        U.y_animation_play(this, "death_first_loop", nil, store.tick_ts, 10)
        U.animation_start(this, "death_second_start", nil, store.tick_ts, false)
        U.y_wait(store, fts(6))

        local rays = E:create_entity("decal_eb_spider_death_second_rays")

        rays.pos.x, rays.pos.y = this.pos.x, this.pos.y + 68
        rays.tween.ts = store.tick_ts

        queue_insert(store, rays)
        U.y_animation_wait(this)
        U.animation_start(this, "death_second_loop", nil, store.tick_ts, true)
        U.y_wait(store, fts(7) + 2)

        local circle = E:create_entity("decal_eb_spider_death_white_circle")

        circle.pos.x, circle.pos.y = rays.pos.x, rays.pos.y
        circle.tween.ts = store.tick_ts

        queue_insert(store, circle)
        U.y_wait(store, 0.5)
    end

    local function y_destroy_tower()
        local a = this.timed_attacks.list[3]
        local towers = table.filter(store.towers, function(_, e)
            return e.tower and e.tower.can_be_mod and not e.tower.blocked and
                       not table.contains(a.excluded_templates, e.template_name) and math.abs(e.pos.x - this.pos.x) > 45 and
                       U.is_inside_ellipse(e.pos, this.pos, a.max_range)
        end)

        if #towers < 1 then
            return
        end

        local tower = table.random(towers)

        S:queue(a.sound)

        local af = tower.pos.x < this.pos.x

        U.y_animation_play(this, a.animations[1], af, store.tick_ts)
        U.y_animation_play(this, a.animations[2], af, store.tick_ts, 2)
        U.animation_start(this, a.animations[3], af, store.tick_ts, false)
        U.y_wait(store, a.shoot_time)

        local o = a.bullet_start_offset[1]
        local b = E:create_entity(a.bullet)

        b.bullet.from = V.v(this.pos.x + (af and -1 or 1) * o.x, this.pos.y + o.y)
        b.bullet.to = V.v(tower.pos.x, tower.pos.y + 8)
        b.bullet.source_id = this.id
        b.bullet.target_id = tower.id
        b.pos = V.vclone(b.bullet.from)

        queue_insert(store, b)
        U.y_animation_wait(this)
    end

    local function reset_cooldowns()
        this.ranged.attacks[1].ts = store.tick_ts
        this.timed_attacks.list[1].ts = store.tick_ts
        this.timed_attacks.list[2].ts = store.tick_ts
    end

    local function ready_to_jump()
        return this.health.hp > 0 and this.health.hp <= this.hp_threshold
    end

    local function ready_to_long_range()
        local a = this.timed_attacks.list[1]

        return store.tick_ts - a.ts > a.cooldown
    end

    local function ready_to_block()
        local a = this.timed_attacks.list[2]

        return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic
    end

    local function break_fn()
        -- return ready_to_jump() or ready_to_long_range() or ready_to_block() or this.unit.is_stunned
        return ready_to_jump() or ready_to_block() or this.unit.is_stunned
    end

    this.health_bar.hidden = true
    shadow.pos = this.pos
    shadow.tween.reverse = nil
    shadow.tween.ts = 0

    local fx = E:create_entity("fx_eb_spider_spawn")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y - 1

    queue_insert(store, fx)
    U.y_wait(store, fts(45))

    fx.tween.disabled = nil
    fx.tween.ts = store.tick_ts

    U.animation_start(this, "shoutOurs", nil, store.tick_ts, false)
    U.y_wait(store, fts(6))
    SU.y_show_taunt_set(store, this.taunts, "intro", 1, V.v(this.pos.x, this.pos.y - 30), fts(48), true)
    y_jump_out()
    U.y_wait(store, 1)
    y_jump_in(round_idx)
    reset_cooldowns()

    this.phase = "fight"

    local cont, blocker, ranged

    ::label_344_0::

    while true do
        if this.health.dead then
            this.phase = "death-animation"
            this.megaspawner.interrupt = true

            LU.kill_all_enemies(store, true)
            S:stop_all()
            y_death()
            signal.emit("boss-killed", this)

            this.phase = "dead"

            LU.kill_all_enemies(store, true)

            return
        end

        if ready_to_jump() then
            y_destroy_tower()

            round_idx = round_idx + 1

            y_jump_out()
            U.y_wait(store, 1)
            y_jump_in(round_idx)
        elseif this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, true)
            coroutine.yield()
        else
            if ready_to_long_range() then
                local a = this.timed_attacks.list[1]
                local targets = U.find_soldiers_in_range(store.soldiers, this.pos, a.min_range, a.max_range,
                    a.vis_flags, a.vis_bans)

                if not targets then
                    SU.delay_attack(store, a, 1)
                else
                    local target = table.random(targets)

                    a.ts = store.tick_ts

                    SU.y_enemy_do_ranged_attack(store, this, target, a)

                    a.ts = store.tick_ts
                end
            end

            if ready_to_block() then
                local a = this.timed_attacks.list[2]

                U.animation_start(this, "blockTower", nil, store.tick_ts, false)
                U.y_wait(store, a.hit_time)
                S:queue(a.hit_sound)

                local towers = table.filter(store.towers, function(_, e)
                    return e.tower and e.tower.can_be_mod and not e.tower.blocked
                end)
                local sel_towers = {}

                while #towers > 0 and #sel_towers < a.tower_count[round_idx] + 1 do
                    local t, i = table.random(towers)

                    table.insert(sel_towers, t)
                    table.remove(towers, i)
                end

                for _, e in pairs(sel_towers) do
                    local m = E:create_entity(a.mod)

                    m.modifier.source_id = this.id
                    m.modifier.target_id = e.id
                    m.pos.x, m.pos.y = e.pos.x, e.pos.y

                    queue_insert(store, m)
                end

                -- signal.emit("block-random-power", a.power_block_duration, "eb_spider")
                -- U.y_animation_wait(this)

                a.ts = store.tick_ts

                goto label_344_0
            end

            cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_344_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not break_fn() do
                        if not SU.y_enemy_range_attacks(store, this, blocker) then
                            goto label_344_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.eb_bram = {}

function scripts.eb_bram.get_info(this)
    return {
        type = STATS_TYPE_ENEMY,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = this.melee.attacks[1].damage_min,
        damage_max = this.melee.attacks[1].damage_max,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        lives = this.enemy.lives_cost
    }
end

function scripts.eb_bram.update(this, store)
    local ac = this.timed_attacks.list[1]

    local function ready_to_convert()
        return store.tick_ts - ac.ts > ac.cooldown and P:nodes_to_defend_point(this.nav_path) > ac.nodes_limit
    end

    this.phase_signal = nil

    while not this.phase_signal do
        coroutine.yield()
    end

    this.phase = "welcome"

    U.y_wait(store, 1.5)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 1, nil, 3, true)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 2, nil, 3, true)

    this.phase = "sitting"
    this.phase_signal = nil

    while not this.phase_signal do
        local delay = math.random(this.taunts.delay_min, this.taunts.delay_max)

        if U.y_wait(store, delay, function()
            return this.phase_signal ~= nil
        end) then
            break
        end

        SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)
    end

    this.phase = "prebattle"

    U.y_wait(store, 1.5)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 1, nil, 3, true)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 2, nil, 3, true)

    this.phase = "battle"
    this.health_bar.hidden = nil

    U.y_animation_play(this, "raise", nil, store.tick_ts)

    ::label_358_0::

    while true do
        if this.health.dead then
            this.phase = "dead"

            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)
            LU.kill_all_enemies(store, true)

            this.phase = "death-complete"

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_convert() then
                local a = ac
                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.max_range, a.vis_flags,
                    a.vis_bans, function(e)
                        return table.contains(a.allowed_templates, e.template_name)
                    end)

                if not targets or #targets < a.min_count then
                    SU.delay_attack(store, a, 0.5)
                else
                    a.ts = store.tick_ts

                    U.animation_start(this, a.animation, nil, store.tick_ts, false)

                    while store.tick_ts - a.ts < a.cast_time do
                        if this.health.dead or this.unit.is_stunned then
                            goto label_358_0
                        end

                        coroutine.yield()
                    end

                    local decal = E:create_entity(a.hit_decal)

                    decal.pos.x, decal.pos.y = this.pos.x, this.pos.y
                    decal.tween.ts = store.tick_ts

                    queue_insert(store, decal)

                    for i, target in ipairs(targets) do
                        if i > a.max_count then
                            break
                        end

                        local e = E:create_entity(a.mod)

                        e.modifier.target_id = target.id

                        queue_insert(store, e)
                    end

                    SU.y_enemy_animation_wait(this)

                    goto label_358_0
                end
            end

            local ok, blocker = SU.y_enemy_walk_until_blocked(store, this, false, function(this, store)
                return ready_to_convert()
            end)

            if not ok then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_358_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_convert() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_358_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.mod_bram_slap = {}

function scripts.mod_bram_slap.queue(this, store, insertion)
    local target = store.entities[this.modifier.target_id]

    if not target then
        return
    end

    if insertion then
        target.vis.bans = F_ALL

        SU.stun_inc(target)
    end
end

function scripts.mod_bram_slap.update(this, store)
    local target = store.entities[this.modifier.target_id]
    local source = store.entities[this.modifier.source_id]

    if not target or not source then
        queue_remove(store, this)

        return
    end

    local af = source.pos.x > target.pos.x

    this.pos.x, this.pos.y = target.pos.x, target.pos.y

    local d = E:create_entity("damage")

    d.damage_type = DAMAGE_EAT
    d.source_id = this.id
    d.target_id = target.id

    queue_damage(store, d)

    local es = E:create_entity("decal_bram_enemy_clone")

    es.pos.x, es.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
    es.render = table.deepclone(target.render)
    es.render.sprites[1].anchor = this.custom_anchors[target.template_name] or this.custom_anchors.default
    es.tween.disabled = nil
    es.tween.ts = store.tick_ts

    local dx, dy = V.rotate(math.random(20, 45) * math.pi / 180, math.random(180, 240), 0)

    dx = (af and -1 or 1) * dx
    es.tween.props[2].keys[2][2].x, es.tween.props[2].keys[2][2].y = dx, dy
    es.tween.props[3].keys[2][2] = (af and -1 or 1) * math.random(300, 400) * math.pi / 180

    queue_insert(store, es)
    queue_remove(store, this)
end

scripts.eb_bajnimen = {}

function scripts.eb_bajnimen.on_damage(this, store, damage)
    log.debug("  EB_BAJNIMEN ON_DAMAGE: %s", damage.value)

    local ar = this.timed_attacks.list[2]

    if this.health.dead or ar.current_step > #ar.steps then
        return true
    end

    if ar.active then
        return false
    end

    local pd = U.predict_damage(this, damage)

    if ar.steps[ar.current_step].hp_threshold > (this.health.hp - pd) / this.health.hp_max then
        ar.active = true
    end

    return true
end

function scripts.eb_bajnimen.update(this, store)
    local as = this.timed_attacks.list[1]
    local ar = this.timed_attacks.list[2]
    local cont, blocker, ranged

    local function spawn_meteor(pi, spi, ni)
        spi = spi or math.random(1, 3)

        local pos = P:node_pos(pi, spi, ni)

        pos.x = pos.x + math.random(-4, 4)
        pos.y = pos.y + math.random(-5, 5)

        local b = E:create_entity(as.bullet)

        b.bullet.from = V.v(pos.x + math.random(190, 160), pos.y + REF_H)
        b.bullet.to = pos
        b.pos = V.vclone(b.bullet.from)

        queue_insert(store, b)
    end

    local function ready_to_storm()
        return store.tick_ts - as.ts > as.cooldown
    end

    local function ready_to_regen()
        return ar.active
    end

    local function break_fn()
        return ready_to_storm() or ready_to_regen() or this.unit.is_stunned
    end

    as.ts = store.tick_ts
    ar.ts = store.tick_ts

    ::label_366_0::

    while true do
        if this.health.dead then
            this.phase = "dead"

            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)
            LU.kill_all_enemies(store, true)

            this.phase = "death-complete"

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_storm() then
                local a = as
                local hero = store.main_hero
                local target

                if hero and not hero.health.dead and band(hero.vis.bans, F_RANGED) == 0 then
                    target = hero
                else
                    target = U.find_random_target(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)
                end

                if not target then
                    SU.delay_attack(store, a, 0.2)
                else
                    a.ts = store.tick_ts

                    S:queue(a.sound)
                    U.y_animation_play(this, a.animations[1], nil, store.tick_ts)
                    U.animation_start(this, a.animations[2], nil, store.tick_ts, true)

                    local nearest = P:nearest_nodes(target.pos.x, target.pos.y)

                    if #nearest > 0 then
                        local pi, spi, ni = unpack(nearest[1])

                        spawn_meteor(pi, spi, ni)

                        local count = a.spread
                        local sequence = {}

                        for i = 1, count do
                            sequence[i] = i
                        end

                        while #sequence > 0 do
                            local i = table.remove(sequence, math.random(1, #sequence))
                            local delay = U.frandom(0, 1 / count)

                            U.y_wait(store, delay / 2)

                            if P:is_node_valid(pi, ni + i) then
                                spawn_meteor(pi, nil, ni + i)
                            else
                                spawn_meteor(pi, nil, ni - i)
                            end

                            U.y_wait(store, delay / 2)

                            if P:is_node_valid(pi, ni - i) then
                                spawn_meteor(pi, nil, ni - i)
                            else
                                spawn_meteor(pi, nil, ni + i)
                            end
                        end
                    end

                    if SU.y_enemy_wait(store, this, 1) then
                        -- block empty
                    else
                        U.y_animation_play(this, a.animations[3], nil, store.tick_ts)

                        a.ts = store.tick_ts
                    end

                    goto label_366_0
                end
            end

            if ready_to_regen() then
                local a = ar
                local hp_heal = a.steps[a.current_step].hp_heal

                S:queue(a.sound)
                U.y_animation_play(this, a.animations[1], nil, store.tick_ts)

                local prev_hit_offset = this.unit.hit_offset
                local prev_mod_offset = this.unit.mod_offset

                this.unit.hit_offset = a.hit_offset
                this.unit.mod_offset = a.mod_offset

                U.animation_start(this, a.animations[2], nil, store.tick_ts, true)

                local start_ts, tick_ts = store.tick_ts, store.tick_ts - a.heal_every

                while store.tick_ts - start_ts <= a.duration do
                    if store.tick_ts - tick_ts >= a.heal_every then
                        tick_ts = tick_ts + a.heal_every
                        this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + hp_heal)
                    end

                    coroutine.yield()
                end

                U.y_animation_play(this, a.animations[3], nil, store.tick_ts)

                this.unit.hit_offset = prev_hit_offset
                this.unit.mod_offset = prev_mod_offset
                a.current_step = a.current_step + 1
                a.active = false

                goto label_366_0
            end

            cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

            if not cont then
                -- block empty
            else
                if ranged then
                    if not SU.can_range_soldier(store, this, ranged) then
                        goto label_366_0
                    end

                    if not SU.y_enemy_range_attacks(store, this, ranged) then
                        goto label_366_0
                    end
                elseif blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_366_0
                    end

                    if not SU.can_melee_blocker(store, this, blocker) then
                        coroutine.yield()

                        goto label_366_0
                    end

                    if not SU.y_enemy_melee_attacks(store, this, blocker) then
                        goto label_366_0
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.eb_balrog = {}

function scripts.eb_balrog.update(this, store)
    local at = this.timed_attacks.list[1]
    local cont, blocker, ranged
    local stage_hero = LU.list_entities(store.soldiers, "hero_bolverk")[1]

    local function ready_to_taint()
        return store.tick_ts - at.ts > at.cooldown
    end

    at.ts = store.tick_ts

    ::label_371_0::

    while true do
        if this.health.dead then
            this.phase = "dead"

            LU.kill_all_enemies(store, true)
            S:stop_all()
            S:queue(this.sound_events.death)
            U.y_animation_play(this, "death", nil, store.tick_ts)
            signal.emit("boss-killed", this)
            LU.kill_all_enemies(store, true)

            this.phase = "death-complete"

            return
        end

        if this.unit.is_stunned then
            U.animation_start(this, "idle", nil, store.tick_ts, -1)
            coroutine.yield()
        else
            if ready_to_taint() then
                local a = at
                local hero = store.main_hero
                local target

                if hero and not hero.health.dead and U.flags_pass(hero.vis, at) then
                    target = hero
                elseif stage_hero and not stage_hero.health.dead and U.flags_pass(stage_hero.vis, at) then
                    target = stage_hero
                else
                    target = U.find_random_target(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags,
                        a.vis_bans)
                end

                if not target then
                    SU.delay_attack(store, at, 0.2)
                else
                    local nearest = P:nearest_nodes(target.pos.x, target.pos.y)

                    if #nearest < 1 then
                        SU.delay_attack(store, at, 0.2)
                    else
                        local pi, spi, ni = unpack(nearest[1])
                        local shoot_dest = P:node_pos(pi, 1, ni)

                        S:queue(a.sound)

                        local an, af, ai = U.animation_name_facing_point(this, a.animation, shoot_dest)

                        U.animation_start(this, a.animation, af, store.tick_ts, false)
                        U.y_wait(store, a.shoot_time)

                        local o = a.bullet_start_offset[1]
                        local b = E:create_entity(a.bullet)

                        b.bullet.to = shoot_dest
                        b.bullet.from = V.v(this.pos.x + (af and -1 or 1) * o.x, this.pos.y + o.y)
                        b.bullet.source_id = this.id
                        b.pos = V.vclone(b.bullet.from)

                        queue_insert(store, b)

                        a.ts = store.tick_ts

                        U.y_animation_wait(this)

                        goto label_371_0
                    end
                end
            end

            local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_taint)

            if not cont then
                -- block empty
            else
                if blocker then
                    if not SU.y_wait_for_blocker(store, this, blocker) then
                        goto label_371_0
                    end

                    while SU.can_melee_blocker(store, this, blocker) and not ready_to_taint() do
                        if not SU.y_enemy_melee_attacks(store, this, blocker) then
                            goto label_371_0
                        end

                        coroutine.yield()
                    end
                end

                coroutine.yield()
            end
        end
    end
end

scripts.eb_hee_haw = {}

function scripts.eb_hee_haw.update(this, store)
    local catapults = LU.list_entities(store.entities, "decal_catapult_endless")

    this.phase_signal = nil
    this.phase = "welcome"

    U.y_wait(store, 1.5)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 1, nil, 3, true)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 2, nil, 3, true)

    this.phase = "prebattle"

    while not this.phase_signal do
        local delay = math.random(this.taunts.delay_min, this.taunts.delay_max)

        if U.y_wait(store, delay, function()
            return this.phase_signal ~= nil
        end) then
            break
        end

        SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)
        coroutine.yield()
    end

    local last_wave_number
    local a = this.attacks
    local wave_config

    this.phase = "battle"
    this.taunts.next_ts = store.tick_ts + math.random(this.taunts.delay_min, this.taunts.delay_max)

    while true do
        if store.tick_ts > this.taunts.next_ts then
            SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)

            this.taunts.next_ts = store.tick_ts + math.random(this.taunts.delay_min, this.taunts.delay_max)
        end

        if store.wave_group_number ~= last_wave_number then
            last_wave_number = store.wave_group_number
            wave_config = W:get_endless_boss_config(store.wave_group_number)
            a.chance = wave_config.chance
            a.cooldown = wave_config.cooldown
            a.multiple_attacks_chance = wave_config.multiple_attacks_chance
            a.power_chances = wave_config.power_chances

            log.debug("EB_HEE_HAW: setting wave config for wave %s - chance:%s cooldown:%s multi:%s",
                store.wave_group_number, a.chance, a.cooldown, a.multiple_attacks_chance)

            a.ts = store.tick_ts
        end

        if store.tick_ts - a.ts > a.cooldown then
            a.ts = store.tick_ts

            while math.random() < a.chance do
                local delay_to_power = U.frandom(0.6, 0.9)
                local a_idx = U.random_table_idx(a.power_chances)
                local aa = this.attacks.list[a_idx]
                local plevel = km.clamp(0, 9000000000,
                    store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

                log.debug("EB_HEE_HAW | ts:%s wave:%s attack idx:%s, plevel:%s", store.tick_ts, store.wave_group_number,
                    a_idx, plevel)

                if a_idx == 1 or a_idx == 2 then
                    local catapult = table.random(table.filter(catapults, function(k, c)
                        return c.phase == "out"
                    end))

                    if not catapult then
                        log.debug("eb_hee_haw: skipping catapult attack. both catapults busy.")

                        goto label_373_0
                    end

                    U.y_wait(store, delay_to_power)
                    S:queue(aa.sound)
                    U.y_animation_play(this, aa.animation, nil, store.tick_ts)

                    local pconf = a_idx == 1 and wave_config.powers_config.barrel or wave_config.powers_config.catapult
                    local dconf = wave_config.boss_config_dif

                    catapult.duration =
                        km.clamp(0, pconf.durationMax, pconf.duration + plevel * pconf.durationIncrement)

                    local ca = catapult.ranged.attacks[1]

                    ca.cooldown = pconf.reload or pconf.munitionReload

                    local multi_chance = pconf.multishotChance + plevel * pconf.multishotChanceIncrement

                    if multi_chance > math.random() then
                        local m_idx = U.random_table_idx(a_idx == 1 and dconf.barrelAmountDistribution or
                                                             dconf.catapultAmountDistribution)

                        ca.count = aa.multishot_counts[m_idx]
                    else
                        ca.count = 1
                    end

                    if a_idx == 1 then
                        ca.munition_type = aa.munition_type
                        ca.barrel_payload_idx = U.random_table_idx(dconf.barrelTypeDistribution)
                    else
                        ca.munition_type = U.random_table_idx(dconf.catapultMunitionTypeDistribution)
                        ca.min_x = pconf.minRange
                        ca.max_range = pconf.maxRange
                    end

                    catapult.phase_signal = "enter"
                elseif a_idx == 3 then
                    local target
                    local h = store.main_hero

                    if h and not h.health.dead and not h.unit.is_stunned and not U.flag_has(h.vis.flags, F_FLYING) then
                        target = h
                    else
                        target = U.find_random_target(store.entities, V.v(0, 0), 0, 1e+99, F_RANGED,
                            bor(F_ENEMY, F_FLYING), function(e)
                                return not e.unit.is_stunned
                            end)
                    end

                    if not target then
                        log.debug("eb_hee_haw: skipping snare attack. both catapults busy.")

                        goto label_373_0
                    end

                    U.y_wait(store, delay_to_power)
                    U.animation_start(this, aa.animation, nil, store.tick_ts)
                    U.y_wait(store, aa.shoot_time)

                    local pconf = wave_config.powers_config.snare
                    local b = E:create_entity(aa.bullet)

                    b.pos = V.v(this.pos.x + aa.bullet_start_offset.x, this.pos.y + aa.bullet_start_offset.y)
                    b.bullet.from = V.vclone(b.pos)
                    b.bullet.to = V.vclone(target.pos)
                    b.bullet.target_id = target.id
                    b.bullet.mod_duration = km.clamp(pconf.duration, pconf.durationMax,
                        pconf.duration + plevel * pconf.durationIncrement)

                    queue_insert(store, b)
                    U.y_animation_wait(this)
                end

                U.animation_start(this, "idle", nil, store.tick_ts)

                ::label_373_0::

                if math.random() >= a.multiple_attacks_chance then
                    break
                end
            end
        end

        coroutine.yield()
    end
end

scripts.snare_hee_haw = {}

function scripts.snare_hee_haw.update(this, store)
    local b = this.bullet

    this.render.sprites[1].flip_y = true

    U.y_ease_key(store, this.pos, "y", this.pos.y, this.pos.y + 1000, 0.5)
    SU.insert_sprite(store, "decal_snare_hee_haw", b.to)
    S:queue(this.sound_events.falling)

    this.render.sprites[1].flip_y = nil
    this.pos.x, this.pos.y = b.to.x, b.to.y + 1600

    U.y_ease_keys(store, {this.pos, this.pos}, {"x", "y"}, {this.pos.x, this.pos.y}, {b.to.x, b.to.y}, 2)
    S:queue(this.sound_events.hit)

    local target = store.entities[b.target_id]

    if target and not target.health.dead and U.flags_pass(target.vis, b) and
        U.is_inside_ellipse(target.pos, b.to, b.mod_radius) then
        local m = E:create_entity(b.mod)

        m.modifier.target_id = target.id
        m.modifier.source_id = this.id
        m.modifier.duration = b.mod_duration
        m.modifier.duration_heroes = b.mod_duration

        queue_insert(store, m)
    else
        this.pos.y = b.to.y
        this.render.sprites[1].z = Z_OBJECTS
        this.render.sprites[1].sort_y_offset = -2

        U.y_animation_play(this, "miss", nil, store.tick_ts)
        U.y_ease_key(store, this.render.sprites[1], "alpha", 255, 0, fts(10))
    end

    queue_remove(store, this)
end

scripts.eb_ainyl = {}

function scripts.eb_ainyl.update(this, store)
    this.phase_signal = nil
    this.phase = "welcome"

    U.y_wait(store, 1.5)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 1, nil, 3, true)
    SU.y_show_taunt_set(store, this.taunts, this.phase, 2, nil, 3, true)

    this.phase = "prebattle"

    while not this.phase_signal do
        local delay = math.random(this.taunts.delay_min, this.taunts.delay_max)

        if U.y_wait(store, delay, function()
            return this.phase_signal ~= nil
        end) then
            break
        end

        SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)
        coroutine.yield()
    end

    local last_wave_number
    local a = this.attacks
    local wave_config

    this.phase = "battle"
    this.taunts.next_ts = store.tick_ts + math.random(this.taunts.delay_min, this.taunts.delay_max)

    while true do
        if store.tick_ts > this.taunts.next_ts then
            SU.y_show_taunt_set(store, this.taunts, this.phase, nil, nil, nil, true)

            this.taunts.next_ts = store.tick_ts + math.random(this.taunts.delay_min, this.taunts.delay_max)
        end

        if store.wave_group_number ~= last_wave_number then
            last_wave_number = store.wave_group_number
            wave_config = W:get_endless_boss_config(store.wave_group_number)
            a.chance = wave_config.chance
            a.cooldown = wave_config.cooldown
            a.multiple_attacks_chance = wave_config.multiple_attacks_chance
            a.power_chances = wave_config.power_chances

            log.debug("EB_AINYL: setting wave config for wave %s - chance:%s cooldown:%s multi:%s",
                store.wave_group_number, a.chance, a.cooldown, a.multiple_attacks_chance)

            a.ts = store.tick_ts
        end

        if store.tick_ts - a.ts > a.cooldown then
            a.ts = store.tick_ts

            while math.random() < a.chance do
                local a_idx = U.random_table_idx(a.power_chances)
                local aa = this.attacks.list[a_idx]
                local plevel = km.clamp(0, 9000000000,
                    store.wave_group_number - wave_config.powers_config.powerProgressionWaveStart)

                log.debug("EB_AINYL | ts:%s wave:%s attack idx:%s, plevel:%s", store.tick_ts, store.wave_group_number,
                    a_idx, plevel)

                if a_idx == 1 then
                    local pconf = wave_config.powers_config.teleport
                    local best_set = {}
                    local target

                    for _, ce in pairs(store.entities) do
                        if not ce.pending_removal and ce.enemy and ce.vis and ce.nav_path and not ce.health.dead and
                            band(ce.vis.flags, aa.vis_bans) == 0 and band(ce.vis.bans, aa.vis_flags) == 0 and
                            P:is_node_valid(ce.nav_path.pi, ce.nav_path.ni) and P:nodes_to_defend_point(ce.nav_path) >
                            aa.nodes_limit then
                            local nearby = table.filter(store.entities, function(k, v)
                                return v ~= ce and not v.pending_removal and v.enemy and v.vis and v.nav_path and
                                           v.health and not v.health.dead and band(v.vis.flags, aa.vis_bans) == 0 and
                                           band(v.vis.bans, aa.vis_flags) == 0 and
                                           P:is_node_valid(v.nav_path.pi, v.nav_path.ni) and v.nav_path.pi ==
                                           ce.nav_path.pi and math.abs(v.nav_path.ni - ce.nav_path.ni) <
                                           pconf.nodesRange and P:nodes_to_defend_point(v.nav_path) > aa.nodes_limit
                            end)

                            if #nearby > #best_set then
                                target = ce
                                best_set = nearby
                            end
                        end
                    end

                    if not target or not best_set then
                        log.debug("eb_ainyl: skipping teleport. target:%s, best_set:%s", target, best_set)

                        goto label_378_0
                    end

                    local targets = table.append({target}, best_set)

                    if #targets < pconf.minEnemies then
                        log.debug("eb_ainyl: skipping teleport. not enough #targets:%s", #targets)

                        goto label_378_0
                    end

                    S:queue(aa.sound)
                    U.animation_start(this, aa.animation, nil, store.tick_ts)
                    U.y_wait(store, aa.shoot_time)

                    for i = 1, math.min(#targets, pconf.maxEnemies) do
                        local e = targets[i]
                        local m = E:create_entity(aa.mod)

                        m.nodes_offset = math.random(pconf.minNodes, pconf.maxNodes)
                        m.modifier.target_id = e.id
                        m.modifier.source_id = this.id

                        queue_insert(store, m)
                    end

                    U.y_animation_wait(this)
                elseif a_idx == 2 then
                    local pconf = wave_config.powers_config.blockTower
                    local targets = U.find_towers_in_range(store.towers, this.pos, aa, function(t)
                        return t.tower.can_be_mod
                    end)

                    if not targets then
                        log.debug("eb_ainyl: skipping block_tower. target not found")

                        goto label_378_0
                    end

                    S:queue(aa.sound)
                    U.animation_start(this, aa.animation, nil, store.tick_ts)
                    U.y_wait(store, aa.shoot_time)

                    targets = U.find_towers_in_range(store.towers, this.pos, aa, function(t)
                        return t.tower.can_be_mod
                    end)

                    if not targets then
                        log.debug("eb_ainyl: skipping block_tower. target not found in second search")
                    else
                        local target = table.random(targets)
                        local m = E:create_entity(aa.mod)

                        m.modifier.target_id = target.id
                        m.modifier.source_id = this.id
                        m.modifier.duration = km.clamp(0, pconf.durationMax,
                            pconf.duration + plevel * pconf.durationIncrement)

                        queue_insert(store, m)
                    end

                    U.y_animation_wait(this)
                elseif a_idx == 3 then
                    local pconf = wave_config.powers_config.shield
                    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, 1e+99, aa.vis_flags,
                        aa.vis_bans, function(e)
                            return e and e.health and e.health.hp < e.health.hp_max
                        end)

                    if not targets then
                        log.debug("eb_ainyl: skipping shield. target not found")

                        goto label_378_0
                    end

                    S:queue(aa.sound)
                    U.animation_start(this, aa.animation, nil, store.tick_ts)
                    U.y_wait(store, aa.shoot_time)

                    targets = U.find_enemies_in_range(store.enemies, this.pos, 0, 1e+99, aa.vis_flags, aa.vis_bans,
                        function(e)
                            return e and e.health and e.health.hp < e.health.hp_max
                        end)

                    if not targets then
                        log.debug("eb_ainyl: skipping shield. target not found in second search")
                    else
                        table.sort(targets, function(e1, e2)
                            return e1.health.hp < e2.health.hp
                        end)

                        local target = targets[1]

                        SU.remove_modifiers(store, target)

                        local m = E:create_entity(aa.mod)

                        m.modifier.target_id = target.id
                        m.modifier.source_id = this.id
                        m.modifier.duration = km.clamp(0, pconf.durationMax,
                            pconf.duration + plevel * pconf.durationIncrement)

                        queue_insert(store, m)
                    end

                    U.y_animation_wait(this)
                end

                U.animation_start(this, "idle", nil, store.tick_ts)

                ::label_378_0::

                if math.random() >= a.multiple_attacks_chance then
                    break
                end
            end
        end

        coroutine.yield()
    end
end

scripts.mod_block_tower_ainyl = {}

function scripts.mod_block_tower_ainyl.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        queue_remove(store, this)

        return
    end

    SU.tower_block_inc(target)

    this.pos.x, this.pos.y = target.pos.x, target.pos.y
    m.ts = store.tick_ts
    this.tween.ts = store.tick_ts

    if target.tower.size == TOWER_SIZE_LARGE then
        this.render.sprites[4].hidden = nil
        this.render.sprites[5].hidden = nil
    end

    U.y_wait(store, m.duration - 0.2)

    local fx = E:create_entity("fx_block_tower_ainyl_end")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)
    SU.tower_block_dec(target)
    queue_remove(store, this)
end

scripts.plant_magic_blossom = {}

function scripts.plant_magic_blossom.update(this, store)
    local ca = this.custom_attack
    local fx_loading = E:create_entity("fx_plant_magic_blossom_loading")
    local fx_idle1 = E:create_entity("fx_plant_magic_blossom_idle1")
    local fx_idle2 = E:create_entity("fx_plant_magic_blossom_idle2")

    fx_loading.pos.x, fx_loading.pos.y = this.pos.x, this.pos.y
    fx_idle1.pos.x, fx_idle1.pos.y = this.pos.x, this.pos.y
    fx_idle2.pos.x, fx_idle2.pos.y = this.pos.x, this.pos.y

    queue_insert(store, fx_loading)
    queue_insert(store, fx_idle1)
    queue_insert(store, fx_idle2)

    ::label_387_0::

    fx_loading.render.sprites[1].hidden = true
    fx_idle1.render.sprites[1].hidden = true
    fx_idle2.render.sprites[1].hidden = true

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    while (this.plant.blocked or store.wave_group_number < 1) and not this.force_ready do
        coroutine.yield()
    end

    ::label_387_1::

    fx_loading.render.sprites[1].hidden = false
    fx_idle1.render.sprites[1].hidden = true
    fx_idle2.render.sprites[1].hidden = true

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    ca.ts = store.tick_ts

    while store.tick_ts - ca.ts < ca.cooldown and not this.force_ready do
        if this.plant.blocked then
            goto label_387_0
        end

        coroutine.yield()
    end

    fx_loading.render.sprites[1].hidden = true

    U.y_animation_play(this, "ready", nil, store.tick_ts)

    fx_idle1.render.sprites[1].hidden = false
    fx_idle2.render.sprites[1].hidden = false

    signal.emit("wave-notification", "icon", "PLANT_MAGIC_BLOSSOM")

    this.force_ready = nil

    U.animation_start(this, "idle", nil, store.tick_ts, true)

    this.ui.clicked = nil

    while true do
        if this.plant.blocked then
            goto label_387_0
        end

        if this.ui.clicked then
            this.ui.clicked = nil

            -- AC:inc_check("GARDEN_SONG")
            S:queue(ca.sound)
            U.animation_start(this, "shoot", nil, store.tick_ts, false)
            U.y_wait(store, ca.shoot_time)

            local first, targets = U.find_foremost_enemy(store.enemies, this.pos, 0, ca.range, true, ca.vis_flags,
                ca.vis_bans)

            for i = 1, ca.bullet_count do
                local b = E:create_entity(ca.bullet)

                b.bullet.shot_index = i
                b.bullet.source_id = this.id
                b.pos.x, b.pos.y = this.pos.x + ca.bullet_start_offset.x, this.pos.y + ca.bullet_start_offset.y
                b.bullet.from = V.vclone(b.pos)

                if targets and #targets > 0 then
                    local target

                    if i <= #targets then
                        target = targets[i]
                    else
                        target = first
                    end

                    b.bullet.target_id = target.id
                    b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
                else
                    b.bullet.to = V.v(this.pos.x + ca.bullet_start_offset.x + math.random(-50, 50),
                        this.pos.y + ca.bullet_start_offset.y + math.random(30, 100))
                end

                b.initial_impulse_angle_abs = math.pi / 2 + U.frandom(-math.pi / 2, math.pi / 2)
                b.initial_impulse = U.frandom(0.3, 1) * b.initial_impulse

                queue_insert(store, b)
            end

            U.y_animation_wait(this)

            goto label_387_1
        end

        coroutine.yield()
    end

    queue_remove(store, fx_loading)
    queue_remove(store, fx_idle1)
    queue_remove(store, fx_idle2)
    queue_remove(store, this)
end

scripts.plant_poison_pumpkin = {}

function scripts.plant_poison_pumpkin.update(this, store)
    local smokes1 = {{"left", -74, 21, false, false}, {"left", 75, 20, true, false}, {"down", -4, -18, false, false},
                     {"down", -4, 62, false, true}}
    local smokes2 = {{"fill", 24, 0, false, false}, {"fill", 29, 42, false, false}, {"fill", -34, 43, true, false},
                     {"fill", -34, 0, true, false}}
    local smokes3 = {{"fill", 48, -4, false, false}, {"fill", 45, 52, false, false}, {"fill", -43, -3, true, false},
                     {"fill", -45, 56, true, false}}

    local function add_smokes(t)
        for _, item in pairs(t) do
            local name, x, y, flip_x, flip_y = unpack(item)
            local fx = E:create_entity("fx_plant_poison_pumpkin_smoke_" .. name)

            fx.pos.x, fx.pos.y = this.pos.x + x, this.pos.y + y
            fx.render.sprites[1].flip_x = flip_x
            fx.render.sprites[1].flip_y = flip_y
            fx.render.sprites[1].ts = store.tick_ts

            if name == "fill" and flip_x then
                fx.tween.props[3].keys[2][2].x = -1 * fx.tween.props[3].keys[2][2].x
                fx.tween.props[3].keys[3][2].x = -1 * fx.tween.props[3].keys[3][2].x
            end

            queue_insert(store, fx)
        end
    end

    local ca = this.custom_attack
    local fx_idle_l = E:create_entity("fx_plant_poison_pumpkin_idle")
    local fx_idle_c = E:create_entity("fx_plant_poison_pumpkin_idle")
    local fx_idle_r = E:create_entity("fx_plant_poison_pumpkin_idle")

    fx_idle_l.pos.x, fx_idle_l.pos.y = this.pos.x, this.pos.y
    fx_idle_c.pos.x, fx_idle_c.pos.y = this.pos.x, this.pos.y
    fx_idle_r.pos.x, fx_idle_r.pos.y = this.pos.x, this.pos.y
    fx_idle_l.render.sprites[1].offset = V.v(-30, 30)
    fx_idle_c.render.sprites[1].offset = V.v(-5, 28)
    fx_idle_r.render.sprites[1].offset = V.v(32, 30)
    fx_idle_l.render.sprites[1].flip_x = true
    fx_idle_c.render.sprites[1].flip_x = true

    queue_insert(store, fx_idle_l)
    queue_insert(store, fx_idle_c)
    queue_insert(store, fx_idle_r)

    local fxs_idle = {fx_idle_l, fx_idle_c, fx_idle_r}

    ::label_388_0::

    for _, fx in pairs(fxs_idle) do
        fx.render.sprites[1].hidden = true
    end

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    while (this.plant.blocked or store.wave_group_number < 1) and not this.force_ready do
        coroutine.yield()
    end

    ::label_388_1::

    for _, fx in pairs(fxs_idle) do
        fx.render.sprites[1].hidden = true
    end

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    ca.ts = store.tick_ts

    while store.tick_ts - ca.ts < ca.cooldown and not this.force_ready do
        if this.plant.blocked then
            goto label_388_0
        end

        coroutine.yield()
    end

    signal.emit("wave-notification", "icon", "PLANT_VENOM")
    S:queue("VenomPlantReady")
    U.y_animation_play(this, "ready", nil, store.tick_ts)

    for _, fx in pairs(fxs_idle) do
        fx.render.sprites[1].hidden = nil
    end

    this.force_ready = nil

    U.animation_start(this, "idle", nil, store.tick_ts, true)

    this.ui.clicked = nil

    while true do
        if this.plant.blocked then
            goto label_388_0
        end

        if this.ui.clicked then
            this.ui.clicked = nil

            -- AC:inc_check("GARDEN_SONG")
            S:queue(ca.sound)
            U.animation_start(this, "shoot", nil, store.tick_ts, false)

            for _, fx in pairs(fxs_idle) do
                fx.render.sprites[1].hidden = true
            end

            U.y_wait(store, fts(9))
            add_smokes(smokes1)
            U.y_wait(store, fts(6))
            add_smokes(smokes2)
            U.y_wait(store, fts(2))
            add_smokes(smokes3)

            local first, targets = U.find_foremost_enemy(store.enemies, this.pos, 0, ca.range, false, ca.vis_flags,
                ca.vis_bans)

            if first then
                for _, target in pairs(targets) do
                    for _, mod_name in pairs(ca.mods) do
                        local m = E:create_entity(mod_name)

                        m.modifier.target_id = target.id
                        m.modifier.source_id = this.id

                        queue_insert(store, m)
                    end
                end
            end

            U.y_animation_wait(this)

            goto label_388_1
        end

        coroutine.yield()
    end

    for _, fx in pairs(fxs_idle) do
        queue_remove(store, fx)
    end

    queue_remove(store, this)
end

scripts.crystal_arcane = {}

function scripts.crystal_arcane.update(this, store)
    local a = this.attacks
    local glow = this.render.sprites[2]
    local glow_tween = this.tween.props[1]
    local chances_list = {a.list[1].chance, a.list[2].chance, a.list[3].chance}
    local random_points = {V.v(this.pos.x - 50, this.pos.y - 50), V.v(this.pos.x + 50, this.pos.y + 50),
                           V.v(this.pos.x - 50, this.pos.y + 50), V.v(this.pos.x + 50, this.pos.y - 50)}
    local freeze_points = {}
    local inner_fx_radius = 100
    local outer_fx_radius = 150

    for i = 1, 12 do
        local r = i % 2 == 0 and inner_fx_radius or outer_fx_radius
        local p = {}

        p.pos = U.point_on_ellipse(this.pos, r, 2 * math.pi * i / 12)
        p.terrain = GR:cell_type(p.pos.x, p.pos.y)

        log.debug("crystal_arcane.freeze_points - i:%i pos:%f,%f type:%i", i, p.pos.x, p.pos.y, p.terrain)

        if P:valid_node_nearby(p.pos.x, p.pos.y, 0.9) then
            table.insert(freeze_points, p.pos)
        end
    end

    while store.wave_group_number < 1 and not this.force_ready do
        coroutine.yield()
    end

    ::label_390_0::

    a.ts = store.tick_ts
    glow.hidden = false
    glow_tween.keys = glow_tween.keys_loading
    glow_tween.ts = store.tick_ts
    glow_tween.loop = true

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    while store.tick_ts - a.ts < a.cooldown and not this.force_ready do
        coroutine.yield()
    end

    this.ui.clicked = nil
    glow_tween.keys = glow_tween.keys_ready
    glow_tween.ts = store.tick_ts
    glow_tween.loop = false

    U.y_animation_play(this, "ready", nil, store.tick_ts)
    signal.emit("wave-notification", "icon", "ARCANE_CRYSTAL")

    this.force_ready = nil

    U.animation_start(this, "idle", nil, store.tick_ts, true)

    while true do
        if this.ui.clicked then
            this.ui.clicked = nil

            local idx = U.random_table_idx(chances_list)
            local aa = a.list[idx]

            if idx == 1 then
                glow_tween.keys = glow_tween.keys_lightning
                glow_tween.ts = store.tick_ts
                glow.hidden = false

                S:queue(aa.sound)
                U.animation_start(this, aa.animation, nil, store.tick_ts, true)

                local targets =
                    U.find_enemies_in_range(store.enemies, this.pos, 0, aa.range, aa.vis_flags, aa.vis_bans)

                for i = 1, aa.bullet_count do
                    U.y_wait(store, fts(3))

                    local target

                    if targets then
                        local tidx = math.random(1, #targets)

                        target = table.remove(targets, tidx)
                    end

                    local b = E:create_entity(aa.bullet)

                    b.bullet.from = V.v(this.pos.x + aa.bullet_start_offset.x, this.pos.y + aa.bullet_start_offset.y)
                    b.bullet.to = target and V.vclone(target.pos) or V.vclone(table.random(random_points))
                    b.bullet.target_id = target and target.id
                    b.pos = V.vclone(b.bullet.from)

                    queue_insert(store, b)
                end

                U.y_animation_wait(this)
            elseif idx == 2 then
                glow_tween.keys = glow_tween.keys_freeze
                glow_tween.ts = store.tick_ts
                glow.hidden = false

                U.animation_start(this, aa.animations[1], nil, store.tick_ts, false)
                U.y_wait(store, aa.hit_time)
                S:queue(aa.sound)

                local aura = E:create_entity(aa.aura)

                aura.pos.x, aura.pos.y = this.pos.x, this.pos.y
                aura.aura.ts = store.tick_ts

                queue_insert(store, aura)

                local d_center = E:create_entity(aa.fx_center)

                d_center.pos.x, d_center.pos.y = this.pos.x, this.pos.y
                d_center.render.sprites[1].ts = store.tick_ts
                d_center.duration = aa.duration

                queue_insert(store, d_center)

                for _, p in pairs(freeze_points) do
                    local d = E:create_entity(table.random(aa.fxs))

                    d.pos.x, d.pos.y = p.x, p.y
                    d.render.sprites[1].ts = store.tick_ts
                    d.render.sprites[1].flip_x = math.random() < 0.5
                    d.duration = aa.duration + U.frandom(0, 0.2)

                    queue_insert(store, d)
                end

                U.y_animation_wait(this)
                U.animation_start(this, aa.animations[2], nil, store.tick_ts, true)
                U.y_wait(store, aa.duration - 0.3)
                U.y_animation_play(this, aa.animations[3], nil, store.tick_ts)
            else
                glow_tween.keys = glow_tween.keys_buff
                glow_tween.ts = store.tick_ts
                glow.hidden = false

                S:queue(aa.sound)
                U.animation_start(this, aa.animation, nil, store.tick_ts, false)
                U.y_wait(store, aa.hit_time)

                local towers = table.filter(store.towers, function(_, e)
                    return e.tower and not e.tower.blocked and
                               not table.contains(aa.excluded_templates, e.template_name) and
                               U.is_inside_ellipse(e.pos, this.pos, aa.range)
                end)

                for _, e in pairs(towers) do
                    local fx = E:create_entity(aa.fx_base)

                    fx.pos.x, fx.pos.y = e.pos.x, e.pos.y
                    fx.tween.ts = store.tick_ts

                    queue_insert(store, fx)

                    if e.tower.can_be_mod then
                        local mod = E:create_entity(aa.mod)

                        mod.modifier.target_id = e.id
                        mod.modifier.source_id = this.id
                        mod.pos.x, mod.pos.y = e.pos.x, e.pos.y

                        queue_insert(store, mod)

                        if e.barrack then
                            for _, soldier in pairs(e.barrack.soldiers) do
                                if soldier and not soldier.health.dead then
                                    local m = E:create_entity(aa.mod_soldier)

                                    m.pos.x, m.pos.y = soldier.pos.x, soldier.pos.y
                                    m.modifier.target_id = soldier.id

                                    queue_insert(store, m)
                                end
                            end
                        end
                    end
                end

                U.y_animation_wait(this)
            end

            goto label_390_0
        end

        coroutine.yield()
    end
end

scripts.crystal_unstable = {}

function scripts.crystal_unstable.update(this, store)
    local a = this.attacks
    local idle_ts = 0
    local chances_list = {a.list[1].chance, a.list[2].chance, a.list[3].chance}

    local function add_fxs()
        for _, n in pairs({"fx_crystal_unstable_ring", "fx_crystal_unstable_glow"}) do
            local fx = E:create_entity(n)

            fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)
        end
    end

    local function y_play_idle()
        U.y_animation_play(this, math.random() < 0.5 and "loading" or "loading2", nil, store.tick_ts)
    end

    while store.wave_group_number < 1 and not this.force_ready do
        y_play_idle()
    end

    ::label_392_0::

    a.ts = store.tick_ts

    while store.tick_ts - a.ts < a.cooldown and not this.force_ready do
        y_play_idle()
    end

    S:queue("ElvesUnstableCrystalReady")
    U.y_animation_play(this, "ready", nil, store.tick_ts)

    this.force_ready = nil

    while true do
        if idle_ts < store.tick_ts then
            U.animation_start(this, math.random() < 0.5 and "idle" or "idle2", nil, store.tick_ts, false, nil, true)

            idle_ts = store.tick_ts + fts(25) + U.frandom(5, 10)
        end

        local idx = U.random_table_idx(chances_list)
        local aa = a.list[idx]
        local casted = false

        if idx == 1 then
            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, aa.range, aa.vis_flags, aa.vis_bans)

            if not targets or #targets < aa.min_count then
                goto label_392_1
            end

            casted = true

            U.animation_start(this, aa.animation, nil, store.tick_ts)
            U.y_wait(store, aa.cast_time)

            local nodes_offset = (math.random() < aa.good_chance and -1 or 1) * math.random(aa.min_nodes, aa.max_nodes)

            for i = 1, math.min(#targets, aa.max_count) do
                if U.flags_pass(targets[i].vis, aa) then
                    local m = E:create_entity(aa.mod)

                    m.nodes_offset = nodes_offset
                    m.modifier.target_id = targets[i].id
                    m.modifier.source_id = this.id

                    queue_insert(store, m)
                end
            end
        elseif idx == 2 then
            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, aa.range, aa.vis_flags, aa.vis_bans,
                function(e)
                    return table.contains(aa.allowed_templates, e.template_name)
                end)

            if not targets or #targets < aa.min_count then
                goto label_392_1
            end

            casted = true

            U.animation_start(this, aa.animation, nil, store.tick_ts)
            U.y_wait(store, aa.cast_time)

            local do_kill = math.random() < aa.good_chance

            for i = 1, math.min(#targets, aa.max_count) do
                if U.flags_pass(targets[i].vis, aa) then
                    local m = E:create_entity(aa.mod)

                    m.modifier.target_id = targets[i].id
                    m.modifier.source_id = this.id
                    m.modifier.kill = do_kill

                    queue_insert(store, m)
                end
            end
        else
            local targets = U.find_targets_in_range(store.entities, this.pos, 0, aa.range, aa.vis_flags, aa.vis_bans,
                function(e)
                    return e.health and e.health.hp / e.health.hp_max < aa.trigger_hp_factor
                end)

            if not targets or #targets < aa.min_count then
                goto label_392_1
            end

            local best_count = -1
            local best_target

            for _, target in pairs(targets) do
                local nearby = U.find_targets_in_range(targets, target.pos, 0, aa.aura_range, aa.vis_flags, aa.vis_bans,
                    function(e)
                        return e.health and e.health.hp / e.health.hp_max < aa.trigger_hp_factor
                    end)

                if nearby and best_count < #nearby then
                    best_target = target
                    best_count = #nearby
                end
            end

            if not best_target or best_count < aa.min_count then
                log.debug("(%s) crystal_unstable: skipping heal / best pack min count ", this.id)

                goto label_392_1
            end

            casted = true

            local pred_pos = V.vclone(best_target.pos)

            if best_target.nav_path then
                local n_off = P:predict_enemy_node_advance(best_target, aa.cast_time)

                pred_pos =
                    P:node_pos(best_target.nav_path.pi, best_target.nav_path.spi, best_target.nav_path.ni + n_off)
            end

            S:queue(aa.sound)
            U.animation_start(this, aa.animation, nil, store.tick_ts)
            U.y_wait(store, aa.cast_time)

            local bc
            local nearby =
                U.find_targets_in_range(store.entities, pred_pos, 0, aa.aura_range, aa.vis_flags, aa.vis_bans)

            if nearby and #nearby > 0 then
                for i = 1, math.min(#nearby, aa.max_count) do
                    local target = nearby[i]
                    local m = E:create_entity(aa.mod)

                    m.modifier.target_id = target.id
                    m.modifier.source_id = this.id

                    queue_insert(store, m)

                    if not bc then
                        bc = V.vclone(target.pos)
                    else
                        bc.x, bc.y = V.add(bc.x, bc.y, target.pos.x, target.pos.y)
                    end
                end

                local fx = E:create_entity("fx_crystal_unstable_heal")

                fx.pos.x, fx.pos.y = V.mul(1 / #nearby, bc.x, bc.y)
                fx.tween.ts = store.tick_ts

                U.animation_start(fx, nil, nil, store.tick_ts)
                queue_insert(store, fx)
            end
        end

        if casted then
            add_fxs()
            U.y_animation_wait(this)

            goto label_392_0
        end

        ::label_392_1::

        U.y_wait(store, fts(5))
    end
end

scripts.paralyzing_tree = {}

function scripts.paralyzing_tree.update(this, store)
    local ca = this.custom_attack

    local function add_fx(count, radius, offset, angle_start, angle)
        for i = 1, count do
            local a = km.deg2rad(angle_start + angle * (i - 1))
            local pos = U.point_on_ellipse(this.pos, radius, a)
            local fx = SU.insert_sprite(store, "fx_paralyzing_tree_" .. math.random(1, 3), pos)

            fx.render.sprites[1].r = U.frandom(0, km.pi)

            queue_insert(store, fx)
        end
    end

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    while (this.plant.blocked or store.wave_group_number < 1) and not this.force_ready do
        coroutine.yield()
    end

    ::label_398_0::

    U.animation_start(this, "loading", nil, store.tick_ts, true)

    ca.ts = store.tick_ts

    while store.tick_ts - ca.ts < ca.cooldown and not this.force_ready do
        coroutine.yield()
    end

    signal.emit("wave-notification", "icon", "PARALYZING_TREE")
    S:queue("ElvesWhiteTreeActivate")
    U.animation_start(this, "ready", nil, store.tick_ts, true)

    this.ui.clicked = nil
    this.force_ready = nil

    while not this.ui.clicked do
        coroutine.yield()
    end

    S:queue("ElvesWhiteTreeTap")
    U.animation_start(this, ca.animation, nil, store.tick_ts)
    add_fx(6, 70, 20, -110, 45)
    U.y_wait(store, fts(2))
    add_fx(13, 111, 30, -125, 30)
    U.y_wait(store, fts(2))
    add_fx(17, 142.5, 30, -170, 30)
    U.y_wait(store, fts(4))

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, ca.range, ca.vis_flags, ca.vis_bans)

    if targets then
        for _, t in pairs(targets) do
            local m = E:create_entity(ca.mod)

            m.modifier.source_id = this.id
            m.modifier.target_id = t.id

            queue_insert(store, m)
        end
    end

    U.y_animation_wait(this)

    goto label_398_0
end

scripts.bolt_elves = {}

function scripts.bolt_elves.insert(this, store)
    return true
end

function scripts.bolt_elves.update(this, store)
    local b = this.bullet
    local fm = this.force_motion
    local target = store.entities[b.target_id]
    local ps

    local function move_step(dest)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
        local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

        if dist <= 4 * fm.max_v * store.tick_length then
            stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
        end

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
        fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
        fm.a.x, fm.a.y = 0, 0

        return dist <= fm.max_v * store.tick_length
    end

    if b.particles_name then
        ps = E:create_entity(b.particles_name)
        ps.particle_system.emit = true
        ps.particle_system.track_id = this.id

        queue_insert(store, ps)
    end

    local pred_pos

    if target then
        pred_pos = P:predict_enemy_pos(target, fts(5))
    else
        pred_pos = b.to
    end

    local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
    local last_pos = V.vclone(this.pos)

    b.ts = store.tick_ts

    while true do
        target = store.entities[b.target_id]

        if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
            local d = math.max(math.abs(target.pos.x + target.unit.hit_offset.x - b.to.x),
                math.abs(target.pos.y + target.unit.hit_offset.y - b.to.y))

            if d > b.max_track_distance then
                log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id,
                    this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

                target = nil
                b.target_id = nil
            else
                b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
            end
        end

        if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
            local t = store.tick_ts - b.ts

            if this.initial_impulse_angle_abs then
                fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
            else
                fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(
                    this.initial_impulse_angle * (b.shot_index % 2 == 0 and 1 or -1), iix, iiy))
            end
        end

        last_pos.x, last_pos.y = this.pos.x, this.pos.y

        if move_step(b.to) then
            break
        end

        if b.align_with_trajectory then
            this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
        end

        coroutine.yield()
    end

    if target and not target.health.dead then
        local d = SU.create_bullet_damage(b, target.id, this.id)
        local u = UP:get_upgrade("mage_el_empowerment")

        if u and not this.upgrades_disabled and math.random() < u.chance then
            d.value = km.round(d.value * u.damage_factor)

            if b.pop_mage_el_empowerment then
                d.pop = b.pop_mage_el_empowerment
                d.pop_conds = DR_DAMAGE
            end
        end

        queue_damage(store, d)

        if this.alter_reality_chance and UP:has_upgrade("mage_el_alter_reality") and math.random() <
            this.alter_reality_chance then
            local mod = E:create_entity(this.alter_reality_mod)

            mod.modifier.target_id = target.id

            queue_insert(store, mod)
        end
        if this.bullet.mods then
            for _, mod_name in pairs(this.bullet.mods) do
                local m = E:create_entity(mod_name)

                m.modifier.target_id = target.id
                m.modifier.source_id = this.id

                queue_insert(store, m)
            end
        elseif this.bullet.mod then
            local m = E:create_entity(this.bullet.mod)

            m.modifier.target_id = target.id
            m.modifier.source_id = this.id

            queue_insert(store, m)
        end
    elseif b.damage_radius and b.damage_radius > 0 then
        local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

        if targets then
            for _, target in pairs(targets) do
                local d = SU.create_bullet_damage(b, target.id, this.id)

                queue_damage(store, d)
            end
        end
    end

    this.render.sprites[1].hidden = true
    this.render.sprites[2].hidden = true

    if b.hit_fx then
        local fx = E:create_entity(b.hit_fx)

        fx.pos.x, fx.pos.y = b.to.x, b.to.y
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].runs = 0

        queue_insert(store, fx)
    end

    if b.hit_decal then
        local decal = E:create_entity(b.hit_decal)

        decal.pos = V.vclone(b.to)
        decal.render.sprites[1].ts = store.tick_ts

        queue_insert(store, decal)
    end

    if ps and ps.particle_system.emit then
        ps.particle_system.emit = false

        U.y_wait(store, ps.particle_system.particle_lifetime[2])
    end

    queue_remove(store, this)
end

scripts.rock_druid = {}

function scripts.rock_druid.update(this, store)
    local b = this.bullet

    this.render.sprites[1].z = Z_OBJECTS

    S:queue(this.sound_events.load, {
        delay = fts(4)
    })
    U.y_animation_play(this, "load", nil, store.tick_ts)
    U.y_animation_play(this, "travel", nil, store.tick_ts)

    this.tween.disabled = false

    while not b.target_id do
        coroutine.yield()
    end

    local fx = E:create_entity("fx_rock_druid_launch")

    fx.pos.x, fx.pos.y = b.from.x, b.from.y
    fx.render.sprites[1].ts = store.tick_ts
    fx.render.sprites[1].flip_x = b.to.x < fx.pos.x

    queue_insert(store, fx)

    this.render.sprites[1].sort_y_offset = nil
    this.render.sprites[1].z = Z_BULLETS
    this.tween.disabled = true
    b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)
    b.ts = store.tick_ts
    b.last_pos = V.vclone(b.from)
    b.rotation_speed = b.rotation_speed * (b.to.x > b.from.x and -1 or 1)

    scripts.bomb.update(this, store)
end

scripts.dagger_drow = {}

function scripts.dagger_drow.insert(this, store)
    this.bullet.flight_time = U.frandom(this.flight_time_range[1], this.flight_time_range[2])

    return scripts.arrow.insert(this, store)
end

scripts.bullet_liquid_fire_faustus = {}

function scripts.bullet_liquid_fire_faustus.update(this, store)
    local b = this.bullet
    local tl = store.tick_length
    local insert_ts = store.tick_ts
    local node
    local target = store.entities[b.target_id]
    local mspeed = V.dist(b.to.x, b.to.y, b.from.x, b.from.y) / b.flight_time

    if not target then
        queue_remove(store, this)

        return
    end

    local nodes = P:nearest_nodes(b.to.x, b.to.y, {target.nav_path.pi}, {target.nav_path.spi}, true)

    if #nodes > 0 then
        node = {
            pi = nodes[1][1],
            spi = nodes[1][2],
            ni = nodes[1][3]
        }
    end

    if not node then
        log.debug("cannot deploy bullet_liquid_fire_faustus: no destination node")
        queue_remove(store, this)

        return
    end

    local node_pos = P:node_pos(node)
    local dist = V.dist(node_pos.x, node_pos.y, b.from.x, b.from.y)
    local ps = E:create_entity(b.particles_name)

    ps.pos.x, ps.pos.y = b.from.x, b.from.y
    ps.particle_system.emit_direction = V.angleTo(node_pos.x - b.from.x, node_pos.y - b.from.y)
    ps.particle_system.emit_rotation = ps.particle_system.emit_direction
    ps.particle_system.emit_speed = {dist / fts(10), dist / fts(10)}

    queue_insert(store, ps)

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * tl do
        b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * tl, this.pos.y + b.speed.y * tl

        coroutine.yield()
    end

    local fx = E:create_entity("fx_bullet_liquid_fire_faustus_hit")

    fx.pos.x, fx.pos.y = node_pos.x, node_pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)
    local nn, a
    for i = 1, this.flames_count do
        nn = {
            pi = node.pi,
            spi = km.zmod(node.spi + 2 * (i - 1), 3),
            ni = node.ni + (i - 1) * 2
        }

        if not P:is_node_valid(nn.pi, nn.ni) then
            goto flame_mid
        end

        a = E:create_entity("aura_liquid_fire_flame_faustus")

        a.pos = P:node_pos(nn)
        a.pos.x = a.pos.x + math.random(-8, 8)
        a.aura.ts = store.tick_ts

        queue_insert(store, a)

        ::flame_mid::

        if i == 1 then
            goto flame_end
        end

        nn = {
            pi = node.pi,
            spi = km.zmod(node.spi + 2 * (i - 1), 3),
            ni = node.ni - (i - 1) * 2
        }

        if not P:is_node_valid(nn.pi, nn.ni) then
            break
        end

        a = E:create_entity("aura_liquid_fire_flame_faustus")

        a.pos = P:node_pos(nn)
        a.pos.x = a.pos.x + math.random(-8, 8)
        a.aura.ts = store.tick_ts

        queue_insert(store, a)

        ::flame_end::

        U.y_wait(store, 0.25)
    end

    queue_remove(store, this)
end

scripts.meteor_lilith = {}

function scripts.meteor_lilith.update(this, store)
    local b = this.bullet
    local speed = b.max_speed

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) >= 2 * (speed * store.tick_length) do
        b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
        this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

        coroutine.yield()
    end

    local targets = U.find_enemies_in_range(store.enemies, b.to, 0, b.damage_radius, b.damage_flags, b.damage_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = E:create_entity("damage")

            d.damage_type = b.damage_type
            d.value = b.damage_max
            d.source_id = this.id
            d.target_id = target.id

            queue_damage(store, d)
        end
    end

    S:queue(this.sound_events.hit)
    SU.insert_sprite(store, b.arrive_fx, b.to)
    SU.insert_sprite(store, b.arrive_decal, b.to)
    queue_remove(store, this)
end

scripts.decal_lilith_soul_eater_ball = {}

function scripts.decal_lilith_soul_eater_ball.update(this, store)
    local sp = this.render.sprites[1]
    local fm = this.force_motion
    local source = store.entities[this.source_id]
    local hero = store.entities[this.target_id]
    local initial_pos, initial_dest
    local initial_h = 0
    local dest_h = hero.unit.hit_offset.y
    local max_dist
    local last_pos = V.v(0, 0)

    local function move_step(dest)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)

        max_dist = math.max(dist, max_dist)

        local phase = km.clamp(0, 1, 1 - dist / max_dist)
        local df = (not fm.ramp_radius or dist > fm.ramp_radius) and 1 or math.max(dist / fm.ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)

        local sx, sy = V.mul(store.tick_length, fm.v.x, fm.v.y)

        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
        fm.a.x, fm.a.y = V.mul(-0.05 / store.tick_length, fm.v.x, fm.v.y)
        sp.offset.y = SU.parabola_y(phase, initial_h, dest_h, fm.max_flight_height)
        sp.r = V.angleTo(this.pos.x - last_pos.x, this.pos.y + sp.offset.y - last_pos.y)
        last_pos.x, last_pos.y = this.pos.x, this.pos.y + sp.offset.y

        return dist < 2 * fm.max_v * store.tick_length
    end

    if not source or not hero then
        log.debug("source or hero entity not found for decal_lilith_soul_eater_ball")
    else
        this.pos.x, this.pos.y = source.pos.x, source.pos.y

        if source.unit and source.unit.hit_offset then
            initial_h = source.unit.hit_offset.y
        end

        this.dest = hero.pos
        initial_pos = V.vclone(this.pos)
        initial_dest = V.vclone(hero.pos)
        initial_h = initial_h + 18
        fm.a.x, fm.a.y = 0, 3.5
        last_pos.x, last_pos.y = this.pos.x, this.pos.y + sp.offset.y
        max_dist = V.len(initial_dest.x - initial_pos.x, initial_dest.y - initial_pos.y)

        while not hero.health.dead and not move_step(this.dest) do
            coroutine.yield()
        end

        if not hero.health.dead then
            local ma = hero.melee.attacks[1]
            local hero_damage_avg = (ma.damage_min + ma.damage_max) / 2
            local m = E:create_entity(this.hit_mod)

            m.pos = hero.pos
            m.modifier.source_id = this.id
            m.modifier.target_id = hero.id
            m.inflicted_damage_factor = 1 + this.stolen_damage * m.soul_eater_factor / hero_damage_avg
            m.tween.ts = store.tick_ts

            queue_insert(store, m)

            local fx = E:create_entity(this.hit_fx)

            fx.pos = hero.pos
            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].offset = hero.unit.mod_offset

            queue_insert(store, fx)
            SU.hero_gain_xp_from_skill(hero, hero.hero.skills.soul_eater)
        end
    end

    queue_remove(store, this)
end

scripts.missile_phoenix = {}

function scripts.missile_phoenix.insert(this, store, script)
    local b = this.bullet
    local flip = this.pos.x > b.to.x and -1 or 1
    local shot_index = b.shot_index or 0

    b.max_speed = U.frandom(b.max_speed - b.speed_var, b.max_speed + b.speed_var)
    b.min_speed = U.frandom(b.min_speed - b.speed_var, b.min_speed + b.speed_var)

    if shot_index > 0 then
        b.to = V.v(this.pos.x + 30 * flip + shot_index * 5, this.pos.y - 70 + shot_index * 5)
    end

    if shot_index > 1 then
        local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, b.first_retarget_range, b.vis_flags,
            b.vis_bans)

        if targets then
            local target = table.random(targets)

            b.target_id = target.id
        end
    end

    return scripts.missile.insert(this, store, script)
end



scripts.bullet_gnoll_blighter = {}

function scripts.bullet_gnoll_blighter.update(this, store)
    local b = this.bullet
    local mspeed = b.min_speed
    local target, an, af

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
        if b.target_id then
            target = store.entities[b.target_id]
        end

        if target then
            if U.flag_has(target.vis.bans, F_RANGED) or target.health.dead then
                b.target_id = nil
                target = nil
            else
                b.to.x, b.to.y = target.pos.x, target.pos.y
            end
        end

        mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
        mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
        b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
        an, af = U.animation_name_facing_point(this, "travel", b.to)

        U.animation_start(this, an, af, store.tick_ts, true)
        coroutine.yield()
    end

    if target and not target.health.dead then
        local d = SU.create_bullet_damage(b, target.id, this.id)

        queue_damage(store, d)
    end

    an, af = U.animation_name_facing_point(this, "hitUpDown", b.to)
    this.pos.x, this.pos.y = b.to.x, b.to.y - 1

    U.y_animation_play(this, an, af, store.tick_ts)
    queue_remove(store, this)
end

scripts.arrow_twilight_elf_harasser = {}

function scripts.arrow_twilight_elf_harasser.insert(this, store)
    this.bullet.flight_time = U.frandom(this.flight_time_range[1], this.flight_time_range[2])

    return scripts.arrow.insert(this, store)
end

scripts.bullet_arachnomancer_spawn = {}

function scripts.bullet_arachnomancer_spawn.insert(this, store)
    local b = this.bullet

    b.to = P:node_pos(this.nav_path)
    b.from = V.vclone(this.pos)

    local e = E:create_entity(this.payload_entity)

    e.render.sprites[1].name = "raise"
    e.nav_path = table.deepclone(this.nav_path)
    e.pos = V.vclone(b.to)
    e.enemy.gold = 0
    b.hit_payload = e

    if scripts.bomb.insert(this, store) then
        this.render.sprites[1].flip_x = b.to.x < b.from.x
        this.render.sprites[1].r = 0

        return true
    end

    return false
end

scripts.rock_perython = {}

function scripts.rock_perython.update(this, store)
    local b = this.bullet

    U.y_animation_play(this, "drop", nil, store.tick_ts)

    local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = target.id
            d.value = math.random(b.damage_min, b.damage_max)
            d.damage_type = b.damage_type

            queue_damage(store, d)
        end
    end

    S:queue(this.sound_events.hit)

    if b.hit_fx then
        local fx = E:create_entity(b.hit_fx)

        fx.pos = V.vclone(this.pos)
        fx.render.sprites[1].ts = store.tick_ts

        queue_insert(store, fx)
    end

    if b.hit_decal then
        local decal = E:create_entity(b.hit_decal)

        decal.pos = V.vclone(this.pos)
        decal.render.sprites[1].ts = store.tick_ts

        queue_insert(store, decal)
    end

    queue_remove(store, this)
end

scripts.aura_arcane_burst = {}

function scripts.aura_arcane_burst.update(this, store)
    local a = this.aura

    local target = this.target_id and store.entities[this.target_id]
    local hit_pos = V.vclone(this.pos)

    if target then
        hit_pos.x, hit_pos.y = target.pos.x, target.pos.y
    end

    local targets = U.find_enemies_in_range(store.enemies, hit_pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = E:create_entity("damage")

            d.damage_type = a.damage_type
            d.value = a.level * a.damage_inc * a.damage_factor
            d.target_id = target.id
            d.source_id = this.id

            queue_damage(store, d)

            if math.random() < this.sleep_chance and band(target.vis.bans, F_STUN) == 0 then
                local m = E:create_entity("mod_arrow_arcane_slumber")
                m.modifier.target_id = target.id
                m.modifier.source_id = this.id
                queue_insert(store, m)
            end
        end
    end

    if target and not target.health.dead and band(target.vis.flags, F_FLYING) == 0 then
        local decal = E:create_entity("decal_arcane_burst_ground")

        decal.pos.x, decal.pos.y = target.pos.x, target.pos.y
        decal.tween.ts = store.tick_ts

        queue_insert(store, decal)
    end

    U.y_animation_play(this, nil, nil, store.tick_ts, 1)
    queue_remove(store, this)
end

scripts.aura_forest_eerie = {}

function scripts.aura_forest_eerie.insert(this, store)
    local function insert_root(pos, duration)
        local fx = E:create_entity("decal_eerie_root_" .. math.random(1, 2))

        fx.render.sprites[1].flip_x = math.random() < 0.5
        fx.delay = U.frandom(0, 0.3)
        fx.pos = pos
        fx.duration = duration

        queue_insert(store, fx)
    end

    this.aura.ts = store.tick_ts
    this.actual_duration = this.aura.duration + this.aura.level * this.aura.duration_inc

    local roots_count = this.roots_count + this.aura.level * this.roots_count_inc
    local root_rows = math.floor(roots_count / 3)
    local ni_inc = 2
    local pi = this.pos_pi
    local ni = this.pos_ni + math.floor((ni_inc + 2.5) * root_rows / 2)

    for i = 1, roots_count do
        local spi = km.zmod(i, 3)

        if P:is_node_valid(pi, ni) then
            local pos = P:node_pos(pi, spi, ni)

            pos.x, pos.y = pos.x + math.random(0, 8), pos.y + math.random(0, 8)

            insert_root(pos, this.actual_duration)
        end

        if i % 3 == 0 then
            ni = ni - ni_inc - math.random(2, 3)
        end
    end

    return true
end

scripts.aura_lilith_soul_eater = {}

function scripts.aura_lilith_soul_eater.update(this, store)
    local a = this.aura
    local hero = store.entities[a.source_id]
    local last_ts = store.tick_ts

    if not hero then
        log.error("hero not found for aura_lilith_soul_eater")
        queue_remove(store, this)

        return
    end

    while true do
        hero.soul_eater.active = store.tick_ts - hero.soul_eater.last_ts >= a.cooldown

        if not hero.health.dead and hero.soul_eater.active and store.tick_ts - last_ts >= a.cycle_time then
            last_ts = store.tick_ts

            local targets = U.find_enemies_in_range(store.enemies, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans,
                function(e)
                    return not table.contains(a.excluded_templates, e.template_name)
                end)

            if targets then
                for _, target in pairs(targets) do
                    local m = E:create_entity(a.mod)

                    m.modifier.source_id = hero.id
                    m.modifier.target_id = target.id

                    queue_insert(store, m)
                end
            end
        end

        coroutine.yield()
    end
end

scripts.aura_bruce_hps = {}

function scripts.aura_bruce_hps.update(this, store)
    local owner = store.entities[this.aura.source_id]
    local hps = this.hps

    while true do
        if store.tick_ts - hps.ts > hps.heal_every then
            hps.ts = store.tick_ts
            owner.health.hp = km.clamp(0, owner.health.hp_max, owner.health.hp + hps.heal_max)
        end

        coroutine.yield()
    end
end

scripts.aura_ray_phoenix = {}

function scripts.aura_ray_phoenix.insert(this, store)
    local bullet = store.entities[this.aura.source_id]

    this.aura.xp_dest_id = bullet and bullet.bullet.source_id or nil

    return true
end

scripts.aura_phoenix_egg = {}

function scripts.aura_phoenix_egg.update(this, store)
    local ca = this.custom_attack
    local a = this.aura

    a.ts = store.tick_ts

    local last_hit_ts = store.tick_ts

    U.y_wait(store, this.show_delay)
    U.sprites_show(this)
    U.y_animation_play(this, "spawn", nil, store.tick_ts, 1)
    U.animation_start(this, "idle", nil, store.tick_ts, true)

    while true do
        if store.tick_ts - a.ts > a.duration then
            break
        end

        if store.tick_ts - last_hit_ts >= a.cycle_time then
            last_hit_ts = store.tick_ts

            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

            if targets then
                for _, t in pairs(targets) do
                    local m = E:create_entity(a.mod)

                    m.modifier.target_id = t.id
                    m.modifier.source_id = this.id

                    queue_insert(store, m)
                end
            end
        end

        coroutine.yield()
    end

    SU.insert_sprite(store, ca.hit_fx, this.pos)

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, ca.radius, ca.vis_flags, ca.vis_bans)

    if targets then
        for _, t in pairs(targets) do
            local d = E:create_entity("damage")

            d.value = math.random(ca.damage_min, ca.damage_max)
            d.damage_type = ca.damage_type
            d.target_id = t.id
            d.source_id = this.id

            queue_damage(store, d)
        end
    end

    queue_remove(store, this)
end

scripts.aura_gnoll_gnawer = {}

function scripts.aura_gnoll_gnawer.update(this, store)
    local a = this.aura
    local last_hit_ts = 0
    local te = store.entities[a.source_id]

    if not te then
        -- block empty
    else
        this.pos = te.pos

        while true do
            te = store.entities[a.source_id]

            if not te or te.health and te.health.dead and not a.track_dead then
                break
            end

            if store.tick_ts - last_hit_ts >= a.cycle_time then
                last_hit_ts = store.tick_ts

                local friends = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

                if friends and #friends >= this.min_count then
                    local m = E:create_entity(this.aura.mod)

                    m.modifier.target_id = te.id
                    m.modifier.source_id = this.id

                    queue_insert(store, m)
                end
            end

            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.aura_bandersnatch_spines = {}

function scripts.aura_bandersnatch_spines.update(this, store)
    local a = this.aura

    for i = 1, this.spines_count do
        local r = math.random(45, 55) + (math.random() < 0.75 and math.random(-6, 15) or 0)
        local angle = U.frandom(0, 2) * math.pi
        local fx = E:create_entity("fx_bandersnatch_spine")

        fx.pos = U.point_on_ellipse(this.pos, r, angle)
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].flip_x = math.random() < 0.5

        queue_insert(store, fx)
    end

    local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = E:create_entity("damage")

            d.damage_type = a.damage_type
            d.value = math.ceil(U.frandom(a.damage_min, a.damage_max))
            d.target_id = target.id
            d.source_id = this.id

            queue_damage(store, d)

            local fx = E:create_entity(a.hit_fx)

            fx.pos.x, fx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)
        end
    end
end

scripts.aura_razorboar_rage = {}

function scripts.aura_razorboar_rage.insert(this, store)
    local source = store.entities[this.aura.source_id]

    if not source then
        return false
    end

    local ma = source.melee.attacks[1]

    this._ini_damage_max = ma.damage_max
    this._ini_damage_min = ma.damage_min

    return true
end

function scripts.aura_razorboar_rage.remove(this, store)
    local source = store.entities[this.aura.source_id]

    if source then
        local ma = source.melee.attacks[1]

        ma.damage_max = this._ini_damage_max
        ma.damage_min = this._ini_damage_min
    end

    return true
end

function scripts.aura_razorboar_rage.update(this, store)
    local a = this.aura
    local te = store.entities[a.source_id]

    if not te then
        queue_remove(store, this)
    end

    local ma = te.melee.attacks[1]
    local ini_damage_max = ma.damage_max
    local ini_damage_min = ma.damage_min

    this.pos = te.pos

    while true do
        te = store.entities[a.source_id]

        if not te or te.health and te.health.dead and not a.track_dead then
            break
        end

        local h = te.health
        local hp_lost_factor = (h.hp_max - h.hp) / h.hp_max * this.damage_hp_factor

        ma.damage_min = math.floor(ini_damage_min * (1 + hp_lost_factor))
        ma.damage_max = math.floor(ini_damage_max * (1 + hp_lost_factor))

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.editor_aura_spider_sprint = {}

function scripts.editor_aura_spider_sprint.update(this, store)
    while true do
        this.render.sprites[1].scale = V.vv(this.aura.radius / 50)

        coroutine.yield()
    end
end

scripts.aura_mactans_path_web = {}

function scripts.aura_mactans_path_web.update(this, store)
    local a = this.aura

    a.ts = store.tick_ts

    local remaining_time = this.aura.duration
    local used_eggs = {}

    local function insert_webs(off_idx)
        local npos = {P:node_pos(this.pi, 1, this.ni + off_idx * this.step_nodes),
                      P:node_pos(this.pi, 2, this.ni + off_idx * this.step_nodes),
                      P:node_pos(this.pi, 3, this.ni + off_idx * this.step_nodes)}
        local rot = -V.angleTo(npos[2].x - npos[1].x, npos[2].y - npos[1].y)

        for spi = 1, 3 do
            local pos = npos[spi]

            if spi == 1 and off_idx <= this.steps_count_auras then
                local e = E:create_entity("aura_spider_sprint")

                e.aura.duration = remaining_time
                e.aura.radius = a.radius
                e.pos.x, e.pos.y = pos.x, pos.y

                queue_insert(store, e)

                local targets = U.find_soldiers_in_range(store.soldiers, pos, 0, a.radius, a.vis_flags, a.vis_bans)

                if targets then
                    for _, target in pairs(targets) do
                        local m = E:create_entity("mod_mactans_spider_web")

                        m.pos.x, m.pos.y = target.pos.x, target.pos.y
                        m.modifier.source_id = this.id
                        m.modifier.target_id = target.id

                        queue_insert(store, m)
                    end
                end

                local sel_eggs = table.filter(this.eggs, function(_, e)
                    return not table.contains(used_eggs, e) and V.dist(e.pos.x, e.pos.y, pos.x, pos.y) < a.radius
                end)

                for _, egg in pairs(sel_eggs) do
                    log.debug("----- EGG:%s", getfulldump(egg))
                    table.insert(used_eggs, egg)

                    local e = E:create_entity("spider_arachnomancer_egg_spawner")

                    e.pos.x, e.pos.y = egg.pos.x, egg.pos.y
                    e.spawn_once = true
                    e.spawner.spawn_data = {}
                    e.spawner.count = this.qty_per_egg
                    e.spawner.pi = egg.node_pi
                    e.spawner.spi = egg.node_spi
                    e.spawner.ni = egg.node_ni

                    queue_insert(store, e)
                end
            end

            local d = E:create_entity("decal_mactans_path_web_" .. math.random(1, 3))

            d.pos.x, d.pos.y = pos.x + math.random(-15, 15), pos.y + math.random(-15, 15)
            d.tween.ts = store.tick_ts + U.frandom(0, this.step_delay * 0.6)
            d.duration = remaining_time
            d.fade_duration = this.fade_duration + U.frandom(fts(5), fts(15))

            local scale_factor = U.frandom(0.8, 1.3)

            d.render.sprites[1].scale = V.v(U.random_sign() * scale_factor, U.random_sign() * scale_factor)

            queue_insert(store, d)
        end
    end

    for i = 0, this.steps_count do
        remaining_time = this.aura.duration - (store.tick_ts - a.ts)

        insert_webs(i)

        if i > 0 then
            insert_webs(-i)
        end

        U.y_wait(store, this.step_delay)

        if this.interrupt then
            break
        end
    end

    U.y_wait(store, remaining_time)
    queue_remove(store, this)
end

scripts.mod_blood_elves = {}

function scripts.mod_blood_elves.insert(this, store)
    if math.random() >= this.chance or not scripts.mod_dps.insert(this, store) then
        return false
    end

    local target = store.entities[this.modifier.target_id]

    if not target then
        log.debug("mod_blood_elves:%s cannot find target with id:%s", this.id, this.modifier.target_id)

        return false
    end

    local _, modifiers = U.has_modifier_types(store, target, this.modifier.type)

    if #modifiers >= this.modifier.max_of_same then
        log.debug("%s: cannot add to id %s because exceeds maximum", this.template_name, this.modifier.target_id)

        return false
    end

    for _, m in pairs(modifiers) do
        if m.dps then
            m.dps.fx = nil
        end
    end

    local source_damage = this.modifier.source_damage

    if not source_damage then
        if DEBUG then
            log.debug("mod_blood_elves: no modifier.source_damage. Using debug value")

            local d = E:create_entity("damage")

            d.value = 50
            d.target_id = target.id
            d.source_id = this.id
            source_damage = d
        else
            log.error("mod_blood_elves: cannot create without modifier.source_damage", this.id)

            return false
        end
    end

    local pred_damage = U.predict_damage(target, source_damage)
    local actual_damage = math.ceil(this.damage_factor * pred_damage)

    this.dps.damage_min = actual_damage
    this.dps.damage_max = actual_damage

    log.debug("mod_blood_elves:%s source_damage:%s actual_damage:%s", this.id, source_damage.value, actual_damage)

    return true
end

scripts.mod_timelapse = {}

function scripts.mod_timelapse.queue(this, store, insertion)
    local target = store.entities[this.modifier.target_id]

    if not target then
        return
    end

    if insertion then
        log.debug("%s (%s) queue/insertion", this.template_name, this.id)

        if U.flags_pass(target.vis, this.modifier) then
            this._target_prev_bans = target.vis.bans
        end
    else
        log.debug("%s (%s) queue/removal", this.template_name, this.id)

        if this._target_prev_bans then
            target.vis.bans = this._target_prev_bans
            target.health.ignore_damage = false
        end

        if this._decal_timelapse then
            queue_remove(store, this._decal_timelapse)

            if target.ui then
                target.ui.can_click = true
            end

            if target.health_bar then
                target.health_bar.hidden = nil
            end

            U.sprites_show(target, nil, nil, true)
            SU.show_modifiers(store, target, true, this)
            SU.show_auras(store, target, true)
        end
    end
end

function scripts.mod_timelapse.dequeue(this, store, insertion)
    return
end

function scripts.mod_timelapse.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if target and target.health and not target.health.dead and this._target_prev_bans ~= nil then
        SU.stun_inc(target)
        scripts.cast_silence(target, store)
        return true
    else
        return false
    end
end

function scripts.mod_timelapse.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if target then
        SU.stun_dec(target)
        scripts.remove_silence(target, store)
    end

    return true
end

function scripts.mod_timelapse.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead then
        queue_remove(store, this)

        return
    end

    m.ts = store.tick_ts
    this.pos.x, this.pos.y = target.pos.x, target.pos.y
    this.render.sprites[1].offset.y = target.unit.hit_offset.y

    local es = E:create_entity("timelapse_enemy_decal")

    this._decal_timelapse = es
    es.pos.x, es.pos.y = target.pos.x, target.pos.y
    es.render = table.deepclone(target.render)

    local tween_keys = es.tween.props[1].keys

    for i, s in ipairs(es.render.sprites) do
        es.tween.props[i] = E:clone_c("tween_prop")
        es.tween.props[i].keys = tween_keys
        es.tween.props[i].sprite_id = i
    end

    queue_insert(store, es)
    U.unblock_all(store, target)

    if target.health_bar then
        target.health_bar.hidden = true
    end

    U.sprites_hide(target, nil, nil, true)
    SU.hide_modifiers(store, target, true, this)
    SU.hide_auras(store, target, true)
    U.animation_start(this, "start", nil, store.tick_ts, false, 1)

    this.tween.ts = store.tick_ts

    U.y_wait(store, fts(10))

    es.tween.ts = store.tick_ts
    es.tween.disabled = false

    U.y_animation_wait(this)
    U.animation_start(this, "loop", nil, store.tick_ts, true, 1)
    U.y_wait(store, m.duration - (store.tick_ts - m.ts) - fts(10), function(store, time)
        return this.interrupt or target.health.dead
    end)
    S:queue("TowerHighMageTimeCastEnd")
    U.animation_start(this, "end", nil, store.tick_ts, false, 1)

    this.tween.ts = store.tick_ts
    this.tween.reverse = true

    U.y_wait(store, fts(5))

    es.tween.reverse = true
    es.tween.ts = store.tick_ts

    U.y_animation_wait(this)
    queue_remove(store, es)

    this._decal_timelapse = nil

    if not target.health.dead then
        if target.health_bar then
            target.health_bar.hidden = nil
        end
        U.sprites_show(target, nil, nil, true)
        SU.show_modifiers(store, target, true, this)
        SU.show_auras(store, target, true)
    end

    queue_remove(store, this)

    if this.interrupt then
        target.health.hp = 0

        if target.death_spawns then
            target.health.last_damage_types = DAMAGE_NO_SPAWNS
        end
    else
        local d = E:create_entity("damage")

        d.damage_type = this.damage_type
        d.value = this.damage_levels[m.level]
        d.source_id = this.id
        d.target_id = target.id

        queue_damage(store, d)
    end

    signal.emit("mod-applied", this, target)
end

scripts.mod_arrow_arcane_slumber = {}

function scripts.mod_arrow_arcane_slumber.insert(this, store)
    if scripts.mod_stun.insert(this, store) then
        local e = E:create_entity("mod_arrow_arcane")

        e.modifier.target_id = this.modifier.target_id

        queue_insert(store, e)

        this.render.sprites[2].flip_x = false

        log.debug("          pATCHING FLIP: %s", this.render.sprites[2].flip_x)

        return true
    end

    return false
end

scripts.mod_arrow_silver_mark = {}

function scripts.mod_arrow_silver_mark.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead or not target.unit then
        return false
    end

    local boss_factor = band(target.vis.flags, F_BOSS) ~= 0 and 0.5 or 1
    this.received_damage_factor = (this.received_damage_factor - 1) * boss_factor + 1

    target.health.damage_factor = target.health.damage_factor * this.received_damage_factor

    signal.emit("mod-applied", this, target)

    return true
end

function scripts.mod_arrow_silver_mark.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.pos then
        queue_remove(store, this)

        return
    end

    this.pos = target.pos
    m.duration = m.durations[m.level]
    m.ts = store.tick_ts

    while true do
        target = store.entities[m.target_id]

        if not target or target.health.dead or store.tick_ts - m.ts > m.duration then
            this.tween.props[3].disabled = nil
            this.tween.props[4].disabled = nil
            this.tween.props[3].ts = store.tick_ts
            this.tween.props[4].ts = store.tick_ts

            U.y_wait(store, this.tween.props[3].keys[2][1])
            queue_remove(store, this)

            return
        end

        coroutine.yield()
    end
end

function scripts.mod_arrow_silver_mark.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if target and target.health and target.unit then
        target.health.damage_factor = target.health.damage_factor / this.received_damage_factor
    end

    return true
end

scripts.mod_eldritch = {}

function scripts.mod_eldritch.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead or not U.flags_pass(target.vis, this.modifier) then
        queue_remove(store, this)

        return
    end

    local es = E:create_entity("eldritch_enemy_decal")

    es.pos.x, es.pos.y = target.pos.x, target.pos.y
    es.render = table.deepclone(target.render)
    es.render.sprites[1].name = "idle"

    queue_insert(store, es)

    local show_blood_pool = target.unit.show_blood_pool
    local d = E:create_entity("damage")

    d.damage_type = DAMAGE_EAT
    d.source_id = this.id
    d.target_id = target.id

    queue_damage(store, d)

    local s = this.render.sprites[1]

    s.ts = store.tick_ts
    this.pos = V.vclone(target.pos)
    s.offset.x = target.unit.mod_offset.x
    s.offset.y = target.unit.mod_offset.y

    S:queue(this.sound_events.loop)

    es.tween.disabled = nil
    es.tween.ts = store.tick_ts

    U.y_wait(store, es.tween.props[1].keys[#es.tween.props[1].keys][1])
    S:stop(this.sound_events.loop)

    local fx = E:create_entity("fx_eldritch_explosion")

    fx.pos.x, fx.pos.y = target.pos.x + target.unit.mod_offset.x, target.pos.y + target.unit.mod_offset.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)

    local terrain_type = band(GR:cell_type(target.pos.x, target.pos.y), TERRAIN_TYPES_MASK)

    if target.unit and target.unit.can_explode and target.unit.explode_fx and band(terrain_type, TERRAIN_WATER) == 0 then
        S:queue(target.sound_events.death_by_explosion)

        local fx = E:create_entity(target.unit.explode_fx)

        fx.pos = V.vclone(target.pos)
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].name = fx.render.sprites[1].size_names[target.unit.size]

        queue_insert(store, fx)
    end

    if target.unit and show_blood_pool and target.unit.blood_color ~= BLOOD_NONE and band(terrain_type, TERRAIN_WATER) ==
        0 then
        local decal = E:create_entity("decal_blood_pool")

        decal.pos = V.vclone(target.pos)
        decal.render.sprites[1].ts = store.tick_ts
        decal.render.sprites[1].name = target.unit.blood_color
        decal.render.sprites[1].z = target.render.sprites[1].z
        decal.render.sprites[1].sort_y_offset = 1

        queue_insert(store, decal)
    end

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, this.damage_radius, this.damage_flags,
        this.damage_bans)

    if targets then
        for _, t in pairs(targets) do
            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = t.id
            d.value = this.damage_levels[m.level]
            d.damage_type = this.damage_type

            queue_damage(store, d)
        end
    end

    signal.emit("mod-applied", this, target)
    queue_remove(store, this)
end

scripts.mod_druid_sylvan = {}

function scripts.mod_druid_sylvan.update(this, store)
    local m = this.modifier
    local a = this.attack
    local s = this.render.sprites[2]
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead then
        queue_remove(store, this)

        return
    end

    if s.size_names then
        s.name = s.size_names[target.unit.size]
    end

    local last_hp = target.health.hp
    local ray_ts = 0

    this.pos = target.pos

    while true do
        target = store.entities[m.target_id]

        if not target or target.health.dead or store.tick_ts - m.ts > m.duration then
            queue_remove(store, this)

            return
        end

        if target and target.unit and target.unit.mod_offset then
            s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
        end

        local dhp = target.health.hp - last_hp

        if dhp < 0 then
            last_hp = target.health.hp

            local targets = U.find_enemies_in_range(store.enemies, target.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

            if targets then
                for _, t in pairs(targets) do
                    if t ~= target then
                        local b = E:create_entity(a.bullet)

                        b.bullet.damage_max = -1 * dhp * a.damage_factor[m.level]
                        b.bullet.damage_min = b.bullet.damage_max
                        b.bullet.target_id = t.id
                        b.bullet.source_id = this.id
                        b.bullet.from = V.v(target.pos.x + target.unit.mod_offset.x,
                            target.pos.y + target.unit.mod_offset.y)
                        b.bullet.to = V.v(t.pos.x + t.unit.hit_offset.x, t.pos.y + t.unit.hit_offset.y)
                        b.pos = V.vclone(b.bullet.from)
                        b.render.sprites[1].hidden = store.tick_ts - ray_ts < this.ray_cooldown

                        queue_insert(store, b)
                    end
                end

                if store.tick_ts - ray_ts > this.ray_cooldown then
                    ray_ts = store.tick_ts
                end
            end
        end

        coroutine.yield()
    end
end

scripts.mod_pixie_pickpocket = {}

function scripts.mod_pixie_pickpocket.insert(this, store)
    local m, pp = this.modifier, this.pickpocket
    local target = store.entities[m.target_id]

    if not target or not target.enemy or target.enemy.gold_bag <= 0 then
        return false
    end

    local q = km.clamp(0, target.enemy.gold_bag, math.random(pp.steal_min[m.level], pp.steal_max[m.level]))

    if q > 0 then
        target.enemy.gold_bag = target.enemy.gold_bag - q
        store.player_gold = store.player_gold + q
    end

    local pop = SU.create_pop(store, target.pos, pp.pop)

    queue_insert(store, pop)

    local fx = E:create_entity(pp.fx)

    fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)
    queue_remove(store, this)

    return true
end

scripts.mod_bravebark_branchball = {}

function scripts.mod_bravebark_branchball.queue(this, store, insertion)
    local target = store.entities[this.modifier.target_id]

    if not target then
        return
    end

    if insertion then
        target.vis.bans = F_ALL

        SU.stun_inc(target)
    end
end

function scripts.mod_bravebark_branchball.update(this, store)
    local target = store.entities[this.modifier.target_id]
    local source = store.entities[this.modifier.source_id]

    if not target or not source then
        queue_remove(store, this)

        return
    end

    local af = source.pos.x > target.pos.x

    this.pos.x, this.pos.y = target.pos.x, target.pos.y

    U.y_wait(store, fts(7))
    S:queue("ElvesHeroForestElementalHomerun")
    U.y_wait(store, fts(10))

    this.render.sprites[1].hidden = false
    this.render.sprites[1].ts = store.tick_ts

    local decal = E:create_entity("decal_bravebark_rootspikes_hit")

    decal.pos.x, decal.pos.y = this.pos.x, this.pos.y
    decal.tween.ts = store.tick_ts

    queue_insert(store, decal)
    U.y_wait(store, fts(16))

    local fx = E:create_entity("fx_bravebark_branchball_hit")

    fx.pos.x, fx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)

    local d = E:create_entity("damage")

    d.damage_type = DAMAGE_EAT
    d.source_id = this.id
    d.target_id = target.id

    queue_damage(store, d)

    local es = E:create_entity("decal_bravebark_branchball_enemy_clone")

    es.pos.x, es.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
    es.render = table.deepclone(target.render)
    es.render.sprites[1].anchor = this.custom_anchors[target.template_name] or this.custom_anchors.default
    es.tween.disabled = nil
    es.tween.ts = store.tick_ts

    local dx, dy = V.rotate(math.random(20, 45) * math.pi / 180, math.random(240, 300), 0)

    dx = (af and -1 or 1) * dx
    es.tween.props[2].keys[2][2].x, es.tween.props[2].keys[2][2].y = dx, dy
    es.tween.props[3].keys[2][2] = (af and -1 or 1) * math.random(300, 400) * math.pi / 180

    queue_insert(store, es)
    U.y_animation_wait(this)
    queue_remove(store, this)
end

scripts.mod_bravebark_springsap = {}

function scripts.mod_bravebark_springsap.insert(this, store)
    if not scripts.mod_hps.insert(this, store) then
        return false
    end

    local target = store.entities[this.modifier.target_id]

    if target.template_name == "hero_bravebark" then
        this.render.sprites[1].hidden = true
    else
        this.render.sprites[1].ts = store.tick_ts
    end

    return true
end

scripts.mod_catha_curse = {}

function scripts.mod_catha_curse.insert(this, store)
    if math.random() < this.chance and scripts.mod_stun.insert(this, store) then
        if this.xp_from_skill then
            local ref = store.entities[this.modifier.source_id]

            if ref and ref.bullet then
                ref = store.entities[ref.bullet.source_id]
            end

            if ref and ref.hero then
                SU.hero_gain_xp_from_skill(ref, ref.hero.skills[this.xp_from_skill])
            else
                log.error("mod_catha_curse: could not find source hero for %s", this.id)
            end
        end

        return true
    else
        return false
    end
end

scripts.mod_rag_raggified = {}

function scripts.mod_rag_raggified.update(this, store)
    local function add_fx(target, pos)
        local fx = E:create_entity(this.fx)
        local s = fx.render.sprites[1]

        s.ts = store.tick_ts

        if s.size_scales then
            s.scale = s.size_scales[target.unit.size]
        end

        fx.pos = V.vclone(pos)

        if target.unit.hit_offset then
            fx.pos.x, fx.pos.y = fx.pos.x + target.unit.hit_offset.x, fx.pos.y + target.unit.hit_offset.y
        end

        queue_insert(store, fx)
    end

    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or target.health.dead or band(target.vis.bans, F_RAGGIFY) ~= 0 then
        queue_remove(store, this)

        return
    end

    target.vis.bans = U.flag_set(target.vis.bans, F_RAGGIFY)

    add_fx(target, target.pos)
    SU.remove_modifiers(store, target, nil, "mod_rag_raggified")
    SU.remove_auras(store, target)
    queue_remove(store, target)

    target.health.dead = true
    target.main_script.co = nil
    target.main_script.runs = 0

    U.unblock_all(store, target)

    if target.ui then
        target.ui.can_click = false
    end

    if target.count_group then
        target.count_group.in_limbo = true
    end

    local e = E:create_entity(this.entity_name)
    e.pos = V.vclone(target.pos)
    if target.melee then
        e.melee.attacks[1].damage_max = target.melee.attacks[1].damage_max
        e.melee.attacks[1].damage_min = target.melee.attacks[1].damage_min
    end
    e.health.hp_max = target.health.hp
    e.health.hp = target.health.hp
    e.nav_rally.center = V.vclone(target.pos)
    e.nav_rally.pos = V.vclone(target.pos)
    e.render.sprites[1].flip_x = target.render.sprites[1].flip_x
    e.render.sprites[1].scale = target.unit.size == UNIT_SIZE_SMALL and V.vv(0.75) or V.vv(1)

    queue_insert(store, e)

    local start_ts = store.tick_ts

    while (not e.health.dead) and (e.health.hp_max - e.health.hp < e.health.hp_max * this.break_factor or store.tick_ts - start_ts < this.doll_duration) do
        coroutine.yield()
    end

    if not e.health.dead then
        local hp = e.health.hp
        e.health.dead = true
        queue_remove(store, e)
        local nodes = P:nearest_nodes(e.pos.x, e.pos.y, {target.nav_path.pi}, nil)

        if #nodes > 0 then
            target.nav_path.ni = nodes[1][3] + 1
        end

        target.pos = V.vclone(e.pos)
        target.main_script.runs = 1
        target.health.dead = false
        target.health.hp = hp

        if target.ui then
            target.ui.can_click = true
        end

        if target.count_group then
            target.count_group.in_limbo = nil
        end

        target.vis.bans = U.flag_clear(target.vis.bans, F_RAGGIFY)

        queue_insert(store, target)
    else
        store.player_gold = store.player_gold + target.enemy.gold

        signal.emit("got-enemy-gold", target, target.enemy.gold)
    end

    add_fx(target, e.pos)
    queue_remove(store, this)
end

scripts.mod_lilith_soul_eater_track = {}

function scripts.mod_lilith_soul_eater_track.update(this, store)
    local hero = store.entities[this.modifier.source_id]

    if not hero then
        log.error("hero not found for mod_lilith_soul_eater")
    else
        this.modifier.ts = store.tick_ts

        while true do
            local target = store.entities[this.modifier.target_id]

            if not target or store.tick_ts - this.modifier.ts > this.modifier.duration then
                break
            end

            if target.health.dead and hero.soul_eater.active and target.melee and target.melee.attacks and
                not U.flag_has(target.health.last_damage_types, DAMAGE_NO_LIFESTEAL) then
                local ma = target.melee.attacks[1]
                local stolen_damage = (ma.damage_min + ma.damage_max) / 2
                local s = E:create_entity("decal_lilith_soul_eater_ball")

                s.target_id = hero.id
                s.source_id = target.id
                s.stolen_damage = stolen_damage

                queue_insert(store, s)

                hero.soul_eater.last_ts = store.tick_ts

                break
            end

            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.mod_bruce_sharp_claws = {}

function scripts.mod_bruce_sharp_claws.insert(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target then
        log.debug("mod_bruce_sharp_claws:%s cannot find target with id:%s", this.id, this.modifier.target_id)

        return false
    end

    local has_mods, mods = U.has_modifier_types(store, target, this.modifier.type)

    if has_mods then
        local d = E:create_entity("damage")

        d.value = this.extra_bleeding_damage
        d.target_id = target.id
        d.source_id = this.id

        queue_damage(store, d)

        return false
    else
        if not scripts.mod_dps.insert(this, store) then
            return false
        end

        local ref = store.entities[this.modifier.source_id]

        if ref then
            SU.hero_gain_xp_from_skill(ref, ref.hero.skills[this.xp_from_skill])
        end

        return true
    end
end



scripts.mod_phoenix_flaming_path = {}

function scripts.mod_phoenix_flaming_path.update(this, store, script)
    local m = this.modifier
    local ca = this.custom_attack
    local target = store.entities[m.target_id]
    local ending, fx_pos

    if not target or not target.tower then
        -- block empty
    else
        m.ts = store.tick_ts
        ca.ts = store.tick_ts
        fx_pos = V.vclone(target.pos)

        if this.custom_offsets and this.custom_offsets[target.template_name] then
            local o = this.custom_offsets[target.template_name]

            for _, s in pairs(this.render.sprites) do
                s.offset.x = s.offset.x + o.x
                s.offset.y = s.offset.y + o.y
            end

            fx_pos.x, fx_pos.y = fx_pos.x + o.x, fx_pos.y + o.y
        end

        SU.insert_sprite(store, ca.fx_start, fx_pos)

        while true do
            target = store.entities[m.target_id]

            if not target or store.tick_ts - m.ts > m.duration then
                break
            end

            if target and not ending and store.tick_ts - m.ts >= m.duration - 0.3 then
                ending = true

                SU.insert_sprite(store, ca.fx_end, fx_pos)
            end

            if store.tick_ts - ca.ts > ca.cooldown then
                ca.ts = store.tick_ts

                S:queue(sound)
                SU.insert_sprite(store, ca.fx, fx_pos)
                U.y_wait(store, ca.hit_time)

                local targets = U.find_enemies_in_range(store.enemies, target.pos, 0, ca.radius, ca.vis_flags,
                    ca.vis_bans)

                if targets then
                    for _, t in pairs(targets) do
                        local d = E:create_entity("damage")

                        d.value = ca.damage
                        d.damage_type = ca.damage_type
                        d.target_id = t.id
                        d.source_id = this.id

                        queue_damage(store, d)

                        local m = E:create_entity(ca.mod)

                        m.modifier.source_id = this.id
                        m.modifier.target_id = t.id

                        queue_insert(store, m)
                    end
                end
            end

            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.mod_phoenix_purification = {}

function scripts.mod_phoenix_purification.update(this, store, script)
    local m = this.modifier
    local target

    m.ts = store.tick_ts

    while true do
        target = store.entities[m.target_id]

        if not target or store.tick_ts - m.ts > m.duration then
            break
        end

        if target.health.dead then
            SU.insert_sprite(store, this.fx, target.pos)
            U.y_wait(store, fts(2))

            local e = E:create_entity(this.entity)

            e.pos = V.vclone(target.pos)
            e.bullet.from = V.vclone(e.pos)
            e.bullet.to = V.v(target.pos.x, target.pos.y + 100)

            local aura = store.entities[m.source_id]

            e.bullet.source_id = this.id
            e.bullet.xp_dest_id = aura and aura.aura.source_id or nil
            e.bullet.shot_index = 0

            queue_insert(store, e)

            break
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.mod_gnoll_blighter = {}

function scripts.mod_gnoll_blighter.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.plant then
        queue_remove(store, this)

        return
    end

    local p = target.plant

    m.ts = store.tick_ts
    this.render.sprites[1].ts = store.tick_ts
    this.pos.x, this.pos.y = target.pos.x, target.pos.y
    p.block_count = p.block_count + 1

    if p.block_count > 0 then
        p.blocked = true

        if this.ui then
            this.ui.can_click = false
        end
    end

    SU.tower_block_inc(target)
    U.y_wait(store, m.duration)

    p.block_count = p.block_count - 1

    if p.block_count < 1 then
        p.blocked = nil
        p.block_count = 0

        if this.ui then
            this.ui.can_click = true
        end
    end

    queue_remove(store, this)
end

scripts.mod_redcap_heal = {}

function scripts.mod_redcap_heal.insert(this, store)
    local target = store.entities[this.modifier.target_id]
    local source = store.entities[this.modifier.source_id]

    if target and source then
        local fx = E:create_entity(this.hit_fx)

        fx.pos = V.vclone(target.pos)
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].flip_x = target.pos.x < source.pos.x

        queue_insert(store, fx)
    end

    this.modifier.target_id = this.modifier.source_id

    return scripts.mod_hps.insert(this, store)
end

scripts.mod_twilight_avenger_last_service = {}

function scripts.mod_twilight_avenger_last_service.remove(this, store)
    local count_soldiers, count_enemies = 0, 0
    local target = store.entities[this.modifier.target_id]

    if this.modifier.removed_by_ban then
        return true
    end

    if not target then
        return true
    end

    if not target.health.dead then
        target.vis.flags = band(target.vis.flags, bnot(F_DARK_ELF))
    else
        local targets = table.filter(store.entities, function(k, v)
            return not v.pending_removal and v.vis and v.health and not v.health.dead and
                       band(v.vis.flags, this.explode_vis_bans) == 0 and band(v.vis.bans, this.explode_vis_flags) == 0 and
                       U.is_inside_ellipse(v.pos, this.pos, this.explode_range) and
                       not table.contains(this.explode_excluded_templates, v.template_name)
        end)

        if targets and #targets > 0 then
            for _, target in pairs(targets) do
                local is_enemy = band(target.vis.flags, F_ENEMY) ~= 0
                local d = E:create_entity("damage")
                if band(target.vis.flags, F_DARK_ELF) ~= 0 then
                    d.value = 0
                else
                    d.value = this.explode_damage
                end
                d.damage_type = DAMAGE_MAGICAL_EXPLOSION
                d.source_id = this.id
                d.target_id = target.id

                queue_damage(store, d)

                if is_enemy then
                    count_enemies = count_enemies + 1
                else
                    count_soldiers = count_soldiers + 1
                end
            end
        end

        if count_enemies > 0 and count_soldiers == 0 then
            -- AC:inc_check("LAST_SERVICE")
        end

        local p

        if U.flag_has(target.vis.flags, F_FLYING) then
            p = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
        else
            p = V.v(target.pos.x, target.pos.y)
        end

        SU.insert_sprite(store, this.explode_fx, p)
    end

    return true
end

scripts.mod_twilight_scourger_lash = {}

function scripts.mod_twilight_scourger_lash.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.health or target.health.dead then
        return false
    end

    m.ts = store.tick_ts
    U.speed_mul(target, this.speed_factor)
    target.unit.damage_factor = target.unit.damage_factor * this.damage_factor

    local s1, s2 = this.render.sprites[1], this.render.sprites[2]

    s1.ts, s2.ts = store.tick_ts, store.tick_ts
    s1.name = s1.size_names[target.unit.size]
    s2.scale = target.template_name == "enemy_twilight_avenger" and V.v(1, 1) or V.v(0.7, 0.7)
    s2.offset = s1.offset

    return true
end

function scripts.mod_twilight_scourger_lash.remove(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        U.speed_div(target, this.speed_factor)
        target.unit.damage_factor = target.unit.damage_factor / this.damage_factor
    end

    return true
end

scripts.mod_twilight_scourger_banshee = {}

function scripts.mod_twilight_scourger_banshee.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        queue_remove(store, this)

        return
    end

    target._is_banshee_target = nil
    m.ts = store.tick_ts

    SU.tower_block_inc(target)

    this.tween.ts = store.tick_ts

    U.y_wait(store, m.duration - 0.2)

    local fx = E:create_entity("fx_twilight_scourger_banshee_end")

    fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
    fx.render.sprites[1].ts = store.tick_ts

    queue_insert(store, fx)
    SU.tower_block_dec(target)
    queue_remove(store, this)
end

scripts.mod_spider_web = {}

function scripts.mod_spider_web.insert(this, store, script)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead then
        return false
    end

    if target.template_name == "soldier_blade" and target.dodge and target.dodge.chance > 0 and
        not target.unit.is_stunned and not target.timed_attacks.list[1].in_progress and
        target.powers[target.dodge.power_name].level > 0 and target.dodge.chance >= math.random() then
        log.debug("(%s)mod_spider_web blocked by (%s)soldier_blade perfect parry", this.id, target.id)

        target.dodge.active = true

        return false
    else
        return scripts.mod_stun.insert(this, store, script)
    end
end

scripts.mod_twilight_heretic_consume = {}

function scripts.mod_twilight_heretic_consume.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        return false
    end

    m.ts = store.tick_ts
    this._angles_walk = target.render.sprites[1].angles.walk
    this._health_bar_offset_y = target.health_bar.offset.y
    target.render.sprites[1].angles.walk = this.angles_walk
    U.speed_mul(target, this.speed_factor)
    target.ranged.attacks[1].disabled = true

    return true
end

function scripts.mod_twilight_heretic_consume.remove(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        target.render.sprites[1].angles.walk = this._angles_walk
        target.health_bar.offset.y = this._health_bar_offset_y
        U.speed_div(target, this.speed_factor)
        target.ranged.attacks[1].disabled = false
    end

    return true
end

function scripts.mod_twilight_heretic_consume.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target or not target.pos then
        queue_remove(store, this)

        return
    end

    local st = target.render.sprites[1]
    local hboy = target.health_bar.offset.y

    this.pos = target.pos

    while true do
        target = store.entities[m.target_id]

        if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or
            P:nodes_to_goal(target.nav_path) < this.nodes_limit then
            queue_remove(store, this)

            return
        end

        local oy, hoy = 0, 0

        if string.starts(st.name, "flying") then
            oy = this.mod_offset_y
            hoy = this.health_bar_offset_y
        end

        this.render.sprites[1].offset.y = oy
        target.health_bar.offset.y = hboy + hoy

        coroutine.yield()
    end
end

scripts.mod_twilight_heretic_servant = {}

function scripts.mod_twilight_heretic_servant.update(this, store)
    local m = this.modifier
    local dps = this.dps
    local target = store.entities[m.target_id]
    local looping = false

    if not target then
        queue_remove(store, this)

        return
    end

    m.ts = store.tick_ts
    dps.ts = store.tick_ts - dps.damage_every
    target.vis.flags = U.flag_set(target.vis.flags, F_SERVANT)

    U.animation_start(this, "start", nil, store.tick_ts, false)

    while store.tick_ts - m.ts < m.duration do
        target = store.entities[m.target_id]

        if not target or target.health.dead then
            break
        end

        if not looping and U.animation_finished(this) then
            looping = true

            U.animation_start(this, "loop", nil, store.tick_ts, true)
        end

        if store.tick_ts - dps.ts >= dps.damage_every then
            dps.ts = store.tick_ts

            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = target.id
            d.value = math.random(dps.damage_min, dps.damage_max)
            d.damage_type = dps.damage_type

            queue_damage(store, d)
        end

        coroutine.yield()
    end

    if target then
        target.vis.flags = U.flag_clear(target.vis.flags, F_SERVANT)
    end

    this.tween.disabled = nil
    this.tween.ts = store.tick_ts
end

scripts.mod_drider_poison = {}

function scripts.mod_drider_poison.update(this, store)
    local m = this.modifier
    local dps = this.dps
    local target
    local source = store.entities[m.source_id]
    local generation = source and source.generation + 1 or 1

    while store.tick_ts - m.ts < m.duration do
        target = store.entities[m.target_id]

        if not target then
            break
        end

        this.pos = target.pos

        if this.render and m.use_mod_offset and target.unit.mod_offset then
            this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.mod_offset.x,
                target.unit.mod_offset.y
        end

        if target.health.dead then
            coroutine.yield()
            coroutine.yield()

            if target.hero or (not target.health.dead) or (target.reinforcement and target.reinforcement.hp_before_timeout) then
                break
            end

            local ec = E:create_entity("decal_drider_clone")

            ec.render = table.deepclone(target.render)
            ec.pos.x, ec.pos.y = target.pos.x, target.pos.y

            queue_insert(store, ec)
            coroutine.yield()
            U.sprites_hide(target)

            local e = E:create_entity("decal_drider_cocoon")
            local se = e.render.sprites[1]

            e.pos.x, e.pos.y = target.pos.x, target.pos.y - 1
            se.flip_x = ec.render.sprites[1].flip_x
            se.scale = se.size_scales[target.unit.size]
            e.generation = generation

            queue_insert(store, e)

            break
        end

        if store.tick_ts - dps.ts >= dps.damage_every then
            dps.ts = store.tick_ts

            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = target.id
            d.value = dps.damage_max
            d.damage_type = dps.damage_type

            queue_damage(store, d)
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.decal_drider_cocoon = {}

function scripts.decal_drider_cocoon.update(this, store)
    U.y_animation_play(this, "start", nil, store.tick_ts)
    U.y_wait(store, this.duration)
    U.y_animation_play(this, "end", nil, store.tick_ts)

    local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_RALLY)

    if #nodes < 1 then
        log.error("(%s) decal_drider_cocoon: could not find valid node to spawn enemy. %s,%s", this.id, this.pos.x,
            this.pos.y)
        queue_remove(store, this)

        return
    end

    local e = E:create_entity("enemy_drider")
    local n = e.nav_path

    e.pos.x, e.pos.y = this.pos.x, this.pos.y
    n.pi, n.spi, n.ni = nodes[1][1], nodes[1][2], nodes[1][3] + 2
    e.render.sprites[1].name = "raise"
    e.generation = this.generation
    e.melee.attacks[2].cooldown = e.melee.attacks[2].cooldown + e.generation * e.melee.attacks[2].cooldown_inc
    e.melee.attacks[2].ts = store.tick_ts

    queue_insert(store, e)
    queue_remove(store, this)
end

scripts.mod_razorboar_rampage_speed = {}

function scripts.mod_razorboar_rampage_speed.insert(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        return false
    end

    this._initial_max_speed = target.motion.max_speed
    U.speed_mul(target, this.speed_factor)

    return true
end

function scripts.mod_razorboar_rampage_speed.remove(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        U.speed_div(target, this.speed_factor)
    end

    return true
end

function scripts.mod_razorboar_rampage_speed.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        queue_remove(store, this)

        return false
    end

    while true do
        target = store.entities[m.target_id]

        if not target or target.health.dead or not target.enemy.can_do_magic or store.tick_ts - m.ts >= m.duration then
            queue_remove(store, this)

            return
        end

        coroutine.yield()
    end
end

scripts.mod_mactans_tower_block = {}

function scripts.mod_mactans_tower_block.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if not target then
        queue_remove(store, this)

        return
    end

    SU.tower_block_inc(target)

    m.ts = store.tick_ts
    this.tween.ts = store.tick_ts

    U.y_wait(store, m.duration + 4 * fts(17))
    U.sprites_hide(this, 1, 4)
    U.sprites_show(this, 5, 5)
    U.y_animation_play(this, "end", nil, store.tick_ts, 1, 5)
    SU.tower_block_dec(target)
    queue_remove(store, this)
end

scripts.mod_bloodsydian_warlock = {}

function scripts.mod_bloodsydian_warlock.update(this, store)
    local target = store.entities[this.modifier.target_id]

    if not target or target.health.dead or not U.flags_pass(target.vis, this.modifier) then
        queue_remove(store, this)

        return
    end

    SU.stun_inc(target)

    target.vis.bans = bor(F_MOD, F_TELEPORT, F_RANGED)
    target.health.ignore_damage = true
    target.ui.can_select = false

    U.sprites_hide(target, nil, nil, true)

    this.pos.x, this.pos.y = target.pos.x, target.pos.y

    U.animation_start(this, "start", target.render.sprites[1].flip_x, store.tick_ts)

    this.incubation_time = this.incubation_time +
                               U.frandom(-this.incubation_time_variance, this.incubation_time_variance)

    U.y_wait(store, this.incubation_time, function()
        return target.health.dead
    end)
    U.sprites_show(target, nil, nil, true)

    target.health.ignore_damage = false

    if this.modifier.kill then
        local d = E:create_entity("damage")

        d.source_id = this.id
        d.target_id = target.id
        d.value = target.health.hp

        queue_damage(store, d)
    elseif not target.health.dead and target.health.hp > 0 then
        local d = E:create_entity("damage")

        d.damage_type = DAMAGE_EAT
        d.source_id = this.id
        d.target_id = target.id

        queue_damage(store, d)

        local e = E:create_entity(this.spawn_name)

        e.pos.x, e.pos.y = target.pos.x, target.pos.y
        e.nav_path = table.deepclone(target.nav_path)
        e.render.sprites[1].flip_x = target.render.sprites[1].flip_x
        e.enemy.gold = target.enemy.gold
        e.enemy.gold_bag = target.enemy.gold_bag
        e.enemy.gems = target.enemy.gems

        queue_insert(store, e)

        target.enemy.gold = 0
        target.enemy.gold_bag = 0
        target.enemy.gems = 0
    end

    S:queue("ElvesCrystallizedGnoll")
    U.y_animation_play(this, "end", nil, store.tick_ts)
    queue_remove(store, this)
end

scripts.mod_dark_spitters = {}

function scripts.mod_dark_spitters.update(this, store)
    local m = this.modifier
    local dps = this.dps
    local target, generation

    while store.tick_ts - m.ts < m.duration do
        target = store.entities[m.target_id]

        if not target then
            break
        end

        this.pos = target.pos

        if this.render and m.use_mod_offset and target.unit.mod_offset then
            local flip_sign = target.render.sprites[1].flip_x and -1 or 1

            this.render.sprites[1].offset.x = target.unit.mod_offset.x * flip_sign
            this.render.sprites[1].offset.y = target.unit.mod_offset.y
        end

        if target.health.dead then
            coroutine.yield()
            coroutine.yield()

            if target.hero or not target.health.dead or target.reinforcement and target.reinforcement.hp_before_timeout then
                break
            end

            U.sprites_hide(target)
            SU.insert_sprite(store, this.explode_fx, target.pos)

            local nodes = P:nearest_nodes(target.pos.x, target.pos.y, nil, nil, true, NF_RALLY)

            if #nodes < 1 then
                log.error("(%s) mod_dark_spitters: could not find valid node nearby to spawn enemy. %s,%s", this.id,
                    target.pos.x, target.pos.y)

                break
            end

            local pi, spi, ni = nodes[1][1], nodes[1][2], nodes[1][3]

            if P:nodes_to_defend_point(pi, spi, ni) < this.nodes_limit then
                break
            end

            local e = E:create_entity(this.spawn_entity)
            local n = e.nav_path

            e.pos.x, e.pos.y = target.pos.x, target.pos.y
            n.pi, n.spi, n.ni = pi, spi, ni + 2
            e.render.sprites[1].name = "raise"
            e.enemy.gold = 0
            e.enemy.gold_bag = 0
            e.enemy.gems = 0

            queue_insert(store, e)

            break
        end

        if store.tick_ts - dps.ts >= dps.damage_every then
            dps.ts = store.tick_ts

            local d = E:create_entity("damage")

            d.source_id = this.id
            d.target_id = target.id
            d.value = dps.damage_max
            d.damage_type = dps.damage_type

            queue_damage(store, d)
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.mactans_controller = {}

function scripts.mactans_controller.insert(this, store)
    if this.load_file then
        local fn = KR_PATH_GAME .. "/data/levels/" .. this.load_file .. ".lua"
        local data, err = LU.eval_file(fn)

        if not data then
            log.error("mactans_controller failed loading file %s: %s", this.load_file, err)

            return false
        end

        this.sequence = data.sequence
        this.sequence_groups = data.sequence_groups
    end

    return true
end

function scripts.mactans_controller.update(this, store)
    local mactans = LU.list_entities(store.entities, "enemy_mactans")[1]
    local sequence = this.sequence and this.sequence[store.level_mode]

    if not this.sequence then
        log.error("mactans_controller not initialized. sequence is missing")
    elseif not sequence then
        log.debug("mactans_controller has no configuration for this game mode")
    elseif not mactans then
        log.error("enemy_mactans could not be found")
    else
        while not store.waves_finished do
            local start_ts, last_ts = store.tick_ts, store.tick_ts
            local wave_number = store.wave_group_number
            local groups = sequence[wave_number]

            if not groups then
                -- block empty
            else
                for _, group in pairs(groups) do
                    local t_elapsed = store.tick_ts - start_ts
                    local t_total = group[1]
                    local t_actual = km.clamp(0, t_total, t_total - t_elapsed)

                    log.debug("mactans_controller wave_number:%s delay:%s waiting:%s type:%s", wave_number, t_total,
                        t_actual, group[2])

                    if U.y_wait(store, t_actual, function(store, time)
                        return store.wave_group_number ~= wave_number or store.waves_finished
                    end) then
                        goto label_487_0
                    end

                    if group[2] == "tower_block" then
                        local holder_ids = this.sequence_groups.towers[group[3]]

                        if holder_ids and #holder_ids > 0 then
                            mactans.phase_signal = group[2]
                            mactans.phase_params = {
                                holder_ids = holder_ids,
                                block_duration = group[4],
                                touch_duration = group[5]
                            }
                        else
                            log.info("mactans wave:%s tower_block for group:%s has no holder_ids defined", wave_number,
                                group[3])
                        end
                    elseif group[2] == "path_web" then
                        local path_data = table.random(this.sequence_groups.paths[group[3]])

                        mactans.phase_signal = group[2]
                        mactans.phase_params = {
                            path_id = path_data.path_id,
                            near_pos = path_data.pos,
                            web_duration = group[4],
                            touch_duration = group[6],
                            qty_per_egg = group[5]
                        }
                    end

                    if store.wave_group_number ~= wave_number then
                        goto label_487_0
                    end
                end

                coroutine.yield()
            end

            ::label_487_0::

            while store.wave_group_number == wave_number and not store.waves_finished do
                coroutine.yield()
            end
        end
    end

    queue_remove(store, this)
end

scripts.power_thunder_control = {}

function scripts.power_thunder_control.can_select_point(this, x, y, store)
    return not GR:cell_is(x, y, TERRAIN_CLIFF) and not GR:cell_is(x, y, TERRAIN_FAERIE) and
               (P:valid_node_nearby(x, y, 1.4285714285714286, NF_POWER_1) or store.level.fn_can_power and
                   store.level:fn_can_power(store, GUI_MODE_POWER_1, V.v(x, y)) or GR:cell_is(x, y, TERRAIN_WATER))
end

function scripts.power_thunder_control.update(this, store)
    local function create_thunder(thunder, pos)
        local e = E:create_entity("fx_power_thunder_" .. math.random(1, 2))

        e.pos.x, e.pos.y = pos.x, pos.y
        e.render.sprites[1].flip_x = math.random() < 0.5
        e.render.sprites[1].ts = store.tick_ts

        if REF_H - pos.y > e.image_h then
            e.render.sprites[1].scale = V.v(1, (REF_H - pos.y) / e.image_h)
        end

        queue_insert(store, e)

        e = E:create_entity("fx_power_thunder_explosion")
        e.pos.x, e.pos.y = pos.x, pos.y
        e.render.sprites[1].ts = store.tick_ts
        e.render.sprites[2].ts = store.tick_ts

        queue_insert(store, e)

        e = E:create_entity("fx_power_thunder_explosion_decal")
        e.pos.x, e.pos.y = pos.x, pos.y
        e.render.sprites[1].ts = store.tick_ts

        queue_insert(store, e)

        if thunder.pop and math.random() < thunder.pop_chance then
            local e = SU.create_pop(store, this.pos, thunder.pop)

            queue_insert(store, e)
        end

        local targets = U.find_enemies_in_range(store.enemies, pos, 0, thunder.damage_radius, this.vis_flags,
            this.vis_bans)

        if targets then
            for _, target in pairs(targets) do
                local d = E:create_entity("damage")

                d.damage_type = thunder.damage_type
                d.value = math.random(thunder.damage_min, thunder.damage_max)
                d.target_id = target.id
                d.source_id = this.id

                queue_damage(store, d)
            end
        end

        -- AC:inc_check("LIGHTNING_CAST")
    end

    local function flash_screen(fx)
        if store.tick_ts - fx.ts > fx.cooldown then
            local duration = U.frandom(this.flash_duration_min, this.flash_duration_max)
            local delay = U.frandom(this.flash_delay_min, this.flash_delay_max)
            local a1 = math.random(this.flash_l1_max_alphas[1], this.flash_l1_max_alphas[2])
            local a2 = this.flash_l2_max_alpha
            local a22 = this.flash_l2_min_alpha
            local delta = this.flash_delta
            local t1, t2, t3 = 0, delta, delta + duration

            fx.tween.props[1].keys = {{t1, 0}, {t2, a1}, {t3, 0}}
            fx.tween.ts = store.tick_ts
            fx.ts = store.tick_ts
            fx.cooldown = duration + U.frandom(0, 0.4)
        end
    end

    local overlay = E:create_entity("overlay_power_thunder_flash")

    overlay.pos.x, overlay.pos.y = REF_W / 2, REF_H / 2
    overlay.tween.props[2].keys = {{0, 0}, {0.5, this.flash_l2_max_alpha}}
    overlay.tween.props[2].ts = store.tick_ts

    queue_insert(store, overlay)
    flash_screen(overlay)

    local visited = {}
    local t1, t2 = this.thunders[1], this.thunders[2]

    t1.created, t2.created = 0, 0

    if t2.count > 0 then
        t2.cooldown = U.frandom(t2.delay_min, t2.delay_max)
        t2.ts = store.tick_ts
    end

    while t1.created < t1.count or t2.created < t2.count do
        for _, thunder in pairs(this.thunders) do
            if thunder.created < thunder.count and store.tick_ts - thunder.ts > thunder.cooldown then
                local pos

                if thunder.targeting == "nearest" then
                    if thunder.created == 0 then
                        pos = this.pos
                    else
                        local target = U.find_nearest_enemy(store.enemies, this.pos, 0, thunder.range, this.vis_flags,
                            this.vis_bans, function(v)
                                return not table.contains(visited, v)
                            end)

                        if target then
                            table.insert(visited, target)

                            pos = target.pos
                        else
                            local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

                            if #nearest > 0 then
                                local pi, spi, ni = unpack(nearest[1])
                                local no = math.random(-this.nodes_spread, this.nodes_spread)

                                if not P:is_node_valid(pi, ni + no) then
                                    no = 0
                                end

                                pos = P:node_pos(pi, math.random(1, 3), ni + no)
                            end
                        end
                    end
                else
                    local target = U.find_random_enemy(store.enemies, this.pos, 0, thunder.range, this.vis_flags,
                        this.vis_bans)

                    if target then
                        pos = target.pos
                    else
                        pos = P:get_random_position(10, bor(TERRAIN_LAND, TERRAIN_WATER)) or this.pos
                    end
                end

                if pos then
                    create_thunder(thunder, pos)
                    flash_screen(overlay)
                end

                thunder.ts = store.tick_ts
                thunder.cooldown = U.frandom(thunder.delay_min, thunder.delay_max)
                thunder.created = thunder.created + 1
            end
        end

        if not this.slow.disabled and store.tick_ts - this.slow.ts > this.slow.cooldown then
            this.slow.ts = store.tick_ts

            local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, this.slow.range, this.vis_flags,
                this.vis_bans)

            if targets then
                for _, target in pairs(targets) do
                    local mod = E:create_entity(this.slow.mod)

                    mod.modifier.target_id = target.id
                    mod.modifier.source_id = this.id

                    queue_insert(store, mod)
                end
            end
        end

        if not this.rain.disabled and store.tick_ts - this.rain.ts > this.rain.cooldown then
            local r = this.rain

            r.ts = store.tick_ts

            local angle = U.frandom(r.angle_min, r.angle_max)

            for i = 1, r.count do
                angle = angle + U.frandom(-r.angle_between, r.angle_between)

                local dist = math.random(r.distance_min, r.distance_max)
                local ox, oy = V.rotate(angle, dist, 0)
                local delay = U.frandom(0.001, r.delay_max)
                local pos = V.v(math.random(-REF_OX, REF_W + REF_OX), math.random(0, REF_H))
                local e = E:create_entity("fx_power_thunder_drop")

                e.pos.x, e.pos.y = pos.x, pos.y
                e.render.sprites[1].offset = V.v(-ox, -oy)
                e.render.sprites[1].r = angle
                e.render.sprites[1].alpha = math.random(r.alpha_min, r.alpha_max)
                e.tween.props[1].keys = {{0, 0}, {0.001, 255}}
                e.tween.props[2] = E:clone_c("tween_prop")
                e.tween.props[2].keys = {{0, V.v(-ox, -oy)}, {0.001, V.v(-ox, -oy)}, {r.duration, V.v(0, 0)}}
                e.tween.props[2].name = "offset"
                e.tween.ts = store.tick_ts + delay

                queue_insert(store, e)

                local e = E:create_entity("fx_power_thunder_rain_splash")

                e.pos.x, e.pos.y = pos.x, pos.y
                e.render.sprites[1].ts = store.tick_ts + delay + r.duration

                queue_insert(store, e)
            end
        end

        coroutine.yield()
    end

    U.y_wait(store, overlay.cooldown)

    overlay.tween.remove = true
    overlay.tween.props[1].keys = {{0, overlay.render.sprites[1].alpha}, {0.5, 0}}
    overlay.tween.props[2].keys = {{0, overlay.render.sprites[2].alpha}, {0.5, 0}}
    overlay.tween.ts = store.tick_ts
    overlay.tween.props[2].ts = nil

    queue_remove(store, this)
end

scripts.power_hero_control = {}

function scripts.power_hero_control.can_select_point(this, x, y, store)
    if store.main_hero then
        local ut = E:get_template(store.main_hero.hero.skills.ultimate.controller_name)

        if not ut.can_fire_fn or ut.can_fire_fn(ut, x, y, store) then
            return true
        end
    end

    return false
end

function scripts.power_hero_control.insert(this, store)
    if store.main_hero then
        local u = store.main_hero.hero.skills.ultimate
        local e = E:create_entity(u.controller_name)

        e.pos.x, e.pos.y = this.pos.x, this.pos.y
        e.owner = store.main_hero
        e.level = u.level

        queue_insert(store, e)
    end

    return false
end

scripts.user_item_gem_timewarp = {}

function scripts.user_item_gem_timewarp.update(this, store)
    local a = this.aura

    signal.emit("gem-timewarp-starts")

    for i = 1, 10 do
        local pos = P:get_random_position(10, bor(TERRAIN_LAND), NF_RALLY) or this.pos

        SU.insert_sprite(store, a.custom_fx, pos)
    end

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for _, e in pairs(targets) do
            local m = E:create_entity(a.mod_teleport)

            m.modifier.target_id = e.id
            m.modifier.source_id = this.id

            queue_insert(store, m)

            local teleport_nodes = math.abs(U.flag_has(e.vis.flags, F_BOSS) and m.boss_nodes_offset or m.nodes_offset)
            local extra_time = U.frandom(a.extra_slow_duration_random[1], a.extra_slow_duration_random[2])

            if teleport_nodes > e.nav_path.ni then
                extra_time = extra_time + (teleport_nodes - e.nav_path.ni) * a.extra_slow_duration_per_clamped_node
            end

            m = E:create_entity(a.mod_slow)
            m.modifier.target_id = e.id
            m.modifier.source_id = this.id
            m.modifier.duration = m.modifier.duration + extra_time

            queue_insert(store, m)
        end
    end

    queue_remove(store, this)
end

scripts.user_item_wrath_of_elynia = {}

function scripts.user_item_wrath_of_elynia.update(this, store)
    local a = this.aura
    local shake, targets

    signal.emit("wrath-of-elynia-starts")
    U.y_wait(store, fts(5))

    shake = E:create_entity("aura_screen_shake")
    shake.aura.amplitude = 0.2
    shake.aura.duration = 1
    shake.aura.freq_factor = 2

    queue_insert(store, shake)

    local ray = SU.insert_sprite(store, "decal_elynia_ray", this.pos)

    targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for _, e in pairs(targets) do
            local m = E:create_entity(a.mod_slow)

            m.modifier.target_id = e.id
            m.modifier.source_id = this.id

            queue_insert(store, m)
        end
    end

    U.y_wait(store, 1)

    shake = E:create_entity("aura_screen_shake")
    shake.aura.amplitude = 1
    shake.aura.duration = 1.5
    shake.aura.freq_factor = 3

    queue_insert(store, shake)

    local explosion = SU.insert_sprite(store, "decal_elynia_big_explosion", this.pos)

    ray.tween.reverse = true
    ray.tween.ts = store.tick_ts
    ray.render.sprites[2].hidden = true

    U.y_wait(store, fts(4))
    queue_remove(store, ray)

    local r = 0
    local start_ts = store.tick_ts
    local seen_bosses = {}

    while r < a.radius do
        r = (store.tick_ts - start_ts) * a.spread_speed
        targets = U.find_enemies_in_range(store.enemies, this.pos, 0, r, a.vis_flags, a.vis_bans)

        if targets then
            for _, e in pairs(targets) do
                do
                    local m

                    if e.vis and band(e.vis.flags, F_BOSS) ~= 0 then
                        if seen_bosses[e.id] then
                            goto label_497_0
                        else
                            seen_bosses[e.id] = true
                        end
                    end

                    m = E:create_entity(a.mod_kill)
                    m.modifier.target_id = e.id
                    m.modifier.source_id = this.id
                    m.modifier.delay = 0

                    queue_insert(store, m)
                end

                ::label_497_0::
            end
        end

        U.y_wait(store, fts(2))
    end

    U.y_wait(store, 0.5)
    signal.emit("wrath-of-elynia-ends")
    queue_remove(store, this)
end

scripts.mod_kill_elynia = {}

function scripts.mod_kill_elynia.queue(this, store, insertion)
    local target = store.entities[this.modifier.target_id]

    if not target then
        return
    end

    if insertion and not U.flag_has(target.vis.flags, F_BOSS) then
        target.vis.bans = F_ALL

        SU.stun_inc(target)
    end
end

function scripts.mod_kill_elynia.update(this, store)
    local m = this.modifier
    local target = store.entities[m.target_id]

    if target then
        U.y_wait(store, m.delay)
        SU.insert_sprite(store, "fx_elynia_creep_explosion", target.pos)

        if U.flag_has(target.vis.flags, F_BOSS) then
            local d = E:create_entity("damage")

            d.damage_type = DAMAGE_TRUE
            d.value = m.damage_boss
            d.source_id = this.id
            d.target_id = target.id

            queue_damage(store, d)
        else
            local ash = SU.insert_sprite(store, "fx_elynia_creep_ashes", target.pos)
            local ash_hold = U.frandom(0, 1)

            ash.tween.props[1].keys[2][1] = ash.tween.props[1].keys[2][1] + ash_hold
            ash.tween.props[1].keys[3][1] = ash.tween.props[1].keys[3][1] + ash_hold

            local d = E:create_entity("damage")

            d.damage_type = DAMAGE_EAT
            d.source_id = this.id
            d.target_id = target.id

            queue_damage(store, d)
        end
    end

    queue_remove(store, this)
end

scripts.user_item_horn_heroism = {}

function scripts.user_item_horn_heroism.update(this, store)
    local a = this.aura
    local at = this.mod_attack

    this.render.sprites[2].ts = store.tick_ts
    this.render.sprites[3].ts = store.tick_ts
    this.tween.ts = store.tick_ts

    U.y_wait(store, fts(17))

    local targets = U.find_soldiers_in_range(store.soldiers, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

    if targets then
        for i = 1, math.min(#targets, a.max_soldiers) do
            local e = targets[i]
            local m = E:create_entity(a.mod)

            m.modifier.target_id = e.id
            m.modifier.source_id = this.id

            queue_insert(store, m)
        end
    end

    local targets = U.find_towers_in_range(store.towers, this.pos, at, function(e, o)
        return not e.barrack and e.tower.can_be_mod
    end)

    if targets then
        for i = 1, math.min(#targets, at.max_towers) do
            local e = targets[i]
            local m = E:create_entity(at.mod)

            m.modifier.target_id = e.id
            m.modifier.source_id = this.id

            queue_insert(store, m)
        end
    end

    U.y_animation_wait(this, 2)
    queue_remove(store, this)
end

scripts.mod_horn_heroism_soldier = {}

function scripts.mod_horn_heroism_soldier.insert(this, store)
    if scripts.mod_damage_factors.insert(this, store) then
        local target = store.entities[this.modifier.target_id]

        if target then
            target.health.immune_to = this.immune_to
        end

        return true
    else
        return false
    end
end

function scripts.mod_horn_heroism_soldier.remove(this, store)
    local target = store.entities[this.modifier.target_id]

    if target then
        target.health.immune_to = DAMAGE_NONE
    end

    scripts.mod_damage_factors.remove(this, store)

    return true
end

scripts.user_item_rod_dragon_fire = {}

function scripts.user_item_rod_dragon_fire.can_select_point(this, x, y, store)
    return scripts.power_reinforcements_control.can_select_point(this, x, y)
end

function scripts.user_item_rod_dragon_fire.update(this, store)
    local au = this.aura
    local at = this.attacks.list[1]

    au.ts = store.tick_ts
    at.ts = store.tick_ts

    U.y_animation_play(this, "start", nil, store.tick_ts, 1, 1)

    this.render.sprites[2].hidden = nil

    while true do
        if store.tick_ts - au.ts >= au.duration then
            break
        end

        if store.tick_ts - at.ts > at.cooldown then
            local target, _, pred_pos = U.find_foremost_enemy(store.enemies, this.pos, 0, at.range, at.node_prediction,
                at.vis_flags, at.vis_bans)

            if not target then
                SU.delay_attack(store, at, 0.2)
            else
                at.ts = store.tick_ts

                local bullet = E:create_entity(at.bullet)

                bullet.pos.x, bullet.pos.y = this.pos.x + at.bullet_start_offset.x,
                    this.pos.y + at.bullet_start_offset.y
                bullet.bullet.from = V.vclone(bullet.pos)
                bullet.bullet.to = V.v(pred_pos.x + target.unit.hit_offset.x, pred_pos.y + target.unit.hit_offset.y)
                bullet.bullet.target_id = target.id

                queue_insert(store, bullet)
            end
        end

        coroutine.yield()
    end

    this.render.sprites[2].hidden = true

    U.y_animation_play(this, "end", nil, store.tick_ts, 1, 1)
    queue_remove(store, this)
end

scripts.user_item_hand_midas = {}

function scripts.user_item_hand_midas.can_select_point(this, x, y, store)
    local u = LU.list_entities(store.entities, this.template_name)[1]

    if u and not u.pending_removal then
        return false
    else
        return true
    end
end

function scripts.user_item_hand_midas.update(this, store)
    this.ts = store.tick_ts
    store.hand_of_midas_factor = this.gold_bonus_factor

    signal.emit("hand-midas-starts")

    while store.tick_ts - this.ts < this.duration do
        coroutine.yield()
    end

    store.hand_of_midas_factor = nil

    signal.emit("hand-midas-ends")
    queue_remove(store, this)
end

scripts.birds_controller = {}

function scripts.birds_controller.update(this, store)
    local ts = store.tick_ts
    local i = 1

    while true do
        local delay = U.frandom(this.delay[1], this.delay[2])

        U.y_wait(store, delay)

        for j = 1, this.batch_count do
            local batch_delay = U.frandom(this.batch_delay[1], this.batch_delay[2])

            U.y_wait(store, batch_delay)

            local e = E:create_entity(table.random(this.bird_templates))
            local o, d = this.origins[km.zmod(i, #this.origins)], this.destinations[km.zmod(i, #this.destinations)]
            local fly_time = V.dist(o.x, o.y, d.x, d.y) / this.fly_speed

            e.pos = V.v(o.x, o.y)
            e.tween.props[1].keys = {{0, V.v(0, 0)}, {fly_time, V.v(d.x, d.y)}}
            e.render.sprites[1].ts = store.tick_ts
            e.render.sprites[1].flip_x = o.x > d.x

            queue_insert(store, e)

            i = i + 1
        end
    end
end

scripts.decal_bambi = {}

function scripts.decal_bambi.update(this, store)
    local clicks = 0
    local max_clicks = math.random(3, 6)
    local idle_ts, idle_time = store.tick_ts, 1
    local pos1, pos2

    if this.run_offset then
        pos1 = V.vclone(this.pos)
        pos2 = V.v(this.pos.x + this.run_offset.x, this.pos.y + this.run_offset.y)
    end

    while true do
        if this.ui.clicked then
            clicks = clicks + 1

            if max_clicks < clicks then
                S:queue("DeathEplosion")

                local fx = E:create_entity("fx_unit_explode")

                fx.pos = V.vclone(this.pos)
                fx.render.sprites[1].ts = store.tick_ts
                fx.render.sprites[1].name = "small"

                queue_insert(store, fx)

                local blood = E:create_entity("decal_blood_pool")

                blood.render.sprites[1].ts = store.tick_ts
                blood.pos = V.vclone(this.pos)

                queue_insert(store, blood)
                queue_remove(store, this)

                return
            else
                U.y_animation_play(this, "touch", nil, store.tick_ts)
            end

            this.ui.clicked = nil
        end

        if idle_time < store.tick_ts - idle_ts then
            idle_ts = store.tick_ts
            idle_time = U.frandom(1, 3)

            if math.random() < 0.8 then
                U.animation_start(this, "eat", nil, store.tick_ts)
            elseif pos1 and pos2 then
                local dest = V.veq(this.pos, pos1) and pos2 or pos1
                local af = dest.x < this.pos.x

                U.animation_start(this, "run", af, store.tick_ts, true)
                U.set_destination(this, dest)

                while not this.motion.arrived do
                    U.walk(this, store.tick_length)
                    coroutine.yield()
                end

                U.animation_start(this, "idle", nil, store.tick_ts)

                this.ui.clicked = nil
            end
        end

        coroutine.yield()
    end
end

scripts.decal_rabbit = {}

function scripts.decal_rabbit.update(this, store)
    local clicks = 0

    local function clicked()
        if this.ui.clicked then
            this.ui.clicked = nil

            return true
        end
    end

    local ani, tmin, tmax, hide_ani

    ::label_510_0::

    while true do
        for _, s in pairs(this.ani_sequence) do
            ani, tmin, tmax, hide_ani = unpack(s, 1, 4)

            if ani then
                if this.tween.reverse then
                    this.tween.reverse = nil
                    this.tween.ts = 0
                end

                U.animation_start(this, ani, nil, store.tick_ts)
            else
                this.tween.reverse = true
                this.tween.ts = store.tick_ts
            end

            if tmin and tmax then
                this.ui.clicked = nil

                if U.y_wait(store, math.random(tmin, tmax), hide_ani and clicked or nil) then
                    goto label_510_1
                end
            else
                U.y_animation_wait(this)
            end
        end
    end

    ::label_510_1::

    U.y_animation_play(this, hide_ani, nil, store.tick_ts)

    this.tween.reverse = true
    this.tween.ts = store.tick_ts

    -- AC:inc_check("FOLLOW_RABBIT")
    U.y_wait(store, math.random(tmin, tmax))

    goto label_510_0
end

scripts.decal_crane = {}

function scripts.decal_crane.update(this, store)
    local clicks = 0
    local max_clicks = math.random(this.final_clicks[1], this.final_clicks[2])
    local play_ts = store.tick_ts
    local play_time = U.frandom(this.play_time[1], this.play_time[2])

    while true do
        if this.ui.clicked then
            clicks = clicks + 1

            if max_clicks <= clicks then
                this.render.sprites[2].hidden = true

                U.y_animation_play(this, this.final_click_animation, nil, store.tick_ts, 1, 1)
                queue_remove(store, this)

                return
            else
                U.y_animation_play(this, this.click_animation, nil, store.tick_ts, 1, 1)
                U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
            end

            this.ui.clicked = nil
            play_ts = store.tick_ts
        end

        if play_time < store.tick_ts - play_ts then
            play_ts = store.tick_ts
            play_time = U.frandom(this.play_time[1], this.play_time[2])

            U.y_animation_play(this, this.play_animation, nil, store.tick_ts, 1, 1)
            U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

            this.ui.clicked = nil
        end

        coroutine.yield()
    end
end

scripts.river_object_controller = {}

function scripts.river_object_controller.update(this, store)
    while store.wave_group_number < 1 do
        coroutine.yield()
    end

    local spawn_ts = store.tick_ts
    local spawn_time = U.frandom(this.min_time, this.max_time)
    local chests = 0
    local name = "hobbit"

    while true do
        if spawn_time < store.tick_ts - spawn_ts then
            spawn_time = U.frandom(this.min_time, this.max_time)
            spawn_ts = store.tick_ts

            if name ~= "hobbit" then
                name = "hobbit"
            else
                name = table.random(this.river_objects)

                if name == "chest" then
                    chests = chests + 1

                    if chests >= this.max_chests then
                        table.removeobject(this.river_objects, "chest")
                    end
                end
            end

            local e = E:create_entity("decal_river_object_" .. name)

            queue_insert(store, e)
        end

        coroutine.yield()
    end
end

scripts.decal_river_object = {}

function scripts.decal_river_object.update(this, store)
    local next, new
    local fall_count = 0

    local function check_clicked()
        if this.ui.clicked then
            if this.gold then
                store.player_gold = store.player_gold + this.gold
            end

            S:queue(this.sound_events.save)
            U.y_animation_play(this, "save", nil, store.tick_ts)
            queue_remove(store, this)

            if this.achievement then
                -- AC:got(this.achievement)
            end

            if this.achievement_inc then
                -- AC:inc_check(this.achievement_inc)
            end

            return
        end
    end

    ::label_514_0::

    this.ui.clicked = nil
    this.pos = P:node_pos(this.nav_path)

    U.animation_start(this, "travel", nil, store.tick_ts, true)

    while true do
        check_clicked()

        next, new = P:next_entity_node(this, store.tick_length)

        if next == nil then
            break
        end

        local remaining_nodes = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

        if fall_count == 1 and this.sink_nodes and remaining_nodes <= this.sink_nodes then
            break
        end

        U.set_destination(this, next)
        U.walk(this, store.tick_length)
        coroutine.yield()
    end

    if fall_count < this.falls then
        fall_count = fall_count + 1

        U.animation_start(this, "fall", nil, store.tick_ts, true)

        if fall_count == 1 then
            this.tween.ts = store.tick_ts
            this.tween.disabled = nil
            this.tween.props[1].keys = this.fall_1_tween
        end

        this.nav_path.pi = this.nav_path.pi + 1
        this.nav_path.ni = 1

        local normal_speed = this.motion.max_speed
        local fall_dest = P:node_pos(this.nav_path)

        U.update_max_speed(this, V.dist(fall_dest.x, fall_dest.y, this.pos.x, this.pos.y) / this.fall_time)

        U.set_destination(this, fall_dest)

        while not U.walk(this, store.tick_length) do
            coroutine.yield()
        end
        U.update_max_speed(this, normal_speed)

        if fall_count == 1 then
            S:queue(this.sound_events.fall)
            U.y_wait(store, this.fall_wait)

            this.tween.ts = store.tick_ts
            this.tween.disabled = nil
            this.tween.props[1].keys = this.travel_2_tween

            goto label_514_0
        else
            S:queue(this.sound_events.crash)
            U.y_animation_play(this, "crash", nil, store.tick_ts)
            queue_remove(store, this)
        end
    else
        S:queue(this.sound_events.sink)
        U.y_animation_play(this, "sink", nil, store.tick_ts)
        queue_remove(store, this)
    end
end

scripts.decal_george_jungle = {}

function scripts.decal_george_jungle.update(this, store)
    local clicks = 0
    local max_clicks = math.random(this.final_clicks[1], this.final_clicks[2])
    local play_ts = store.tick_ts
    local play_time = U.frandom(this.play_time[1], this.play_time[2])
    local sid_liana, sid_fall, sid_bush = 1, 2, 3
    local s_liana, s_fall, s_bush = this.render.sprites[1], this.render.sprites[2], this.render.sprites[3]
    local dx = store.visible_coords.right - REF_W
    local ox, oy = s_liana.offset.x, s_liana.offset.y

    this.tween.props[2].keys[1][2] = V.v(ox + dx, oy)
    this.tween.props[2].keys[2][2] = V.v(ox, oy)
    s_liana.offset.x, s_liana.offset.y = ox + dx, oy

    local rect = this.ui.click_rect

    rect.pos.x = ox + dx + 60
    rect.pos.y = REF_H - rect.size.y

    while true do
        if this.ui.clicked then
            clicks = clicks + 1

            if max_clicks <= clicks then
                S:queue("ElvesSpecialGeorgeFall")

                this.tween.ts = store.tick_ts
                this.tween.disabled = nil

                U.y_wait(store, this.tween.props[1].keys[2][1])
                U.y_animation_play(this, "start", nil, store.tick_ts, 1, sid_liana)
                U.animation_start(this, "release", nil, store.tick_ts, false, sid_liana)

                s_fall.hidden = nil

                U.animation_start(this, "fall", nil, store.tick_ts, false, sid_fall)
                U.y_animation_wait(this, sid_liana)

                s_liana.hidden = true

                U.y_animation_wait(this, sid_fall)

                s_fall.hidden = true

                U.y_animation_play(this, "play", nil, store.tick_ts, 1, sid_bush)
                U.animation_start(this, "idle", nil, store.tick_ts, true, sid_bush)
                -- AC:got(this.achievement)

                break
            else
                U.y_animation_play(this, "click", nil, store.tick_ts, 1, sid_liana)
                U.animation_start(this, "idle", nil, store.tick_ts, true, sid_liana)
            end

            this.ui.clicked = nil
            play_ts = store.tick_ts
        end

        if play_time < store.tick_ts - play_ts then
            play_ts = store.tick_ts
            play_time = U.frandom(this.play_time[1], this.play_time[2])

            U.y_animation_play(this, "click", nil, store.tick_ts, 1, sid_liana)
            U.animation_start(this, "idle", nil, store.tick_ts, true, sid_liana)

            this.ui.clicked = nil
        end

        coroutine.yield()
    end
end

scripts.decal_tree_ewok = {}

function scripts.decal_tree_ewok.update(this, store)
    local a = this.ranged.attacks[1]

    a.ts = store.tick_ts

    local wait_ts = -this.wait_time

    this.nav_path.pi = this.path_id
    this.nav_path.spi = 1
    this.nav_path.ni = 1
    this.pos = P:node_pos(this.nav_path)

    while true do
        if store.tick_ts - a.ts > a.cooldown then
            local target = U.find_random_enemy(store.enemies, this.ranged_center, a.min_range, a.max_range,
                a.vis_flags, a.vis_bans)

            if target then
                a.ts = store.tick_ts

                local node_offset = P:predict_enemy_node_advance(target, prediction_time)
                local pred_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
                local start_ts = store.tick_ts
                local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)

                U.animation_start(this, an, af, store.tick_ts, false)
                S:queue(a.sound)
                U.y_wait(store, a.shoot_time)

                local bo = a.bullet_start_offset[ai]
                local b = E:create_entity(a.bullet)

                b.pos = V.v(this.pos.x + bo.x, this.pos.y + bo.y)
                b.bullet.to = V.v(pred_pos.x + target.unit.hit_offset.x, pred_pos.y + target.unit.hit_offset.y)
                b.bullet.from = V.vclone(b.pos)
                b.bullet.target_id = target.id
                b.bullet.source_id = this.id

                queue_insert(store, b)
                U.y_animation_wait(this)
            end
        end

        if store.tick_ts - wait_ts > this.wait_time then
            U.y_animation_play(this, table.random(this.dance_animations), nil, store.tick_ts, 2)

            while SU.y_enemy_walk_step(store, this) do
                coroutine.yield()
            end

            this.nav_path.dir = -1 * this.nav_path.dir
            wait_ts = store.tick_ts
        end

        U.animation_start(this, "idle", false, store.tick_ts, true)
        coroutine.yield()
    end
end

scripts.tower_ewok_holder = {}

function scripts.tower_ewok_holder.get_info()
    local tpl = E:get_template("tower_ewok")
    local o = scripts.tower_barrack.get_info(tpl)

    o.respawn = nil

    return o
end

scripts.soldier_ewok = {}

function scripts.soldier_ewok.update(this, store)
    local brk, sta

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    while true do
        for pn, p in pairs(this.powers) do
            if p.changed then
                p.changed = nil
                SU.soldier_power_upgrade(this, pn)
            end
        end

        if this.health.dead then
            SU.y_soldier_death(store, this)
            return
        end

        if this.unit.is_stunned then
            SU.soldier_idle(store, this)
        else
            if this.dodge and this.dodge.active then
                local start_ts = store.tick_ts

                U.y_animation_play(this, this.dodge.animation_start, nil, store.tick_ts, 1)

                this.dodge.last_hit_ts = nil
                this.health.immune_to = F_ALL
                scripts.heal(this, this.dodge.heal)
                while store.tick_ts - start_ts < this.dodge.duration and not this.health.dead and
                    not this.unit.is_stunned do
                    SU.soldier_regen(store, this)

                    if this.dodge.last_hit_ts then
                        U.y_animation_play(this, this.dodge.animation_hit, nil, store.tick_ts, 1)

                        this.dodge.last_hit_ts = nil
                    end

                    coroutine.yield()
                end

                U.y_animation_play(this, this.dodge.animation_end, nil, store.tick_ts, 1)

                this.dodge.active = false
                this.health.immune_to = 0
                this.dodge.ts = store.tick_ts

                goto label_519_1
            end

            while this.nav_rally.new do
                if SU.y_soldier_new_rally(store, this) then
                    goto label_519_1
                end
            end

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                goto label_519_1
            end

            brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

            if brk or sta ~= A_NO_TARGET then
                goto label_519_1
            end

            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk or sta == A_DONE then
                goto label_519_1
            elseif sta == A_IN_COOLDOWN then
                goto label_519_0
            end


            if SU.soldier_go_back_step(store, this) then
                goto label_519_1
            end

            ::label_519_0::

            SU.soldier_idle(store, this)
            SU.soldier_regen(store, this)
        end

        ::label_519_1::

        coroutine.yield()
    end
end

scripts.decal_bush_statue = {}

function scripts.decal_bush_statue.insert(this, store)
    local d = store.ephemeral

    if not d.bush_indexes then
        local indexes = {}

        for i = 1, #this.bush_frames do
            table.insert(indexes, i)
        end

        local match_idx = math.random(1, #indexes)

        table.remove(indexes, match_idx)

        d.bush_match_idx = match_idx
        d.bush_indexes = indexes
        d.bush_start_idx = math.random(1, 3)
    end

    this.bush_indexes = {d.bush_match_idx, table.remove(d.bush_indexes, math.random(1, #d.bush_indexes)),
                         table.remove(d.bush_indexes, math.random(1, #d.bush_indexes))}
    this.bush_match_idx = 1
    this.bush_idx = d.bush_start_idx
    d.bush_start_idx = km.zmod(d.bush_start_idx + 1, #this.bush_indexes)
    this.render.sprites[1].name = this.bush_frame_prefix .. this.bush_frames[this.bush_indexes[this.bush_idx]]

    return true
end

function scripts.decal_bush_statue.update(this, store)
    while true do
        if this.ui.clicked then
            local fx = E:create_entity("fx_bush_statue_click")

            fx.pos = this.pos
            fx.render.sprites[1].ts = store.tick_ts

            queue_insert(store, fx)
            U.y_wait(store, fts(5))

            this.bush_idx = km.zmod(this.bush_idx + 1, #this.bush_indexes)

            local frame = this.bush_frame_prefix .. this.bush_frames[this.bush_indexes[this.bush_idx]]

            this.render.sprites[1].name = frame

            if this.bush_idx == this.bush_match_idx then
                local all_bushes = table.filter(store.entities, function(k, v)
                    return v.template_name == this.template_name
                end)

                for _, e in pairs(all_bushes) do
                    if e.bush_idx ~= e.bush_match_idx then
                        goto label_521_0
                    end
                end

                -- AC:got("SCISSOR_FINGER")
            end

            ::label_521_0::

            this.ui.clicked = nil
        end

        coroutine.yield()
    end
end

scripts.soldier_gryphon_guard = {}

function scripts.soldier_gryphon_guard.upper_ranged_filter_fn(e, origin)
    return U.is_inside_ellipse(e.pos, V.v(300, 627), 125, 0.64) or
               U.is_inside_ellipse(e.pos, V.v(560, 382), 95, 0.5263157894736842)
end

function scripts.soldier_gryphon_guard.lower_ranged_filter_fn(e, origin)
    return U.is_inside_ellipse(e.pos, V.v(275, 454), 175, 0.7714285714285715) or
               U.is_inside_ellipse(e.pos, V.v(530, 376), 150, 0.36666666666666664)
end

scripts.aura_soldier_gryphon_guard_upper = {}

function scripts.aura_soldier_gryphon_guard_upper.update(this, store)
    while true do
        local target = store.entities[this.aura.source_id]

        if not target then
            queue_remove(store, this)

            return
        end

        local attack = target.ranged.attacks[1]
        local cooldown = U.frandom(this.patch_cooldown_min, this.patch_cooldown_max)

        attack.cooldown = cooldown

        U.y_wait(store, cooldown + fts(1))
    end
end

scripts.aura_soldier_gryphon_guard_lower = {}

function scripts.aura_soldier_gryphon_guard_lower.update(this, store)
    local target = store.entities[this.aura.source_id]

    if not target then
        queue_remove(store, this)

        return
    end

    local attack = target.ranged.attacks[1]
    local hidden = true
    local last_show_ts = 0

    target.pos.x, target.pos.y = this.hide_pos.x, this.hide_pos.y
    target.nav_rally.pos = this.hide_pos
    target.nav_rally.center = this.hide_pos
    target.tween.reverse = true
    target.tween.ts = -1

    while store.wave_group_number < 1 do
        coroutine.yield()
    end

    while true do
        if hidden then
            U.y_wait(store, U.frandom(this.hidden_min, this.hidden_max))

            target.tween.reverse = false
            target.tween.ts = store.tick_ts
            target.nav_rally.pos = this.show_pos
            target.nav_rally.center = this.show
            target.nav_rally.new = true

            coroutine.yield()

            while not target.motion.arrived do
                coroutine.yield()
            end

            hidden = false
            last_show_ts = store.tick_ts
            attack.disabled = nil
        elseif store.tick_ts - math.max(attack.ts, last_show_ts) > this.idle_time_to_hide then
            attack.disabled = true
            target.tween.reverse = true
            target.tween.ts = store.tick_ts
            target.nav_rally.pos = this.hide_pos
            target.nav_rally.center = this.hide_pos
            target.nav_rally.new = true

            coroutine.yield()

            while not target.motion.arrived do
                coroutine.yield()
            end

            hidden = true
        end

        coroutine.yield()
    end
end

scripts.decal_gryphon = {}

function scripts.decal_gryphon.update(this, store)
    local flip_x = this.side == "right"
    local flip_sign = flip_x and -1 or 1
    local at = this.attacks.list[1]
    local bso = V.v(at.bullet_start_offset.x * flip_sign, at.bullet_start_offset.y)
    local beo = V.v(bso.x + 100 * flip_sign, bso.y - 140)
    local c = this.custom[this.side]
    local initial_curve = P:nodes_as_list(c.initial_curve_id)
    local default_curve = P:nodes_as_list(c.default_curve_id)
    local approach_curve = P:nodes_as_list(c.land_curve_id)
    local idle_pos = V.v(default_curve[1], default_curve[2])
    local approach_offset = V.v(-152 * flip_sign, 15)
    local default_offset = V.v(0, 0)
    local shadow_default_offset = V.v(94 * flip_sign, 0)
    local shadow_approach_offset = V.v(-28 - 30 * flip_sign, 60)
    local flash_offset = V.v(104 * flip_sign, -23)
    local sign_hidden_time = 5
    local sign_shown_time = 1
    local sign = E:create_entity("decal_gryphon_sign")

    sign.pos.x, sign.pos.y = idle_pos.x + flip_sign * 64, idle_pos.y + 5
    sign.render.sprites[1].flip_x = flip_x
    sign.tween.reverse = true
    sign.tween.ts = -1

    queue_insert(store, sign)

    this.render.sprites[4].offset = flash_offset

    local first_pass = true

    while true do
        this.render.sprites[3].offset = shadow_default_offset
        this.render.sprites[3].hidden = false

        U.animation_start_group(this, "fly", flip_x, store.tick_ts, true, "layers")

        local bez = love.math.newBezierCurve(first_pass and initial_curve or default_curve)
        local start_ts = store.tick_ts
        local t = 0
        local ari, ar = next(c.attack_ranges)
        local phase = 1

        while t <= 1 do
            this.pos.x, this.pos.y = bez:evaluate(t)
            t = (store.tick_ts - start_ts) / (first_pass and c.initial_duration or c.default_duration)

            if phase == 1 and flip_sign * this.pos.x > flip_sign * ar[1] then
                phase = phase + 1

                S:queue("ElvesGryphonsShoot")
                U.animation_start_group(this, "attack_start", flip_x, store.tick_ts, false, "layers")
            elseif phase == 2 and U.animation_finished(this) then
                phase = phase + 1

                U.animation_start_group(this, "attack_loop", flip_x, store.tick_ts, true, "layers")
            elseif phase == 3 then
                if flip_sign * this.pos.x > flip_sign * ar[2] then
                    this.render.sprites[4].hidden = true
                    ari, ar = next(c.attack_ranges, ari)
                    phase = ar and 1 or phase + 1

                    U.animation_start_group(this, "attack_end", flip_x, store.tick_ts, false, "layers")
                    S:queue("ElvesGryphonsShootEnd")
                elseif flip_sign * this.pos.x > flip_sign * ar[1] and store.tick_ts - at.ts >= at.cooldown then
                    at.ts = store.tick_ts
                    this.render.sprites[4].hidden = nil
                    this.render.sprites[4].ts = store.tick_ts

                    for i = 1, at.loops do
                        local b = E:create_entity(at.bullet)

                        b.pos.x, b.pos.y = this.pos.x + bso.x, this.pos.y + bso.y
                        b.bullet.from = V.v(b.pos.x, b.pos.y)
                        b.bullet.to = V.v(this.pos.x + beo.x + U.frandom(-20, 20),
                            this.pos.y + beo.y + U.frandom(-30, 30))
                        b.initial_impulse = U.frandom(0, 1000) * 30

                        queue_insert(store, b)
                    end
                end
            elseif phase == 4 and U.animation_finished(this) then
                phase = phase + 1

                U.animation_start_group(this, "fly", flip_x, store.tick_ts, true, "layers")
            end

            coroutine.yield()
        end

        U.y_wait(store, first_pass and 0 or this.cooldown)

        first_pass = false
        this.render.sprites[1].offset = approach_offset
        this.render.sprites[2].offset = approach_offset
        this.render.sprites[3].offset = shadow_approach_offset

        local bez = love.math.newBezierCurve(approach_curve)
        local start_ts = store.tick_ts
        local t = 0

        while t <= 1 do
            this.pos.x, this.pos.y = bez:evaluate(t)
            t = (store.tick_ts - start_ts) / c.approach_duration

            coroutine.yield()
        end

        this.render.sprites[1].offset = default_offset
        this.render.sprites[2].offset = default_offset
        this.render.sprites[3].hidden = true

        S:queue("ElvesGryphonsLand")

        this.pos.x, this.pos.y = idle_pos.x, idle_pos.y

        U.y_animation_play_group(this, "land", flip_x, store.tick_ts, 1, "layers")
        U.animation_start_group(this, "idle", flip_x, store.tick_ts, true, "layers")

        this.ui.clicked = nil

        while not this.ui.clicked do
            local sign_cooldown = sign.tween.reverse and sign_hidden_time or sign_shown_time

            if sign_cooldown < store.tick_ts - sign.tween.ts then
                sign.tween.reverse = not sign.tween.reverse
                sign.tween.ts = store.tick_ts
            end

            coroutine.yield()
        end

        sign.tween.reverse = true
        sign.tween.ts = -1

        S:queue("ElvesGryphonsTakeOff")
        U.y_animation_play_group(this, "takeoff", flip_x, store.tick_ts, 1, "layers")
    end
end

scripts.bullet_gryphon = {}

function scripts.bullet_gryphon.update(this, store)
    local b = this.bullet
    local speed = b.max_speed

    this.render.sprites[1].ts = store.tick_ts

    while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) >= 2 * (speed * store.tick_length) do
        coroutine.yield()

        b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
        this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
        this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
    end

    local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

    if targets then
        for _, target in pairs(targets) do
            local d = SU.create_bullet_damage(b, target.id, this.id)

            queue_damage(store, d)
        end
    end

    this.render.sprites[1].hidden = true

    if b.hit_fx then
        local fx = E:create_entity(b.hit_fx)

        fx.pos.x, fx.pos.y = b.to.x, b.to.y
        fx.render.sprites[1].ts = store.tick_ts
        fx.render.sprites[1].runs = 0

        queue_insert(store, fx)
    end

    if b.hit_decal then
        local decal = E:create_entity(b.hit_decal)

        decal.pos = V.vclone(b.to)
        decal.render.sprites[1].ts = store.tick_ts

        queue_insert(store, decal)
    end

    queue_remove(store, this)
end

scripts.gryphon_controller = {}

function scripts.gryphon_controller.update(this, store)
    local cwi, cw = 0
    local wts = store.tick_ts

    ::label_529_0::

    while true do
        cwi, cw = next(this.gryphon_waves, cwi)

        if not cw then
            break
        end

        while store.wave_group_number < cw.wave do
            coroutine.yield()

            wts = store.tick_ts
        end

        while store.tick_ts - wts < cw.delay do
            if store.wave_group_number ~= cw.wave then
                goto label_529_0
            end

            coroutine.yield()
        end

        local e = E:create_entity("decal_gryphon")

        e.cooldown = cw.cooldown
        e.side = cw.side

        LU.queue_insert(store, e)
    end

    queue_remove(store, this)
end

scripts.decal_s08_magic_bean = {}

function scripts.decal_s08_magic_bean.update(this, store)
    local delay = U.frandom(5, 10)
    local step = 1
    local start_ts

    ::label_530_0::

    start_ts = store.tick_ts

    if step == 4 then
        S:queue("ElvesBeanGrowLoop")
    elseif step > 1 then
        S:queue("ElvesBeanGrow")
    end

    U.animation_start(this, "step" .. step, nil, store.tick_ts, false)

    while not U.animation_finished(this) do
        if step == 4 and store.tick_ts - start_ts >= fts(60) then
            S:stop("ElvesBeanGrowLoop")

            goto label_530_1
        end

        coroutine.yield()
    end

    this.ui.clicked = nil

    while not this.ui.clicked do
        if step == 1 and delay < store.tick_ts - start_ts then
            start_ts = store.tick_ts
            delay = U.frandom(5, 10)

            U.animation_start(this, "step" .. step, nil, store.tick_ts, false)
        end

        coroutine.yield()
    end

    step = step + 1

    goto label_530_0

    ::label_530_1::

    U.y_wait(store, 4)

    store.player_gold = store.player_gold + this.reward_gold

    local fx = E:create_entity(this.reward_fx)

    fx.render.sprites[1].ts = store.tick_ts
    fx.pos.x, fx.pos.y = this.pos.x + 38, this.pos.y

    queue_insert(store, fx)
    -- AC:got(this.achievement_id)

    while true do
        coroutine.yield()
    end
end

scripts.decal_s08_peakaboo = {}

function scripts.decal_s08_peakaboo.update(this, store)
    local s = this.render.sprites[1]

    ::label_531_0::

    s.hidden = true

    U.y_wait(store, U.frandom(30, 40))

    s.hidden = false

    if this.pos_list then
        this.pos = table.random(this.pos_list)
    end

    U.y_animation_play(this, "in", nil, store.tick_ts)

    this.ui.clicked = nil

    if U.y_wait(store, U.frandom(2, 4), function(store, time)
        return this.ui.clicked
    end) then
        -- block empty
    else
        U.y_animation_play(this, "out", nil, store.tick_ts)

        goto label_531_0
    end

    S:queue(this.sound)
    U.y_animation_play(this, "action", nil, store.tick_ts)
    -- AC:flag_check(unpack(this.achievement_flag))
    queue_remove(store, this)
end

scripts.decal_s08_hansel_gretel = {}

function scripts.decal_s08_hansel_gretel.update(this, store)
    local witch_clicks = 0
    local door_sid = 2
    local start_ts
    local witch = E:create_entity("decal_s08_witch")

    witch.inside_pos = V.v(this.pos.x + 37, this.pos.y - 45)
    witch.outside_pos = V.v(this.pos.x + 70, this.pos.y - 76)
    witch.pos.x, witch.pos.y = witch.inside_pos.x, witch.inside_pos.y
    witch.render.sprites[1].hidden = true
    witch.ui.can_click = false

    queue_insert(store, witch)

    ::label_533_0::

    this.ui.clicked = nil

    while not this.ui.clicked do
        coroutine.yield()
    end

    S:queue("GUITowerOpenDoor")
    U.animation_start(this, "open", nil, store.tick_ts, false, door_sid)
    U.y_wait(store, 0.8)

    witch.render.sprites[1].hidden = nil
    witch.ui.can_click = true

    U.animation_start(witch, "walk", false, store.tick_ts, true)
    U.set_destination(witch, witch.outside_pos)

    while not witch.motion.arrived do
        U.walk(witch, store.tick_length)
        coroutine.yield()
    end

    S:queue("ElvesWitchOutside")
    U.y_animation_play(witch, "angry", nil, store.tick_ts)

    start_ts = store.tick_ts
    witch.ui.clicked = nil

    while store.tick_ts - start_ts < 3 do
        if witch.ui.clicked then
            S:queue("ElvesWitchTouch")

            witch.ui.clicked = nil
            witch_clicks = witch_clicks + 1

            if witch_clicks >= 10 then
                goto label_533_1
            else
                U.y_animation_play(witch, "click", nil, store.tick_ts)
            end
        end

        coroutine.yield()
    end

    U.animation_start(witch, "walk", true, store.tick_ts, true)
    U.set_destination(witch, witch.inside_pos)

    while not witch.motion.arrived do
        U.walk(witch, store.tick_length)
        coroutine.yield()
    end

    witch.render.sprites[1].hidden = true
    witch.ui.can_click = false

    S:queue("GUITowerOpenDoor")
    U.animation_start(this, "close", nil, store.tick_ts, false, door_sid)
    U.y_wait(store, 0.8)

    goto label_533_0

    ::label_533_1::

    S:queue("ElvesWitchDeath")
    U.y_animation_play(witch, "die", nil, store.tick_ts)
    S:queue("ElvesHanselAndGretelEscape")

    for _, n in pairs({"hansel", "gretel"}) do
        local e = E:create_entity("decal_s08_" .. n)

        e.pos.x, e.pos.y = this.pos.x, this.pos.y
        e.tween.ts = store.tick_ts

        queue_insert(store, e)
    end

    -- AC:got("CANDY_RUSH")
end

scripts.aura_waterfall_entrance = {}

function scripts.aura_waterfall_entrance.update(this, store)
    local show_queue = {}

    while true do
        for _, e in pairs(store.enemies) do
            if e.nav_path and e._waterfall_entrance_done ~= true then
                for _, item in pairs(this.waterfall_nodes) do
                    local pi, nin, nout = item.path_id, item.from, item.to

                    if pi ~= e.nav_path.pi then
                        -- block empty
                    elseif e.nav_path.ni == nin and e._waterfall_entrance_done == nil then
                        e._waterfall_entrance_done = false

                        U.sprites_hide(e)

                        if e.health_bar then
                            e.health_bar.hidden = true
                        end
                    elseif e.nav_path.ni == nout and e._waterfall_entrance_done == false then
                        e._waterfall_entrance_done = true

                        local fx = E:create_entity(this.show_fx)

                        fx.pos.x, fx.pos.y = e.pos.x, e.pos.y - 3
                        fx.render.sprites[1].ts = store.tick_ts

                        queue_insert(store, fx)
                        table.insert(show_queue, e)
                    end
                end
            end
        end

        coroutine.yield()

        for i = #show_queue, 1, -1 do
            local e = show_queue[i]

            U.sprites_show(e)

            if e.health_bar then
                e.health_bar.hidden = nil
            end

            table.remove(show_queue, i)
        end
    end
end

scripts.decal_s09_crystal_serpent_attack = {}

function scripts.decal_s09_crystal_serpent_attack.update(this, store)
    local hids = this.holder_ids
    local towers_by_idx = {}

    for _, e in E:filter_iter(store.entities, "tower") do
        for i, hid in ipairs(hids) do
            if e.tower.holder_id == hid then
                towers_by_idx[i] = e

                log.debug(" tower %s holder:%s pos_y:%s", i, e.tower.holder_id, e.pos.y)
            end
        end
    end

    S:queue("ElvesCrystalSerpentEmerge")
    U.animation_start(this, "spawn", this.flip_x, store.tick_ts, false)
    U.y_animation_wait(this)
    S:queue("ElvesCrystalSerpentAttack", {
        delay = fts(5)
    })
    U.animation_start(this, "shootSmoke", this.flip_x, store.tick_ts, false)
    U.y_wait(store, fts(13))

    local first_dest = towers_by_idx[1].pos

    for i = 1, 3 do
        local target = towers_by_idx[i]
        local b = E:create_entity("bullet_crystal_serpent")

        b.bullet.target_id = target.id
        b.pos = this.flip_x and V.v(this.pos.x - 30, this.pos.y - 17) or V.v(this.pos.x + 33, this.pos.y - 13)
        b.bullet.from = V.vclone(b.pos)

        if i == 1 then
            b.bullet.to = V.v(first_dest.x, first_dest.y)
        else
            b.bullet.to = V.v((first_dest.x + target.pos.x) / 2, (first_dest.y + target.pos.y) / 2)
        end

        queue_insert(store, b)

        if i == 1 then
            U.y_wait(store, fts(3))
        end
    end

    U.y_animation_wait(this)
    S:queue("ElvesCrystalSerpentSubmerge", {
        delay = fts(8)
    })
    U.y_animation_play(this, "dive", this.flip_x, store.tick_ts)
    queue_remove(store, this)
end

scripts.decal_s09_crystal_serpent_scream = {}

function scripts.decal_s09_crystal_serpent_scream.update(this, store)
    S:queue("ElvesCrystalSerpentEmerge")
    U.animation_start(this, "spawn", this.flip_x, store.tick_ts, false, 1)

    this.render.sprites[3].hidden = false

    U.animation_start(this, "waterWaves", this.flip_x, store.tick_ts, true, 3)
    U.y_animation_wait(this)
    S:queue("ElvesCrystalSerpentScream")

    this.render.sprites[2].hidden = false

    U.animation_start(this, "superScream", this.flip_x, store.tick_ts, false, 1)
    U.animation_start(this, "superScreamRays", this.flip_x, store.tick_ts, false, 2)
    U.y_animation_wait(this)

    this.render.sprites[2].hidden = true

    S:queue("ElvesCrystalSerpentSubmerge", {
        delay = fts(8)
    })
    U.animation_start(this, "dive", this.flip_x, store.tick_ts, false, 1)
    U.y_wait(store, fts(19))

    this.render.sprites[3].hidden = true

    U.y_animation_wait(this)
    queue_remove(store, this)
end

scripts.bullet_crystal_serpent = {}

function scripts.bullet_crystal_serpent.update(this, store)
    local b = this.bullet

    b.ts = store.tick_ts

    local psf = E:create_entity(b.particles_name)

    psf.particle_system.track_id = this.id

    queue_insert(store, psf)

    while store.tick_ts - b.ts + store.tick_length <= b.flight_time do
        coroutine.yield()

        local phase = km.clamp(0, 1, (store.tick_ts - b.ts) / b.flight_time)

        this.pos.x = b.from.x + (b.to.x - b.from.x) * phase
        this.pos.y = b.from.y + (b.to.y - b.from.y) * phase
    end

    psf.particle_system.emit = false

    local target = store.entities[b.target_id]

    if target then
        local psh = E:create_entity("ps_bullet_crystal_serpent_hit")

        psh.pos.x, psh.pos.y = target.pos.x, target.pos.y + 20
        psh.particle_system.emit = true

        queue_insert(store, psh)
        U.y_wait(store, fts(7))

        psh.particle_system.emit = false
    end

    local wait_time

    if target and target.tower and target.tower.can_be_mod and not target.tower.blocked then
        local m = E:create_entity(b.mod)

        m.modifier.target_id = b.target_id
        m.pos.x, m.pos.y = target.pos.x, target.pos.y
        wait_time = m.modifier.duration

        queue_insert(store, m)
    end

    if wait_time then
        U.y_wait(store, wait_time)
        S:queue("ElvesCrystalSerpentBreakingCrystal")

        local s = E:create_entity("decal_s09_crystal_debris_mod")

        s.pos.x, s.pos.y = target.pos.x, target.pos.y

        U.animation_start(s, nil, nil, store.tick_ts)

        s.tween.ts = store.tick_ts

        queue_insert(store, s)
    end

    queue_remove(store, this)
end

scripts.aura_tower_faerie_dragon = {
    update = function(this, store, script)
        local last_ts = store.tick_ts
        while true do
            local source = store.entities[this.aura.source_id]
            if not source then
                queue_remove(store, this)
                return
            end
            if store.tick_ts - last_ts >= source.attacks.list[1].cooldown then
                last_ts = store.tick_ts
                local targets = table.filter(store.enemies, function(k, v)
                    return (not v.health.dead) and ((band(F_BOSS, v.vis.flags) == 0) and (band(bor(F_MOD, F_STUN), v.vis.bans) == 0)) and U.is_inside_ellipse(v.pos, this.pos, source.attacks.range)
                end)

                if targets then
                    for _, target in pairs(targets) do
                        if math.random() < source.aura_rate then
                            local mod = E:create_entity(this.aura.mod)
                            mod.modifier.target_id = target.id
                            mod.modifier.source_id = this.aura.source_id
                            queue_insert(store, mod)
                            local d = E:create_entity("damage")
                            d.source_id = source.id
                            d.target_id = target.id
                            d.value = this.aura.damage * source.tower.damage_factor
                            d.damage_type = this.aura.damage_type
                            queue_damage(store, d)
                        end
                    end
                end
            end
            coroutine.yield()
        end
    end
}


scripts.faerie_dragon = {}

function scripts.faerie_dragon.update(this, store)
    local sp = this.render.sprites[1]
    local fm = this.force_motion
    local ca = this.custom_attack
    local dest = V.vclone(this.idle_pos)
    local pred_pos, dist

    local function force_move_step(dest, max_speed, ramp_radius)
        local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
        local dist = V.len(dx, dy)
        local df = (not ramp_radius or ramp_radius < dist) and 1 or math.max(dist / ramp_radius, 0.1)

        fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(495, V.mul(10 * df, dx, dy)))
        fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
        fm.v.x, fm.v.y = V.trim(max_speed, fm.v.x, fm.v.y)
        this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
        fm.a.x, fm.a.y = V.mul(-0.05 / store.tick_length, fm.v.x, fm.v.y)
        sp.flip_x = this.pos.x > dest.x
    end

    ca.ts = store.tick_ts
    sp.offset.y = this.flight_height

    log.debug(">>>>>>>>> START")
    U.y_animation_play(this, "rise", nil, store.tick_ts)
    log.debug(">>>>>>>>> DONE")

    while true do
        if ca.target_id ~= nil and store.tick_ts - ca.ts > ca.cooldown then
            ca.ts = store.tick_ts

            local an, af, ai, fx
            local target = store.entities[ca.target_id]

            if not target or target.health.dead then
                -- block empty
            else
                an, af, ai = U.animation_name_facing_point(this, "fly", target.pos)

                U.animation_start(this, an, af, store.tick_ts, true)

                repeat
                    target = store.entities[ca.target_id]

                    if not target or target.health.dead then
                        goto label_542_0
                    end

                    dist = V.dist(this.pos.x, this.pos.y, target.pos.x, target.pos.y)
                    pred_pos = P:predict_enemy_pos(target, dist / this.flight_speed_busy)
                    dest.x, dest.y = pred_pos.x, pred_pos.y

                    force_move_step(dest, this.flight_speed_busy)
                    coroutine.yield()
                until dist < 30 or ca.target_id == nil

                if not sp.sync_flag then
                    coroutine.yield()
                end

                S:queue(ca.sound)

                an, af, ai = U.animation_name_facing_point(this, ca.animation, pred_pos)

                U.animation_start(this, an, af, store.tick_ts, false)

                fx = E:create_entity("fx_faerie_dragon_shoot")
                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                fx.render.sprites[1].ts = store.tick_ts
                fx.render.sprites[1].flip_x = af
                fx.render.sprites[1].offset.y = sp.offset.y

                queue_insert(store, fx)
                U.y_wait(store, ca.shoot_time)

                do
                    local so = ca.bullet_start_offset[ai]
                    local b = E:create_entity(ca.bullet)

                    b.pos.x, b.pos.y = this.pos.x + (af and -1 or 1) * so.x, this.pos.y + this.flight_height + so.y
                    b.bullet.from = V.vclone(b.pos)
                    b.bullet.to = pred_pos
                    b.bullet.target_id = target.id
                    b.bullet.source_id = this.id
                    if not b.bullet.mods then
                        b.bullet.mods = {b.mods}
                    end
                    for i, modname in ipairs(b.bullet.mods) do
                        if modname == "mod_faerie_dragon" then
                            b.bullet.mods[i] =  "mod_faerie_dragon_l" .. this.owner.powers.improve_shot.level
                            break
                        end
                    end

                    b.bullet.damage_factor = this.owner.tower.damage_factor
                    queue_insert(store, b)
                end

                U.y_animation_wait(this)
            end

            ::label_542_0::

            ca.target_id = nil
            dest.x, dest.y = this.idle_pos.x, this.idle_pos.y
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true)

        if V.dist(dest.x, dest.y, this.idle_pos.x, this.idle_pos.y) > 43 or
            V.dist(dest.x, dest.y, this.pos.x, this.pos.y) < 10 then
            dest = U.point_on_ellipse(this.idle_pos, 30, U.frandom(0, 2 * math.pi))
        end

        force_move_step(dest, this.flight_speed_idle, this.ramp_dist_idle)
        coroutine.yield()
    end
end

scripts.simon_controller = {}

function scripts.simon_controller.update(this, store)
    local sign_cooldown, sign_ts, sign_step, touch_count, touch_ts
    local m1 = LU.list_entities(store.entities, "simon_mushroom_1")[1]
    local m2 = LU.list_entities(store.entities, "simon_mushroom_2")[1]
    local m3 = LU.list_entities(store.entities, "simon_mushroom_3")[1]
    local m4 = LU.list_entities(store.entities, "simon_mushroom_4")[1]
    local m0 = LU.list_entities(store.entities, "simon_gnome_mushrooom_glow")[1]
    local gnome = LU.list_entities(store.entities, "simon_gnome")[1]
    local ms = {
        [0] = m0,
        m1,
        m2,
        m3,
        m4
    }
    local glow_data = {
        gnome = {false, 1, {{0, 0}, {fts(9), 255}, {fts(18), 0}}},
        hint = {false, 1, {{0, 0}, {fts(9), 128}, {fts(18), 0}}},
        start = {false, 1, {{0, 0}, {fts(5), 255}, {fts(15), 255}, {fts(24), 0}}},
        touch = {true, 1, {{0, 0}, {fts(5), 255}, {fts(15), 255}, {fts(24), 0}}},
        seq = {true, 1, {{0, 0}, {fts(5), 255}, {fts(18), 255}, {fts(27), 0}}},
        win = {false, 1,
               {{fts(20), 0}, {fts(22), 255}, {fts(24), 170}, {fts(26), 255}, {fts(28), 170}, {fts(30), 255},
                {fts(32), 170}, {fts(34), 255}, {fts(36), 170}, {fts(38), 255}, {fts(40), 0}}},
        fail = {false, 2, {{fts(3), 0}, {fts(8), 255}, {fts(13), 255}, {fts(20), 0}}}
    }

    local function show_fx(name, delay)
        local fx = E:create_entity(name)

        fx.pos.x, fx.pos.y = gnome.pos.x, gnome.pos.y
        fx.render.sprites[1].ts = store.tick_ts + (delay or 0)

        queue_insert(store, fx)
    end

    local function glow(mi, id, overlap)
        for _, prop in pairs(ms[mi].tween.props) do
            prop.disabled = true
        end

        local has_sound, tween_id, keys = unpack(glow_data[id])
        local prop = ms[mi].tween.props[tween_id]

        prop.keys = keys
        prop.disabled = nil
        ms[mi].tween.ts = store.tick_ts

        if has_sound then
            S:queue(ms[mi].sound_events.touch)
        end

        if overlap then
            return keys[#keys][1] - fts(6)
        else
            return keys[#keys][1]
        end
    end

    local function glow_all(id)
        local delay

        for i = 1, #ms do
            delay = glow(i, id)
        end

        return delay
    end

    local function clear_touches()
        for i = 0, #ms do
            ms[i].ui.clicked = nil
        end
    end

    local function get_touched()
        for i = 0, #ms do
            if ms[i].ui.clicked then
                clear_touches()

                touch_ts = store.tick_ts

                return i
            end
        end
    end

    local function extend_seq()
        local seq = this.seq

        ::label_550_0::

        local r = math.random(1, 4)

        if #seq > 0 and seq[#seq] == r then
            goto label_550_0
        end

        table.insert(seq, r)
    end

    local function reset_seq()
        this.seq = {}

        for i = 1, this.initial_sequence_length do
            extend_seq()
        end
    end

    while store.wave_group_number < 1 do
        coroutine.yield()
    end

    ::label_544_0::

    reset_seq()

    ::label_544_1::

    sign_ts = store.tick_ts
    sign_cooldown = U.frandom(3, 5)

    clear_touches()

    while get_touched() ~= 0 do
        if sign_cooldown < store.tick_ts - sign_ts then
            sign_ts = store.tick_ts
            sign_step = km.zmod((sign_step or 0) + 1, 3)

            if sign_step == 3 then
                show_fx("simon_gnome_sign")
            else
                glow(0, "hint")
            end
        end

        coroutine.yield()
    end

    glow(0, "gnome")
    S:queue("ElvesSimonActivate", {
        delay = fts(10)
    })
    show_fx("simon_gnome_fx", fts(29))
    U.animation_start(gnome, "play", nil, store.tick_ts, false)
    U.y_wait(store, fts(40))
    U.y_wait(store, glow_all("start") + 0.5)

    for _, id in pairs(this.seq) do
        U.y_wait(store, glow(id, "seq", true))
    end

    clear_touches()

    touch_count = 0

    while true do
        local id = get_touched()

        if id then
            if id == 0 then
                goto label_544_1
            end

            local delay = glow(id, "touch")

            U.y_wait(store, delay / 2)

            touch_count = touch_count + 1

            if id == this.seq[touch_count] then
                if touch_count == #this.seq then
                    U.y_wait(store, delay / 2)
                    glow_all("win")
                    S:queue("ElvesSimonActivate", {
                        delay = fts(10)
                    })
                    U.animation_start(gnome, "play", nil, store.tick_ts, false)
                    U.y_wait(store, fts(27))

                    local fx = E:create_entity("fx_coin_shower")

                    fx.coin_count = 5
                    fx.pos.x, fx.pos.y = gnome.pos.x - 4, gnome.pos.y + 10

                    queue_insert(store, fx)

                    store.player_gold = store.player_gold + this.reward_base + this.reward_inc *
                                            (#this.seq - this.initial_sequence_length)

                    U.y_animation_wait(gnome)

                    if #this.seq == this.achievement_count then
                        -- AC:got(this.achievement_id)
                    end

                    extend_seq()

                    goto label_544_1
                end
            else
                U.y_wait(store, delay / 2)
                S:queue("ElvesSimonWrong")
                U.y_wait(store, glow_all("fail"))

                goto label_544_0
            end
        end

        coroutine.yield()
    end
end

scripts.decal_s10_gnome = {}

function scripts.decal_s10_gnome.update(this, store)
    local s = this.render.sprites[1]
    local action, delay

    local function y_play(name, loops)
        loops = loops or 1

        U.animation_start(this, name, nil, store.tick_ts, loops > 1)

        while not U.animation_finished(this, nil, loops) do
            if this.ui.clicked then
                return true
            end

            coroutine.yield()
        end
    end

    local function y_walk(from, to, time)
        local an, af, ai = U.animation_name_facing_point(this, "walk", to)

        U.animation_start(this, an, af, store.tick_ts, true)

        local start_ts = store.tick_ts
        local phase = 0

        while phase < 1 do
            if this.ui.clicked then
                return true
            end

            phase = km.clamp(0, 1, (store.tick_ts - start_ts) / time)
            this.pos.x = from.x + phase * (to.x - from.x)
            this.pos.y = from.y + phase * (to.y - from.y)

            coroutine.yield()
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true)
    end

    s.flip_x = math.random() < 0.5

    ::label_552_0::

    this.ui.clicked = nil
    delay = U.frandom(this.min_delay, this.max_delay)

    if U.y_wait(store, delay, function()
        return this.ui.clicked
    end) then
        -- block empty
    else
        action = table.random(this.gnome_actions)

        if action == "guitar" then
            if y_play("guitarBegin") or y_play("guitarLoop", math.random(5, 10)) or y_play("guitarEnd") then
                goto label_552_1
            end
        elseif action == "diamond" then
            if y_play("diamond") then
                goto label_552_1
            end
        elseif action == "sleep" then
            if y_play("sleepBegin") or y_play("sleepLoop", math.random(5, 10)) or y_play("sleepEnd") then
                goto label_552_1
            end
        elseif action == "teleport" then
            U.y_animation_play(this, "teleportOut", nil, store.tick_ts, false)
            U.y_wait(store, U.frandom(5, 10))
            U.y_animation_play(this, "teleportIn", nil, store.tick_ts, false)
        elseif action == "flip" then
            s.flip_x = not s.flip_x
        elseif action == "walk" then
            local from, to = unpack(this.walk_points)

            if y_walk(from, to, this.walk_time) or U.y_wait(store, U.frandom(10, 15), function()
                return this.ui.clicked
            end) or y_walk(to, from, this.walk_time) then
                goto label_552_1
            end
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true)

        goto label_552_0
    end

    ::label_552_1::

    S:queue("ElvesGnomeDeathTaunt")
    U.y_animation_play(this, "explode", nil, store.tick_ts)
    -- AC:inc_check("GARGAMEL")
    U.y_wait(store, 25)

    if this.walk_points then
        this.pos.x, this.pos.y = this.walk_points[1].x, this.walk_points[1].y
    end

    U.y_animation_play(this, "teleportIn", nil, store.tick_ts, false)

    goto label_552_0
end

scripts.decal_faerie_crystal = {}

function scripts.decal_faerie_crystal.update(this, store)
    local current_color = "yellow"

    while true do
        if this.faerie_color and this.faerie_color ~= current_color then
            current_color = this.faerie_color

            U.y_wait(store, this.delay)

            this.tween.disabled = nil
            this.tween.ts = store.tick_ts
            this.tween.reverse = this.faerie_color ~= "red"
            this.render.sprites[3].name = this.faerie_color
            this.render.sprites[3].hidden = nil
            this.render.sprites[3].ts = store.tick_ts
        end

        coroutine.yield()
    end
end

scripts.faerie_trails = {}

function scripts.faerie_trails.insert(this, store)
    this.path_colors = {}
    this.sections = {}

    for pi = 1, #P.paths do
        this.path_colors[pi] = "none"

        local node_in
        local nodes = P.paths[pi][1]

        for ni = 1, #nodes do
            local npos = nodes[ni]

            if not node_in and GR:cell_is(npos.x, npos.y, TERRAIN_FAERIE) then
                node_in = ni
            elseif node_in and not GR:cell_is(npos.x, npos.y, TERRAIN_FAERIE) then
                table.insert(this.sections, {pi, node_in, ni})

                node_in = nil
            end
        end

        if node_in then
            table.insert(this.sections, {pi, node_in, ni})
        end
    end

    return true
end

function scripts.faerie_trails.update(this, store)
    local sections = this.sections

    local function is_inside_section(pi, ni)
        for _, s in pairs(sections) do
            if pi == s[1] and ni >= s[2] and ni < s[3] then
                return true
            end
        end

        return false
    end

    local function get_speed(pi)
        local path_speeds = this.path_speed_per_wave and this.path_speed_per_wave[pi]
        local speed_idx = path_speeds and path_speeds[store.wave_group_number] or 0
        local speed = this.path_speeds[speed_idx]

        return speed, speed_idx == 0 and "yellow" or "red"
    end

    while true do
        for pi = 1, #this.path_colors do
            local _, color = get_speed(pi)

            if this.path_colors[pi] ~= color then
                this.path_colors[pi] = color

                local crystals = table.filter(store.entities, function(_, e)
                    return e.template_name == "decal_faerie_crystal" and e.path_id == pi
                end)

                for _, c in pairs(crystals) do
                    c.faerie_color = color
                    c.faerie_color_ts = store.tick_ts
                end
            end
        end

        local enemies = table.filter(store.enemies, function(_, e)
            return e and e.enemy and not e.health.dead and e.main_script and e.main_script.co ~= nil and e.nav_path and
                       is_inside_section(e.nav_path.pi, e.nav_path.ni)
        end)

        for _, enemy in pairs(enemies) do
            local speed, color = get_speed(enemy.nav_path.pi)
            local fx = E:create_entity("fx_faerie_smoke")

            fx.pos.x, fx.pos.y = enemy.pos.x, enemy.pos.y
            fx.render.sprites[1].ts = store.tick_ts
            fx.render.sprites[1].scale = enemy.unit.size == UNIT_SIZE_SMALL and V.vv(0.83) or V.vv(1)
            fx.render.sprites[1].name = color

            queue_insert(store, fx)

            local f = E:create_entity("nav_faerie")

            f.pos.x, f.pos.y = enemy.pos.x, enemy.pos.y
            f.nav_path.pi, f.nav_path.spi, f.nav_path.ni = enemy.nav_path.pi, enemy.nav_path.spi, enemy.nav_path.ni
            U.update_max_speed(f, speed)
            f.enemy_size = enemy.unit.size
            f.enemy_offset = V.vclone(enemy.unit.mod_offset)
            f.faerie_color = color
            f.faerie_enemy = enemy

            queue_insert(store, f)
            SU.remove_modifiers(store, enemy)
            SU.remove_auras(store, enemy)
            queue_remove(store, enemy)
            U.unblock_all(store, enemy)

            if enemy.ui then
                enemy.ui.can_click = false
            end

            enemy.main_script.co = nil
            enemy.main_script.runs = 0

            if enemy.count_group then
                enemy.count_group.in_limbo = true
            end
        end

        local faeries = table.filter(store.entities, function(_, e)
            return e.template_name == "nav_faerie"
        end)

        for _, f in pairs(faeries) do
            local speed, color = get_speed(f.nav_path.pi)

            if is_inside_section(f.nav_path.pi, f.nav_path.ni) then
                if color ~= f.faerie_color then
                    U.update_max_speed(f, speed)
                    f.faerie_color = color
                end
            else
                queue_remove(store, f)

                local enemy = f.faerie_enemy

                enemy.pos.x, enemy.pos.y = f.pos.x, f.pos.y
                enemy.nav_path.pi, enemy.nav_path.spi, enemy.nav_path.ni = f.nav_path.pi, f.nav_path.spi, f.nav_path.ni
                enemy.main_script.runs = 1

                if enemy.ui then
                    enemy.ui.can_click = true
                end

                if enemy.health_bar then
                    enemy.health_bar.hidden = nil
                end

                enemy.health.ignore_damage = false

                U.sprites_show(enemy)
                SU.stun_dec(enemy, true)
                queue_insert(store, enemy)

                local fx = E:create_entity("fx_faerie_smoke")

                fx.pos.x, fx.pos.y = enemy.pos.x, enemy.pos.y
                fx.render.sprites[1].ts = store.tick_ts
                fx.render.sprites[1].scale = enemy.unit.size == UNIT_SIZE_SMALL and V.vv(0.83) or V.vv(1)
                fx.render.sprites[1].name = color

                queue_insert(store, fx)
            end
        end

        coroutine.yield()
    end
end

scripts.nav_faerie = {}

function scripts.nav_faerie.update(this, store)
    local enemy_is_small = this.enemy_size == UNIT_SIZE_SMALL
    local next, new, current_color
    local pss = {}

    pss.red = E:create_entity("ps_nav_faerie_red")
    pss.yellow = E:create_entity("ps_nav_faerie_yellow")
    pss.red.particle_system.emit = false
    pss.red.particle_system.track_id = this.id
    pss.yellow.particle_system.emit = false
    pss.yellow.particle_system.track_id = this.id

    queue_insert(store, pss.red)
    queue_insert(store, pss.yellow)

    for _, ps in pairs(pss) do
        ps.particle_system.scale_var = enemy_is_small and {0.5, 0.5}
        ps.particle_system.track_offset = this.enemy_offset
    end

    for i = 1, 4 do
        this.render.sprites[i].offset = this.enemy_offset
        this.render.sprites[i].scale = enemy_is_small and V.vv(0.5) or V.vv(1)
    end

    for i = 1, 2 do
        for _, v in pairs(this.tween.props[i].keys) do
            v[2].x = v[2].x * (enemy_is_small and 0.5 or 1)
            v[2].y = v[2].y * (enemy_is_small and 0.5 or 1)
        end
    end

    while true do
        if this.faerie_color ~= current_color then
            current_color = this.faerie_color
            pss.red.particle_system.emit = current_color == "red"
            pss.yellow.particle_system.emit = current_color == "yellow"
            this.render.sprites[1].hidden = current_color ~= "red"
            this.render.sprites[3].hidden = current_color ~= "red"
            this.render.sprites[2].hidden = current_color ~= "yellow"
            this.render.sprites[4].hidden = current_color ~= "yellow"
        end

        next, new = P:next_entity_node(this, store.tick_length)

        if not next then
            log.error("(%s)nav_faerie reached goal", this.id)

            break
        end

        U.set_destination(this, next)
        U.walk(this, store.tick_length)
        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.tower_pixie = {}

function scripts.tower_pixie.get_info(this)
    return {
        desc = "ELVES_TOWER_PIXIE_DESCRIPTION",
        type = STATS_TYPE_TEXT
    }
end

function scripts.tower_pixie.update(this, store)
    local a = this.attacks

    a.ts = store.tick_ts

    local pow_c = this.powers.cream
    local pow_t = this.powers.total
    local pixies = {}
    local enemy_cooldowns = {}

    local function spawn_pixie()
        local e = E:create_entity("decal_pixie")
        local po = pow_c.idle_offsets[#pixies + 1]

        e.idle_pos = po
        e.pos.x, e.pos.y = this.pos.x + po.x, this.pos.y + po.y
        e.owner = this

        table.insert(pixies, e)
        queue_insert(store, e)
    end

    spawn_pixie()

    while true do
        if this.tower.blocked then
            -- block empty
        else
            if pow_c.changed and #pixies < 3 then
                pow_c.changed = nil

                spawn_pixie()
            end

            if pow_t.changed then
                pow_t.changed = nil

                for i, ch in ipairs(pow_t.chances) do
                    a.list[i].chance = ch[pow_t.level]
                end
            end

            for k, v in pairs(enemy_cooldowns) do
                if v <= store.tick_ts then
                    enemy_cooldowns[k] = nil
                end
            end

            if store.tick_ts - a.ts > a.cooldown then
                for _, pixie in pairs(pixies) do
                    local target, attack
                    local rnd, acc = math.random(), 0

                    if pixie.target or store.tick_ts - pixie.attack_ts <= a.pixie_cooldown then
                        -- block empty
                    else
                        for ii, aa in ipairs(a.list) do
                            if aa.chance > 0 and rnd <= aa.chance + acc then
                                attack = aa

                                break
                            else
                                acc = acc + aa.chance
                            end
                        end

                        if not attack then
                            -- block empty
                        else
                            target = U.find_random_enemy(store.enemies, this.pos, 0, a.range, attack.vis_flags,
                                attack.vis_bans, function(e)
                                    return not table.contains(a.excluded_templates, e.template_name) and
                                               not enemy_cooldowns[e.id] and
                                               (not attack.check_gold_bag or e.enemy.gold_bag > 0)
                                end)

                            if not target then
                                -- block empty
                            else
                                enemy_cooldowns[target.id] = store.tick_ts + a.enemy_cooldown
                                pixie.attack_ts = store.tick_ts
                                pixie.target_id = target.id
                                pixie.attack = attack
                                pixie.attack_level = pow_t.level
                                a.ts = store.tick_ts

                                break
                            end
                        end
                    end
                end
            end
        end

        coroutine.yield()
    end
end

scripts.decal_pixie = {}

function scripts.decal_pixie.update(this, store)
    local iflip = this.idle_flip
    local a, o, e, slot_pos, slot_flip, enemy_flip

    U.y_animation_play(this, "teleportIn", slot_flip, store.tick_ts)

    while true do
        if this.target_id ~= nil then
            local target = store.entities[this.target_id]

            if not target or target.health.dead then
                -- block empty
            else
                a = this.attack

                U.y_animation_play(this, "teleportOut", nil, store.tick_ts)
                U.y_wait(store, 0.5)
                SU.stun_inc(target)

                slot_pos, slot_flip, enemy_flip = U.melee_slot_position(this, target, 1)
                this.pos.x, this.pos.y = slot_pos.x, slot_pos.y

                U.y_animation_play(this, "teleportIn", slot_flip, store.tick_ts)
                U.animation_start(this, a.animation, nil, store.tick_ts, false)
                U.y_wait(store, 0.3)

                if a.type == "mod" then
                    e = E:create_entity(a.mod)
                    e.modifier.source_id = this.id
                    e.modifier.target_id = target.id
                    e.modifier.level = this.attack_level
                else
                    e = E:create_entity(a.bullet)
                    e.bullet.source_id = this.id
                    e.bullet.target_id = target.id
                    e.bullet.from = V.v(this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y)
                    e.bullet.to = V.v(target.pos.x, target.pos.y)
                    e.bullet.hit_fx = e.bullet.hit_fx .. (target.unit.size >= UNIT_SIZE_MEDIUM and "big" or "small")
                    e.pos = V.vclone(e.bullet.from)
                end

                queue_insert(store, e)
                U.y_animation_wait(this)
                U.y_animation_play(this, "teleportOut", nil, store.tick_ts)
                SU.stun_dec(target)

                o = this.idle_pos
                this.pos.x, this.pos.y = this.owner.pos.x + o.x, this.owner.pos.y + o.y

                U.y_animation_play(this, "teleportIn", slot_flip, store.tick_ts)
            end

            this.target_id = nil
        elseif store.tick_ts - iflip.ts > iflip.cooldown then
            U.animation_start(this, table.random(iflip.animations), math.random() < 0.5, store.tick_ts, iflip.loop)

            iflip.ts = store.tick_ts
        end

        coroutine.yield()
    end
end

scripts.decal_drow_queen_portal = {}

function scripts.decal_drow_queen_portal.update(this, store)
    local current_pack
    local pack_idx = 1
    local pi_nodes = {}
    local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y, this.path_ids)

    for _, item in pairs(nearest_nodes) do
        pi_nodes[item[1]] = item[3] + 2
    end

    while true do
        while not this.pack do
            coroutine.yield()
        end

        current_pack = this.pack
        this.pack_finished = nil
        this.tween.ts = store.tick_ts
        this.tween.reverse = nil
        this.tween.disabled = nil

        for _, row in pairs(current_pack.waves) do
            local tn, interval, qty, sub0 = unpack(row, 1, 4)

            for i = 1, qty do
                log.debug("(%s)decal_drow_queen_portal spawning:%s", this.id, tn)

                local o = this.spawn_offsets[sub0 + 1]
                local e = E:create_entity(tn)

                e.nav_path.pi = current_pack.pi
                e.nav_path.spi = sub0 + 1
                e.nav_path.ni = pi_nodes[current_pack.pi]
                e.pos.x, e.pos.y = this.pos.x + o.x, this.pos.y + o.y
                e.enemy.gold = 0

                queue_insert(store, e)

                local fx = E:create_entity("fx_drow_queen_portal")

                fx.render.sprites[1].ts = store.tick_ts
                fx.pos.x, fx.pos.y = e.pos.x, e.pos.y - 1

                queue_insert(store, fx)
                coroutine.yield()

                if interval > 0 and U.y_wait(store, fts(interval), function()
                    return this.pack == nil
                end) then
                    log.debug("(%s)decal_drow_queen_portal interrupted", this.id)

                    goto label_571_0
                end
            end
        end

        log.debug("(%s)decal_drow_queen_portal finished", this.id)

        ::label_571_0::

        this.pack = nil
        this.pack_finished = true
        this.tween.ts = store.tick_ts
        this.tween.reverse = true
        this.tween.disabled = nil
        current_pack = nil
    end
end

scripts.decal_s12_lemur = {}

function scripts.decal_s12_lemur.update(this, store)
    local clicked = false

    ::label_573_0::

    this.nav_path.ni = 1
    this.pos = P:node_pos(this.nav_path)

    U.y_wait(store, U.frandom(this.wait_time[1], this.wait_time[2]))

    this.tween.ts = store.tick_ts
    this.tween.reverse = false

    while this.nav_path.ni < this.action_ni do
        SU.y_enemy_walk_step(store, this, "running", 1)
    end

    U.animation_start(this, "idle", nil, store.tick_ts, true)

    this.ui.clicked = nil

    local show_time = U.frandom(this.show_time[1], this.show_time[2])

    if U.y_wait(store, show_time, function()
        return this.ui.clicked == true
    end) then
        U.y_animation_play(this, "action", nil, store.tick_ts)
        -- AC:got(this.achievement)

        clicked = true
    end

    while SU.y_enemy_walk_step(store, this, "running", 1) do
        if not this.tween.reverse and this.nav_path.ni > this.fade_ni then
            this.tween.reverse = true
            this.tween.ts = store.tick_ts
        end
    end

    if not clicked then
        goto label_573_0
    end

    queue_remove(store, this)
end

scripts.birds_formation_controller = {}

function scripts.birds_formation_controller.update(this, store)
    while true do
        U.y_wait(store, U.frandom(this.wait_time[1], this.wait_time[2]))

        for ii, n in ipairs(this.names) do
            local o = this.offsets and this.offsets[ii] or V.v(0, 0)
            local from = V.v(this.from.x + o.x, this.from.y + o.y)
            local to = V.v(this.to.x + o.x, this.to.y + o.y)
            local e = E:create_entity(this.bird_template)

            e.render.sprites[1].name = n
            e.render.sprites[1].ts = U.frandom(0, 1)
            e.render.sprites[1].flip_x = from.x > to.x
            e.tween.props[1].keys = {{0, from}, {this.time, to}}
            e.tween.ts = store.tick_ts

            queue_insert(store, e)
        end
    end
end

scripts.decal_metropolis_portal = {}

function scripts.decal_metropolis_portal.update(this, store)
    local function should_activate()
        local enemies = table.filter(store.enemies, function(k, v)
            if v.pending_removal or not v.enemy or not v.vis or not v.nav_path or not v.health or v.health.dead or
                band(v.vis.flags, this.vis_bans) ~= 0 or band(v.vis.bans, this.vis_flags) ~= 0 or
                not P:is_node_valid(v.nav_path.pi, v.nav_path.ni) then
                return false
            end

            if this.detection_paths and not table.contains(this.detection_paths, v.nav_path.pi) then
                return false
            end

            for _, r in pairs(this.detection_rects) do
                if V.is_inside(v.pos, r) then
                    return true
                end
            end

            return false
        end)

        return #enemies > 0
    end

    if this.detection_tags then
        this.detection_rects = {}

        for _, tag in pairs(this.detection_tags) do
            local es = LU.list_entities(store.entities, this.template_name, tag)

            if #es == 1 then
                local e = es[1]
                local rect = table.deepclone(e.detection_rect)

                rect.pos.x, rect.pos.y = rect.pos.x + e.pos.x, rect.pos.y + e.pos.y

                table.insert(this.detection_rects, rect)
            end
        end
    end

    while true do
        this.render.sprites[1].hidden = true

        while not should_activate() do
            coroutine.yield()
        end

        this.active = true
        this.tween.reverse = false
        this.tween.ts = store.tick_ts
        this.render.sprites[1].hidden = false

        U.y_animation_play(this, "start", nil, store.tick_ts, 1, 1)
        U.animation_start(this, "loop", nil, store.tick_ts, true, 1)

        while should_activate() or not this.render.sprites[1].sync_flag do
            coroutine.yield()
        end

        this.active = false
        this.tween.reverse = true
        this.tween.ts = store.tick_ts

        U.y_animation_play(this, "end", nil, store.tick_ts, 1, 1)
    end
end

scripts.tower_black_baby_dragon = {}

function scripts.tower_black_baby_dragon.get_info(this)
    return {
        desc = "ELVES_BABY_BERESAD_DESCRIPTION",
        type = STATS_TYPE_TEXT
    }
end

function scripts.tower_black_baby_dragon.update(this, store)
    local e = E:create_entity("decal_black_baby_dragon")

    e.pos.x, e.pos.y = this.pos.x, this.pos.y
    e.sleep_pos = V.vclone(e.pos)

    queue_insert(store, e)

    while true do
        this.ui.can_select = not e.attack_requested

        if this.user_selection.arg and not e.attack_requested then
            this.user_selection.arg = nil

            local attack = this.attacks.list[1]

            store.player_gold = store.player_gold - attack.price
            e.attack_requested = true
        end

        coroutine.yield()
    end
end

scripts.decal_black_baby_dragon = {}

function scripts.decal_black_baby_dragon.update(this, store)
    local image_x = 128
    local shadow_ref_height = 150
    local shadow_offset = 0
    local dragon_offset = V.v(-75, 40)
    local dragon_sort_offset = -80
    local ps_flame_offset = V.v(-37, 66)
    local s = this.render.sprites[1]
    local zzz = this.render.sprites[2]
    local shadow = this.render.sprites[3]
    local hit_fire = this.render.sprites[4]

    shadow.scale = V.v(1, 1)

    local wakeup_ts = 0
    local wakeup_cooldown = math.random(this.wakeup_cooldown_min, this.wakeup_cooldown_max)
    local ps_flame = E:create_entity("ps_baby_black_dragon_flame")

    ps_flame.particle_system.track_id = this.id
    ps_flame.particle_system.emit = false
    ps_flame.particle_system.track_offset = V.vclone(ps_flame_offset)
    ps_flame.particle_system.sort_y_offset = -20

    queue_insert(store, ps_flame)

    local function update_shadow()
        local dy = this.pos.y - this.sleep_pos.y
        local scale = km.clamp(0, 1, 1 - dy / shadow_ref_height)

        shadow.scale.x, shadow.scale.y = scale, scale
        shadow.offset.y = shadow_offset - dy
    end

    ::label_581_0::

    while true do
        if this.attack_requested then
            shadow.hidden = true

            S:queue(this.sound_events.wakeup, {
                delay = fts(13)
            })
            U.y_animation_play(this, "wakeUp", false, store.tick_ts, 1, 1)

            s.z = Z_OBJECTS_SKY

            U.animation_start(this, "fly", true, store.tick_ts, true, 1)

            local takeoff_dest = V.v(store.visible_coords.right + image_x / 2, this.pos.y + 200)
            local takeoff_duration = 2

            U.y_ease_keys(store, {this.pos, this.pos}, {"x", "y"}, {this.pos.x, this.pos.y},
                {takeoff_dest.x, takeoff_dest.y}, takeoff_duration, {"quad-out", "linear"})

            s.loop_forced = true

            for _, pass in pairs(this.dragon_passes) do
                this.nav_path.pi = pass.path_id
                this.nav_path.ni = 1
                this.pos = P:node_pos(this.nav_path)

                local nex, new = P:next_entity_node(this, store.tick_length)
                local flip = nex.x < this.pos.x
                local flip_sign = flip and -1 or 1
                local flame_i, flame_range = next(pass.ranges)
                local flame_on = false
                local fire_on = false
                local flame_ni_offset = 0
                local last_decal_ni, decal_ni_dist, decal_ni_offset = 0, 8, 0

                s.offset = V.v(dragon_offset.x * flip_sign, dragon_offset.y)
                s.sort_y_offset = dragon_sort_offset
                this.render.sprites[1].flip_x = not flip
                ps_flame.particle_system.track_offset.x = ps_flame_offset.x * flip_sign
                ps_flame.particle_system.emit_direction = (flip and -5 or -1) * math.pi / 6
                ps_flame.particle_system.scales_x = {flip_sign, flip_sign}
                hit_fire.flip_x = flip

                while nex do
                    local flame_ni = this.nav_path.ni + flame_ni_offset

                    if not flame_on and flame_range and flame_ni >= flame_range[1] and flame_ni <= flame_range[2] then
                        S:queue(this.sound_events.fire_loop)
                        S:queue(this.sound_events.fire_start)

                        ps_flame.particle_system.emit = true

                        U.animation_start(this, "attack", nil, store.tick_ts, true, 1)

                        flame_on = true
                        last_decal_ni = this.nav_path.ni - decal_ni_dist / 2
                    elseif flame_on and flame_range and (flame_ni < flame_range[1] or flame_ni > flame_range[2]) then
                        S:stop(this.sound_events.fire_loop)
                        S:queue(this.sound_events.fire_stop)

                        ps_flame.particle_system.emit = false

                        U.animation_start(this, "fly", nil, store.tick_ts, true, 1)

                        flame_on = false

                        local fx = E:create_entity("fx_baby_black_dragon_flame_hit")

                        fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                        fx.tween.ts = store.tick_ts

                        queue_insert(store, fx)

                        hit_fire.hidden = true
                        flame_i, flame_range = next(pass.ranges, flame_i)
                    end

                    if flame_on and decal_ni_dist < this.nav_path.ni - last_decal_ni then
                        local aura = E:create_entity(this.attacks.list[1].aura)

                        aura.pos = P:node_pos(this.nav_path.pi, 1, this.nav_path.ni + decal_ni_offset)
                        aura.aura.duration = U.frandom(0.8, 1.2) * aura.aura.duration
                        aura.render.sprites[2].flip_x = math.random() < 0.5

                        queue_insert(store, aura)

                        last_decal_ni = this.nav_path.ni
                        hit_fire.hidden = false
                    end

                    U.set_destination(this, nex)
                    U.walk(this, store.tick_length)

                    nex, new = P:next_entity_node(this, store.tick_length)

                    coroutine.yield()
                end
            end

            s.loop_forced = false
            s.offset = V.v(0, 0)
            s.sort_y_offset = 0
            shadow.hidden = false

            update_shadow()
            U.animation_start(this, "fly", true, store.tick_ts, true, 1, true)

            this.pos.x, this.pos.y = this.sleep_pos.x, REF_H

            local a_from, a_to = this.pos.y, this.sleep_pos.y
            local approach_duration = math.floor(2.5 / fts(18)) * fts(18) + fts(10)
            local start_ts = store.tick_ts
            local phase

            repeat
                phase = (store.tick_ts - start_ts) / approach_duration
                this.pos.y = U.ease_value(a_from, a_to, phase, "quad-in")

                update_shadow()
                coroutine.yield()
            until phase >= 1

            U.y_animation_play(this, "land", false, store.tick_ts, 1, 1)
            U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

            shadow.hidden = true
            s.sort_y_offset = 0
            s.z = Z_OBJECTS
            this.attack_requested = nil
        elseif wakeup_cooldown < store.tick_ts - wakeup_ts then
            S:queue(this.sound_events.wakeup, {
                delay = fts(13)
            })
            U.y_animation_play(this, "sneeze", nil, store.tick_ts, 1, 1)

            wakeup_cooldown = math.random(this.wakeup_cooldown_min, this.wakeup_cooldown_max)
            wakeup_ts = store.tick_ts
        else
            zzz.hidden = false
            zzz.alpha = 255

            U.animation_start(this, "zzz", nil, store.tick_ts, false, 2)

            while not U.animation_finished(this, 2) do
                if this.attack_requested then
                    this.tween.disabled = false
                    this.tween.props[1].time_offset = zzz.ts - store.tick_ts

                    U.y_wait(store, this.tween.props[1].keys[2][1])

                    this.tween.disabled = true

                    goto label_581_0
                end

                coroutine.yield()
            end

            zzz.hidden = true
        end

        coroutine.yield()
    end
end

scripts.mod_black_baby_dragon = {}

function scripts.mod_black_baby_dragon.insert(this, store)
    if scripts.mod_dps.insert(this, store, script) then
        local target = store.entities[this.modifier.target_id]
        local d = E:create_entity("damage")

        d.source_id = this.id
        d.target_id = target.id
        d.value = this.insert_damage
        d.damage_type = this.dps.damage_type

        queue_damage(store, d)

        return true
    else
        return false
    end
end

scripts.soldier_baby_ashbite = {}

function scripts.soldier_baby_ashbite.ranged_filter_fn(e, origin)
    local pp = P:predict_enemy_pos(e, fts(12))
    local allow = math.abs(pp.x - origin.x) > 30

    return allow
end

function scripts.soldier_baby_ashbite.blazing_breath_filter_fn(e, origin)
    local pp = P:predict_enemy_pos(e, 0.33 + fts(9))
    local allow = math.abs(pp.x - origin.x) > 30 and math.abs(pp.x - origin.x) < 150 and math.abs(pp.y - origin.y) < 120

    return allow
end

function scripts.soldier_baby_ashbite.get_info(this)
    local b = E:get_template(this.ranged.attacks[1].bullet)
    local min, max = b.bullet.damage_min, b.bullet.damage_max

    return {
        type = STATS_TYPE_SOLDIER,
        hp = this.health.hp,
        hp_max = this.health.hp_max,
        damage_min = min,
        damage_max = max,
        -- damage_icon = this.info.damage_icon,
        armor = this.health.armor,
        magic_armor = this.health.magic_armor,
        respawn = this.health.dead_lifetime
    }
end

function scripts.soldier_baby_ashbite.insert(this, store)
    this.ranged.order = U.attack_order(this.ranged.attacks)

    if this.powers then
        for pn, p in pairs(this.powers) do
            for i = 1, p.level do
                SU.soldier_power_upgrade(this, pn)
            end
        end
    end

    this.vis._bans = this.vis.bans
    this.vis.bans = F_ALL

    return true
end

function scripts.soldier_baby_ashbite.update(this, store)
    local brk, sta

    if this.vis._bans then
        this.vis.bans = this.vis._bans
        this.vis._bans = nil
    end

    this.render.sprites[1].z = Z_BULLETS

    U.y_animation_play(this, "hatch", nil, store.tick_ts)

    this.render.sprites[1].z = Z_OBJECTS
    this.render.sprites[1].ts = store.tick_ts

    while true do
        if this.powers then
            for pn, p in pairs(this.powers) do
                if p.changed then
                    p.changed = nil

                    SU.soldier_power_upgrade(this, pn)
                end
            end
        end

        if this.health.dead then
            SU.y_hero_death_and_respawn(store, this)
        end

        while this.nav_rally.new do
            if SU.y_soldier_new_rally(store, this) then
                goto label_590_0
            end
        end

        if this.ranged then
            brk, sta = SU.y_soldier_ranged_attacks(store, this)

            if brk then
                goto label_590_0
            elseif sta == A_DONE then
                SU.soldier_idle(store, this, true)
            end
        end

        if SU.soldier_go_back_step(store, this) then
            -- block empty
        else
            SU.soldier_idle(store, this)
            SU.soldier_regen(store, this)
        end

        ::label_590_0::

        coroutine.yield()
    end
end

scripts.decal_emit_breath_baby_ashbite = {}

function scripts.decal_emit_breath_baby_ashbite.update(this, store)
    local start_ts = store.tick_ts
    local soldier = store.entities[this.source_id]
    local direction = V.angleTo(this.to.x - this.pos.x, this.to.y - this.pos.y)

    this.render.sprites[1].r = direction

    local emit_ps = E:create_entity(this.emit_ps)
    local mspeed = V.dist(this.to.x, this.to.y, this.pos.x, this.pos.y) / this.flight_time

    emit_ps.particle_system.emit_direction = direction
    emit_ps.particle_system.emit_speed = {mspeed, mspeed}
    emit_ps.particle_system.flip_x = this.to.x < this.pos.x
    emit_ps.particle_system.particle_lifetime = {this.flight_time, this.flight_time}
    emit_ps.particle_system.source_lifetime = this.duration
    emit_ps.pos.x, emit_ps.pos.y = this.pos.x, this.pos.y

    queue_insert(store, emit_ps)
    U.y_wait(store, this.duration, function()
        return soldier.health.dead or soldier.nav_rally.new
    end)

    emit_ps.particle_system.emit = false
    emit_ps.particle_system.source_lifetime = 0

    queue_remove(store, this)
end

scripts.aura_fiery_mist_baby_ashbite = {}

function scripts.aura_fiery_mist_baby_ashbite.update(this, store)
    local a = this.aura
    local node, spi

    a.ts = store.tick_ts

    local last_cycle_ts = store.tick_ts - a.cycle_time
    local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

    if #nodes < 1 then
        log.error("aura_fiery_mist_baby_ashbite: could not find node for aura")
    else
        node = {
            pi = nodes[1][1],
            spi = nodes[1][2],
            ni = nodes[1][3]
        }
        this.pos = P:node_pos(node.pi, 1, node.ni)
        spi = 1

        for i = 1, 8 do
            local ni = node.ni - 3 + i

            if P:is_node_valid(node.pi, ni) then
                local fx = E:create_entity(this.fx)

                fx.pos = P:node_pos(node.pi, spi, ni)
                fx.pos.x, fx.pos.y = fx.pos.x + math.random(-4, 4), fx.pos.y + math.random(-4, 4)

                local scale = U.frandom(0.9, 1.1)

                fx.render.sprites[1].scale = V.v(scale, scale)
                fx.render.sprites[1].time_offset = fts(i * 2)
                fx.duration = U.frandom(0.95, 1.05) * a.duration
                fx.tween.ts = store.tick_ts

                queue_insert(store, fx)
            else
                log.debug("aura_fiery_mist_baby_ashbite: path %s,%s,%s is not valid", pi, spi, ni)
            end

            spi = km.zmod(spi + 2, 3)
        end

        while true do
            if store.tick_ts - a.ts > a.duration then
                break
            end

            if store.tick_ts - last_cycle_ts > a.cycle_time then
                last_cycle_ts = store.tick_ts

                local targets = U.find_enemies_in_range(store.enemies, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)

                if targets then
                    for _, target in pairs(targets) do
                        local m = E:create_entity(a.mod)

                        m.modifier.target_id = target.id
                        m.modifier.source_id = this.id
                        m.modifier.level = a.level
                        m.slow.factor = m.slow.factor + m.slow.factor_inc * a.level

                        queue_insert(store, m)

                        local d = E:create_entity("damage")

                        d.source_id = this.id
                        d.target_id = target.id

                        local dmin, dmax = a.damage_min, a.damage_max

                        if a.damage_inc then
                            dmin = dmin + a.damage_inc * a.level
                            dmax = dmax + a.damage_inc * a.level
                        end

                        d.value = math.random(dmin, dmax)
                        d.damage_type = a.damage_type

                        queue_damage(store, d)
                    end
                end
            end

            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.decal_s14_break_spider = {}

function scripts.decal_s14_break_spider.update(this, store)
    local c = this.click_play
    local s = this.render.sprites[1]
    local clicks = 0

    if s.scale then
        for _, p in pairs(this.tween.props[1].keys) do
            p[2].x = p[2].x * s.scale.x
            p[2].y = p[2].y * s.scale.y
        end
    end

    while true do
        if this.ui.clicked then
            this.ui.clicked = nil
            clicks = clicks + 1
            this.tween.ts = store.tick_ts
        end

        if clicks > c.required_clicks then
            this.ui.can_click = false
            clicks = 0

            U.animation_start(this, "open", nil, store.tick_ts, false)
            U.y_wait(store, fts(4))

            local pis = {this.pi}
            local nodes = P:nearest_nodes(this.pos.x, this.pos.y, pis)

            for i = 1, 3 do
                local npos = P:node_pos(nodes[1][1], nodes[1][2], nodes[1][3] + 6 * (i - 2))
                local e = E:create_entity("decal_s14_break_spider")

                e.pos.x, e.pos.y = this.pos.x, this.pos.y
                e.tween.ts = store.tick_ts
                e.tween.props[2].keys[2][2] = V.v(npos.x - this.pos.x, npos.y - this.pos.y)

                queue_insert(store, e)
            end
        end

        coroutine.yield()
    end
end

scripts.decal_s15_mactans = {}

function scripts.decal_s15_mactans.update(this, store)
    local attack_ts, cooldown = 0, 0
    local attack_pending, attack_loop

    this.phase_signal = "attack"

    while true do
        if this.phase_signal == "attack" then
            this.phase_signal = nil
            attack_loop = true
            attack_pending = true
            attack_ts = store.tick_ts
        elseif this.phase_signal == "single_attack" then
            this.phase_signal = nil
            attack_ts = store.tick_ts - cooldown - 1
            attack_loop = false
            attack_pending = true
        elseif this.phase_signal == "stop" then
            this.phase_signal = nil
            attack_loop = false
            attack_pending = false
        elseif this.phase_signal == "jump_out" then
            this.phase_signal = nil

            U.y_animation_play(this, "jumpOut", nil, store.tick_ts)
            U.sprites_hide(this)

            this.phase = "out"

            while this.phase_signal ~= "jump_in" do
                coroutine.yield()
            end

            this.phase_signal = nil

            U.sprites_show(this)
            U.y_animation_play(this, "jumpIn", nil, store.tick_ts)
        elseif this.phase_signal == "jump" then
            U.y_animation_play(this, "jumpToCrystal", nil, store.tick_ts, 1)
            queue_remove(store, this)

            return
        end

        if attack_pending and cooldown < store.tick_ts - attack_ts then
            this.phase = "attack"

            S:queue("ElvesFinalBossGemattackSpider")
            U.animation_start(this, "attack", nil, store.tick_ts, false)
            U.y_wait(store, fts(11))

            this.decal_statue.phase_signal = "hit"

            U.y_animation_wait(this)

            attack_ts = store.tick_ts
            cooldown = U.frandom(4, 6)
            attack_pending = attack_loop
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true)

        this.phase = "idle"

        coroutine.yield()
    end
end

scripts.decal_s15_malicia = {}

function scripts.decal_s15_malicia.update(this, store)
    local ray = this.render.sprites[2]
    local ray_duration = U.frandom(4, 6)
    local attack_ts, cooldown = 0, 0
    local attack_pending, attack_loop

    this.phase_signal = "attack"

    while true do
        if this.phase_signal == "attack" then
            this.phase_signal = nil
            attack_loop = true
            attack_pending = true
            attack_ts = store.tick_ts
        elseif this.phase_signal == "single_attack" then
            this.phase_signal = nil
            attack_ts = store.tick_ts - cooldown - 1
            ray_duration = 2
            attack_loop = false
            attack_pending = true
        elseif this.phase_signal == "stop" then
            this.phase_signal = nil
            attack_loop = false
            attack_pending = false
        elseif this.phase_signal == "jump" then
            U.y_animation_play(this, "jumpToCrystal", nil, store.tick_ts, 1, 1)
            queue_remove(store, this)

            return
        end

        if attack_pending and cooldown < store.tick_ts - attack_ts then
            this.phase = "attack"

            S:queue("ElvesFinalBossGemattackMalicia")

            ray.hidden = false

            U.animation_start(this, "attack", nil, store.tick_ts, true, 1)
            U.y_wait(store, ray_duration, function()
                return this.phase_signal == "stop"
            end)

            ray.hidden = true
            attack_ts = store.tick_ts
            cooldown = U.frandom(5, 10)
            ray_duration = U.frandom(4, 6)
            attack_pending = attack_loop
        end

        U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

        this.phase = "idle"

        coroutine.yield()
    end
end

scripts.decal_s15_statue = {}

function scripts.decal_s15_statue.update(this, store)
    local crystal = this.render.sprites[1]

    while true do
        if this.phase_signal == "break" then
            S:queue("ElvesFinalBossGemCrystalBreak")
            U.y_animation_play(this, "break", nil, store.tick_ts)

            this.render.sprites[1].z = Z_DECALS
            this.phase = "broken"

            return
        elseif this.phase_signal == "hit" then
            this.phase_signal = nil

            U.y_animation_play(this, "hit", nil, store.tick_ts)
            U.animation_start(this, "idle", nil, store.tick_ts, true)
        end

        coroutine.yield()
    end
end

scripts.gnoll_bush_spawner = {}

function scripts.gnoll_bush_spawner.update(this, store)
    local sp = this.spawner

    while true do
        if sp.interrupt then
            -- block empty
        elseif sp.spawn_data then
            local gnoll_type = sp.spawn_data.gnollType

            sp.spawn_data = nil
            sp.count = 1

            local brk, spawns = SU.y_spawner_spawn(store, this)

            if brk then
                -- block empty
            elseif spawns and #spawns > 0 then
                spawns[1].spawner.entity = gnoll_type
                spawns[1].spawner.node_offset = this.spawn_node_offset
            end
        end

        sp.interrupt = nil
        sp.spawn_data = nil

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.gnoll_bush = {}

function scripts.gnoll_bush.update(this, store)
    local sp = this.spawner
    local original_pi = this.nav_path.pi
    local sit_node = math.random(unpack(this.walk_nodes_range))

    if this.spawner.entity ~= "enemy_gnoll_gnawer" then
        this.render.sprites[1].scale = V.v(0.8, 0.8)
    end

    while true do
        SU.y_enemy_walk_step(store, this, "walk")

        if sp.interrupt then
            sp.count = 0

            break
        elseif original_pi ~= this.nav_path.pi then
            this.spawner.pi = this.nav_path.pi
            this.spawner.ni = this.nav_path.ni

            break
        elseif sit_node <= this.nav_path.ni then
            sit_node = this.nav_path.ni + math.random(unpack(this.walk_nodes_range))

            U.y_animation_play(this, "sitDown", nil, store.tick_ts)
            U.y_wait(store, this.walk_wait)
            U.y_animation_play(this, "standUp", nil, store.tick_ts)
        end

        coroutine.yield()
    end

    U.animation_start(this, "explode", nil, store.tick_ts)
    U.y_wait(store, fts(3))

    if sp.count > 0 then
        SU.y_spawner_spawn(store, this)
    end

    S:queue("ElvesGnollTrailOut")
    U.y_animation_wait(this)
    queue_remove(store, this)
end

scripts.malik_slave_controller = {}

function scripts.malik_slave_controller.fn_can_power(this, store, power_id, pos)
    if this.ready_to_free and power_id == GUI_MODE_POWER_1 and V.is_inside(pos, this.thunder_rect) then
        this.got_thunder = true

        return true
    else
        return false
    end
end

function scripts.malik_slave_controller.update(this, store)
    local function do_thunder_fx(pos)
        -- local e = E:create_entity("fx_power_thunder_explosion")
        local e= E:create_entity("fx_fireball_explosion")
        e.pos.x, e.pos.y = pos.x, pos.y
        e.render.sprites[1].ts = store.tick_ts
        -- e.render.sprites[2].ts = store.tick_ts

        queue_insert(store, e)

        -- e = E:create_entity("fx_power_thunder_explosion_decal")
        -- e.pos.x, e.pos.y = pos.x, pos.y
        -- e.render.sprites[1].ts = store.tick_ts

        -- queue_insert(store, e)
    end

    local function y_await_arrival(entities)
        coroutine.yield()

        for _, e in pairs(entities) do
            while not e.motion.arrived do
                coroutine.yield()
            end
        end
    end

    local function is_free()
        return this.got_thunder
    end

    while store.wave_group_number < this.starting_wave do
        coroutine.yield()
    end

    local wp = this.walk_points
    local g1 = E:create_entity("decal_gnoll_gnawer")
    local g2 = E:create_entity("decal_gnoll_gnawer")
    local m1 = E:create_entity("decal_baby_malik_slave")
    local sign = E:create_entity("decal_baby_malik_slave_banner")
    local free_seq = E:create_entity("decal_baby_malik_slave_free")
    local decals = {g1, g2, m1}

    g1.walk_points = this.walk_points.gnoll_left
    g2.walk_points = this.walk_points.gnoll_right
    m1.walk_points = this.walk_points.malik
    g1.pos = V.vclone(g1.walk_points[1])
    g2.pos = V.vclone(g2.walk_points[1])
    m1.pos = V.vclone(m1.walk_points[1])
    sign.pos = m1.pos

    queue_insert(store, g1)
    queue_insert(store, g2)
    queue_insert(store, m1)
    queue_insert(store, sign)
    queue_insert(store, free_seq)

    while true do
        for _, e in pairs(decals) do
            e.motion.arrived = false
            e.nav_grid.waypoints = table.deepclone(e.walk_points)
        end

        y_await_arrival(decals)

        this.ready_to_free = true

        U.animation_start(g1, "idle", false, store.tick_ts, true)
        U.animation_start(g2, "idle", true, store.tick_ts, true)
        U.animation_start(m1, "work", true, store.tick_ts, true)

        local t1 = U.frandom(1, 2)

        if U.y_wait(store, t1, is_free) then
            break
        end

        sign.tween.ts = store.tick_ts

        if U.y_wait(store, this.wait_time - t1, is_free) then
            break
        end

        this.ready_to_free = false

        for _, e in pairs(decals) do
            e.motion.arrived = false
            e.nav_grid.waypoints = table.reverse(e.walk_points, true)
        end

        y_await_arrival(decals)
        U.animation_start(g1, "idle", false, store.tick_ts, true)
        U.animation_start(g2, "idle", true, store.tick_ts, true)
        U.animation_start(m1, "idle", true, store.tick_ts, true)
        U.y_wait(store, this.wait_time)
        coroutine.yield()
    end

    this.ready_to_free = false

    do_thunder_fx(g1.pos)
    do_thunder_fx(g2.pos)
    U.animation_start(g1, "death", nil, store.tick_ts, false)
    U.animation_start(g2, "death", nil, store.tick_ts, false)
    U.animation_start(m1, "idle", true, store.tick_ts, true)
    U.y_wait(store, 4)

    g1.tween.ts = store.tick_ts
    g2.tween.ts = store.tick_ts
    g1.tween.disabled = nil
    g2.tween.disabled = nil
    m1.render.sprites[1].hidden = true
    free_seq.render.sprites[1].hidden = false
    free_seq.pos = m1.pos

    S:queue("ElvesMalikHammer")
    U.y_animation_play(free_seq, nil, nil, store.tick_ts)

    local hero = LU.insert_hero(store, "hero_baby_malik", this.hero_spawn_pos)

    hero.nav_grid.ignore_waypoints = true
    hero.nav_rally.new = true
    hero.nav_rally.pos = V.v(575, 557)
    hero.nav_rally.center = V.v(575, 557)

    coroutine.yield()

    free_seq.render.sprites[1].hidden = true

    -- AC:got(this.achievement_id)
    queue_remove(store, g1)
    queue_remove(store, g2)
    queue_remove(store, m1)
    queue_remove(store, sign)
    queue_remove(store, free_seq)
    queue_remove(store, this)
end

scripts.decal_walking = {}

function scripts.decal_walking.update(this, store)
    local n = this.nav_grid

    while true do
        if n.waypoints and #n.waypoints > 1 then
            local dest = n.waypoints[#n.waypoints]
            local orig = table.remove(n.waypoints, 1)

            this.pos.x, this.pos.y = orig.x, orig.y

            while not V.veq(this.pos, dest) do
                local w = table.remove(n.waypoints, 1) or dest

                U.set_destination(this, w)

                local an, af = U.animation_name_facing_point(this, "walkingRightLeft", this.motion.dest)

                U.animation_start(this, an, af, store.tick_ts, true)

                while not this.motion.arrived do
                    U.walk(this, store.tick_length)
                    coroutine.yield()

                    this.motion.speed.x, this.motion.speed.y = 0, 0
                end
            end
        end

        coroutine.yield()
    end
end

scripts.decal_s18_roadrunner_bush = {}

function scripts.decal_s18_roadrunner_bush.update(this, store)
    local clicks = 0
    local required_clicks = math.random(this.required_clicks[1], this.required_clicks[2])
    local shake_cooldown = math.random(this.shake_cooldown[1], this.shake_cooldown[2])
    local shake_ts = store.tick_ts

    while true do
        if this.ui.clicked then
            this.ui.clicked = nil
            clicks = clicks + 1

            if required_clicks <= clicks then
                local fx = E:create_entity("fx_roadruner_bush_explode")

                fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
                fx.render.sprites[1].ts = store.tick_ts

                queue_insert(store, fx)

                local rr = E:create_entity("decal_s18_roadrunner")

                rr.render.sprites[1].ts = store.tick_ts

                queue_insert(store, rr)

                local coyo = E:create_entity("decal_s18_coyote")

                coyo.render.sprites[1].ts = store.tick_ts

                queue_insert(store, coyo)
                U.animation_start(coyo, "pull", nil, store.tick_ts)
                U.y_wait(store, 1.9)
                S:queue(coyo.sound_events.push)
                U.y_animation_play(coyo, "push", nil, store.tick_ts)
                -- AC:got("WILE")
                U.y_ease_key(store, coyo.render.sprites[1], "alpha", 255, 0, 0.5)
                queue_remove(store, coyo)

                return
            else
                shake_ts = -99

                S:queue(this.sound_clicked)
            end
        end

        if shake_cooldown < store.tick_ts - shake_ts then
            this.render.sprites[1].ts = store.tick_ts
            shake_ts = store.tick_ts
        end

        coroutine.yield()
    end
end

scripts.decal_s19_drizzt = {}

function scripts.decal_s19_drizzt.update(this, store)
    local idle_ts = 0
    local idle_cooldown = math.random(this.idle_cooldown[1], this.idle_cooldown[2])
    local gnoll

    while true do
        if this.ui.clicked then
            this.ui.clicked = nil

            if gnoll and gnoll.phase == "joke" then
                gnoll.set_phase = "scared"

                S:queue(this.sound_chase, this.sound_chase_params)
                U.y_animation_play(this, "alert", nil, store.tick_ts)
                U.y_animation_play(this, "run", nil, store.tick_ts)

                break
            else
                S:queue(this.sound_clicked)
                U.y_animation_play(this, "alert", nil, store.tick_ts)
            end
        end

        if idle_cooldown < store.tick_ts - idle_ts then
            idle_ts = store.tick_ts
            this.render.sprites[1].ts = store.tick_ts

            if math.random() < 0.5 then
                idle_cooldown = math.random(this.idle_cooldown[1], this.idle_cooldown[2])
            else
                idle_cooldown = math.random(this.spawn_cooldown[1], this.spawn_cooldown[2])
                gnoll = E:create_entity("decal_s19_drizzt_gnoll")
                gnoll.pos.x, gnoll.pos.y = this.pos.x - 70, this.pos.y - 10

                queue_insert(store, gnoll)
            end
        end

        coroutine.yield()
    end

    queue_remove(store, this)
end

scripts.decal_s19_drizzt_gnoll = {}

function scripts.decal_s19_drizzt_gnoll.update(this, store)
    local out_x = this.pos.x
    local in_x = this.pos.x + 60
    local walk_time = 2
    local run_time = 0.6

    this.phase = "enter"

    U.animation_start(this, "walk", nil, store.tick_ts, true)
    U.y_ease_key(store, this.pos, "x", out_x, in_x, walk_time)

    this.phase = "joke"

    U.animation_start(this, "joke", nil, store.tick_ts, true)

    if U.y_wait(store, 2, function()
        return this.set_phase == "scared"
    end) then
        this.phase = "scared"

        U.y_animation_play(this, "scared", nil, store.tick_ts)
        U.animation_start(this, "walk", true, store.tick_ts, true)
        U.y_ease_key(store, this.pos, "x", in_x, out_x, run_time)
    else
        this.phase = "exit"

        U.animation_start(this, "idle", nil, store.tick_ts, false)
        U.y_wait(store, 1)
        U.animation_start(this, "walk", true, store.tick_ts, true)
        U.y_ease_key(store, this.pos, "x", in_x, out_x, walk_time)
    end

    queue_remove(store, this)
end

scripts.lava_fireball_controller = {}

function scripts.lava_fireball_controller.update(this, store)
    while store.wave_group_number < 1 do
        coroutine.yield()
    end

    while not store.waves_finished do
        local start_ts, last_ts
        local wave_number = store.wave_group_number
        local active = this.launch_active[store.level_mode][wave_number]
        local cooldown_normal = this.launch_cooldown[store.level_mode]
        local cooldown_boss = this.launch_cooldown_boss
        local duration = this.duration[store.level_mode]

        log.debug("lava_fireball_controller - running wave_number:%s active:%s waves_finished:%s", wave_number, active,
            store.waves_finished)

        if not active then
            -- block empty
        else
            start_ts = store.tick_ts

            while duration > store.tick_ts - start_ts do
                local boss = LU.list_entities(store.enemies, "eb_balrog")[1]
                local cooldown = boss and cooldown_boss or cooldown_normal

                U.y_wait(store, cooldown)

                local target = U.find_random_target(store.entities, V.v(0, 0), 0, 1e+99, F_RANGED,
                    bor(F_ENEMY, F_FLYING))

                if target then
                    local launch_pos = table.random(this.launch_points)

                    SU.insert_sprite(store, this.launch_fx, launch_pos)

                    local b = E:create_entity(this.bullet)

                    b.pos = V.vclone(launch_pos)
                    b.bullet.from = V.vclone(launch_pos)
                    b.bullet.to = V.vclone(target.pos)

                    queue_insert(store, b)
                end
            end
        end

        while store.wave_group_number == wave_number and not store.waves_finished do
            coroutine.yield()
        end
    end

    queue_remove(store, this)
end

scripts.decal_catapult_endless = {}

function scripts.decal_catapult_endless.update(this, store)
    local start_ts
    local a = this.ranged.attacks[1]
    local s2 = this.render.sprites[2]

    this.x_outside = this.pos.x

    while true do
        this.phase_signal = nil
        this.phase = "out"

        while this.phase_signal == nil do
            coroutine.yield()
        end

        local ms = a.munition_settings[a.munition_type]

        s2.prefix = ms[a.count == 1 and 0 or 1]
        a.bullet = ms.bullet
        this.phase = "enter"

        U.animation_start(this, "running", true, store.tick_ts, true)
        U.y_ease_key(store, this.pos, "x", this.x_outside, this.x_inside, this.transit_time)

        this.phase = "in"
        start_ts = store.tick_ts

        U.animation_start(this, "idle", true, store.tick_ts, true)

        while store.tick_ts - start_ts < this.duration do
            if store.tick_ts - a.ts > a.cooldown then
                local dest, d_pi, d_spi, d_ni, target

                if a.munition_type == 3 then
                    dest, d_pi, d_spi, d_ni = P:get_random_position(a.path_margins, TERRAIN_LAND, nil, true)
                else
                    local targets = table.filter(store.entities, function(k, v)
                        return not v.pending_removal and v.health and not v.health.dead and v.vis and
                                   band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and v.pos.x <
                                   a.max_x and v.pos.y > a.min_x
                    end)

                    if #targets > 0 then
                        local stunned = table.filter(targets, function(k, v)
                            return v.unit.is_stunned
                        end)

                        target = table.random(#stunned > 0 and stunned or targets)
                        dest = target.pos

                        local nodes = P:nearest_nodes(dest.x, dest.y)

                        if #nodes > 0 then
                            d_pi, d_spi, d_ni = unpack(nodes[1])
                        end
                    end
                end

                if not d_pi then
                    log.warning("%s: node for shooting not found", this.template_name)
                else
                    local an, af, ai = U.animation_name_facing_point(this, a.animation, dest)

                    U.animation_start(this, an, af, store.tick_ts, false)
                    U.y_wait(store, a.shoot_time)

                    local n_offsets = {0, -5, 5, -10, 10}

                    for i = 1, a.count do
                        local d = P:node_pos(d_pi, d_spi, d_ni + n_offsets[i])
                        local b = E:create_entity(a.bullet)

                        b.pos = V.vclone(this.pos)

                        local offset = a.bullet_start_offset[ai]

                        b.pos.x, b.pos.y = b.pos.x + (af and -1 or 1) * offset.x, b.pos.y + offset.y
                        b.bullet.from = V.vclone(b.pos)
                        b.bullet.to = V.vclone(d)

                        if a.munition_type == 3 then
                            local e = E:create_entity(a.barrel_payloads[a.barrel_payload_idx])

                            e.nav_path.pi = d_pi
                            e.nav_path.spi = d_spi
                            e.nav_path.ni = d_ni + 3
                            b.bullet.hit_payload = e
                        end

                        queue_insert(store, b)
                    end

                    U.y_animation_wait(this)
                    U.animation_start(this, "idle", nil, store.tick_ts)

                    a.ts = store.tick_ts
                end
            end

            coroutine.yield()
        end

        this.phase = "exit"

        U.animation_start(this, "running", false, store.tick_ts, true)
        U.y_ease_key(store, this.pos, "x", this.x_inside, this.x_outside, this.transit_time)
    end
end

return scripts



